#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Sep 29 14:55:36 2011 by generateDS.py version 2.6a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class antenna(GeneratedsSuper):
    """Basic antenna information as specified in the VCI messages. Antenna
    ID is needed only by the Correlator Backend. Detailed antenna
    information will be specified in the Antenna Table and made
    available to the Backend by some other means (e.g. as a file
    stored on a server)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, name=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if antenna.subclass:
            return antenna.subclass(*args_, **kwargs_)
        else:
            return antenna(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='antenna', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='antenna')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='antenna'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='antenna', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='antenna'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class antenna


class stbDataProducts(GeneratedsSuper):
    """Station Board data products."""
    subclass = None
    superclass = None
    def __init__(self, inputStateCounts=None, clipCounts=None, powerCounts=None, rfiCounts=None, outputStateCounts=None):
        self.inputStateCounts = inputStateCounts
        self.clipCounts = clipCounts
        self.powerCounts = powerCounts
        self.rfiCounts = rfiCounts
        self.outputStateCounts = outputStateCounts
    def factory(*args_, **kwargs_):
        if stbDataProducts.subclass:
            return stbDataProducts.subclass(*args_, **kwargs_)
        else:
            return stbDataProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inputStateCounts(self): return self.inputStateCounts
    def set_inputStateCounts(self, inputStateCounts): self.inputStateCounts = inputStateCounts
    def get_clipCounts(self): return self.clipCounts
    def set_clipCounts(self, clipCounts): self.clipCounts = clipCounts
    def get_powerCounts(self): return self.powerCounts
    def set_powerCounts(self, powerCounts): self.powerCounts = powerCounts
    def get_rfiCounts(self): return self.rfiCounts
    def set_rfiCounts(self, rfiCounts): self.rfiCounts = rfiCounts
    def get_outputStateCounts(self): return self.outputStateCounts
    def set_outputStateCounts(self, outputStateCounts): self.outputStateCounts = outputStateCounts
    def export(self, outfile, level, namespace_='widar:', name_='stbDataProducts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stbDataProducts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stbDataProducts'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stbDataProducts', fromsubclass_=False):
        if self.inputStateCounts:
            self.inputStateCounts.export(outfile, level, namespace_, name_='inputStateCounts')
        if self.clipCounts:
            self.clipCounts.export(outfile, level, namespace_, name_='clipCounts')
        if self.powerCounts:
            self.powerCounts.export(outfile, level, namespace_, name_='powerCounts')
        if self.rfiCounts:
            self.rfiCounts.export(outfile, level, namespace_, name_='rfiCounts')
        if self.outputStateCounts:
            self.outputStateCounts.export(outfile, level, namespace_, name_='outputStateCounts')
    def hasContent_(self):
        if (
            self.inputStateCounts is not None or
            self.clipCounts is not None or
            self.powerCounts is not None or
            self.rfiCounts is not None or
            self.outputStateCounts is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stbDataProducts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inputStateCounts is not None:
            showIndent(outfile, level)
            outfile.write('inputStateCounts=model_.inputStateCounts(\n')
            self.inputStateCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.clipCounts is not None:
            showIndent(outfile, level)
            outfile.write('clipCounts=model_.clipCounts(\n')
            self.clipCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.powerCounts is not None:
            showIndent(outfile, level)
            outfile.write('powerCounts=model_.powerCounts(\n')
            self.powerCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rfiCounts is not None:
            showIndent(outfile, level)
            outfile.write('rfiCounts=model_.rfiCounts(\n')
            self.rfiCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.outputStateCounts is not None:
            showIndent(outfile, level)
            outfile.write('outputStateCounts=model_.outputStateCounts(\n')
            self.outputStateCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inputStateCounts':
            obj_ = inputStateCounts.factory()
            obj_.build(child_)
            self.set_inputStateCounts(obj_)
        elif nodeName_ == 'clipCounts':
            obj_ = clipCounts.factory()
            obj_.build(child_)
            self.set_clipCounts(obj_)
        elif nodeName_ == 'powerCounts':
            obj_ = powerCounts.factory()
            obj_.build(child_)
            self.set_powerCounts(obj_)
        elif nodeName_ == 'rfiCounts':
            obj_ = rfiCounts.factory()
            obj_.build(child_)
            self.set_rfiCounts(obj_)
        elif nodeName_ == 'outputStateCounts':
            obj_ = outputStateCounts.factory()
            obj_.build(child_)
            self.set_outputStateCounts(obj_)
# end class stbDataProducts


class monitorData(GeneratedsSuper):
    """Station Board monitor data."""
    subclass = None
    superclass = None
    def __init__(self, tickIntervalCounts=None, errorCounts=None, crcTable=None):
        self.tickIntervalCounts = tickIntervalCounts
        self.errorCounts = errorCounts
        self.crcTable = crcTable
    def factory(*args_, **kwargs_):
        if monitorData.subclass:
            return monitorData.subclass(*args_, **kwargs_)
        else:
            return monitorData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tickIntervalCounts(self): return self.tickIntervalCounts
    def set_tickIntervalCounts(self, tickIntervalCounts): self.tickIntervalCounts = tickIntervalCounts
    def get_errorCounts(self): return self.errorCounts
    def set_errorCounts(self, errorCounts): self.errorCounts = errorCounts
    def get_crcTable(self): return self.crcTable
    def set_crcTable(self, crcTable): self.crcTable = crcTable
    def export(self, outfile, level, namespace_='widar:', name_='monitorData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='monitorData'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='monitorData', fromsubclass_=False):
        if self.tickIntervalCounts:
            self.tickIntervalCounts.export(outfile, level, namespace_, name_='tickIntervalCounts')
        if self.errorCounts:
            self.errorCounts.export(outfile, level, namespace_, name_='errorCounts')
        if self.crcTable:
            self.crcTable.export(outfile, level, namespace_, name_='crcTable')
    def hasContent_(self):
        if (
            self.tickIntervalCounts is not None or
            self.errorCounts is not None or
            self.crcTable is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='monitorData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tickIntervalCounts is not None:
            showIndent(outfile, level)
            outfile.write('tickIntervalCounts=model_.tickIntervalCounts(\n')
            self.tickIntervalCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errorCounts is not None:
            showIndent(outfile, level)
            outfile.write('errorCounts=model_.errorCounts(\n')
            self.errorCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.crcTable is not None:
            showIndent(outfile, level)
            outfile.write('crcTable=model_.crcTable(\n')
            self.crcTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tickIntervalCounts':
            obj_ = tickIntervalCounts.factory()
            obj_.build(child_)
            self.set_tickIntervalCounts(obj_)
        elif nodeName_ == 'errorCounts':
            obj_ = errorCounts.factory()
            obj_.build(child_)
            self.set_errorCounts(obj_)
        elif nodeName_ == 'crcTable':
            obj_ = crcTable.factory()
            obj_.build(child_)
            self.set_crcTable(obj_)
# end class monitorData


class host(GeneratedsSuper):
    """Set of parameters that unequely define a WIDAR host computer. This
    element may be used in logs/Alarms and other messages, where it
    may be used to identify the machine where log or report was
    originated."""
    subclass = None
    superclass = None
    def __init__(self, instance=None, type_=None, destIP4address=None):
        self.instance = _cast(None, instance)
        self.type_ = _cast(None, type_)
        self.destIP4address = _cast(None, destIP4address)
        pass
    def factory(*args_, **kwargs_):
        if host.subclass:
            return host.subclass(*args_, **kwargs_)
        else:
            return host(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_destIP4address(self): return self.destIP4address
    def set_destIP4address(self, destIP4address): self.destIP4address = destIP4address
    def export(self, outfile, level, namespace_='widar:', name_='host', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='host')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='host'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            outfile.write(' destIP4address=%s' % (quote_attrib(self.destIP4address), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='host', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='host'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            showIndent(outfile, level)
            outfile.write('destIP4address = %s,\n' % (self.destIP4address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('destIP4address', node)
        if value is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            self.destIP4address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class host


class wbcPolProduct(GeneratedsSuper):
    """Wideband Correlator Product. Specifies the product ID and input data
    streams that should be correlated. Baseband IDs are used to
    identify data streams to be correlated."""
    subclass = None
    superclass = None
    def __init__(self, laggedBBID=None, spectChannels=None, ppid=None, integFactor=1, promptBBID=None):
        self.laggedBBID = _cast(None, laggedBBID)
        self.spectChannels = _cast(None, spectChannels)
        self.ppid = _cast(None, ppid)
        self.integFactor = _cast(int, integFactor)
        self.promptBBID = _cast(None, promptBBID)
        pass
    def factory(*args_, **kwargs_):
        if wbcPolProduct.subclass:
            return wbcPolProduct.subclass(*args_, **kwargs_)
        else:
            return wbcPolProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_laggedBBID(self): return self.laggedBBID
    def set_laggedBBID(self, laggedBBID): self.laggedBBID = laggedBBID
    def get_spectChannels(self): return self.spectChannels
    def set_spectChannels(self, spectChannels): self.spectChannels = spectChannels
    def get_ppid(self): return self.ppid
    def set_ppid(self, ppid): self.ppid = ppid
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_promptBBID(self): return self.promptBBID
    def set_promptBBID(self, promptBBID): self.promptBBID = promptBBID
    def export(self, outfile, level, namespace_='widar:', name_='wbcPolProduct', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wbcPolProduct')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wbcPolProduct'):
        if self.laggedBBID is not None and 'laggedBBID' not in already_processed:
            already_processed.append('laggedBBID')
            outfile.write(' laggedBBID=%s' % (quote_attrib(self.laggedBBID), ))
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            outfile.write(' spectChannels=%s' % (quote_attrib(self.spectChannels), ))
        if self.ppid is not None and 'ppid' not in already_processed:
            already_processed.append('ppid')
            outfile.write(' ppid=%s' % (quote_attrib(self.ppid), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor="%s"' % self.gds_format_integer(self.integFactor, input_name='integFactor'))
        if self.promptBBID is not None and 'promptBBID' not in already_processed:
            already_processed.append('promptBBID')
            outfile.write(' promptBBID=%s' % (quote_attrib(self.promptBBID), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wbcPolProduct', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wbcPolProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laggedBBID is not None and 'laggedBBID' not in already_processed:
            already_processed.append('laggedBBID')
            showIndent(outfile, level)
            outfile.write('laggedBBID = %s,\n' % (self.laggedBBID,))
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            showIndent(outfile, level)
            outfile.write('spectChannels = %s,\n' % (self.spectChannels,))
        if self.ppid is not None and 'ppid' not in already_processed:
            already_processed.append('ppid')
            showIndent(outfile, level)
            outfile.write('ppid = %s,\n' % (self.ppid,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %d,\n' % (self.integFactor,))
        if self.promptBBID is not None and 'promptBBID' not in already_processed:
            already_processed.append('promptBBID')
            showIndent(outfile, level)
            outfile.write('promptBBID = %s,\n' % (self.promptBBID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laggedBBID', node)
        if value is not None and 'laggedBBID' not in already_processed:
            already_processed.append('laggedBBID')
            self.laggedBBID = value
        value = find_attr_value_('spectChannels', node)
        if value is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            self.spectChannels = value
        value = find_attr_value_('ppid', node)
        if value is not None and 'ppid' not in already_processed:
            already_processed.append('ppid')
            self.ppid = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            try:
                self.integFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('promptBBID', node)
        if value is not None and 'promptBBID' not in already_processed:
            already_processed.append('promptBBID')
            self.promptBBID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wbcPolProduct


class radarMode(GeneratedsSuper):
    """Raw data saving, also known as, radar mode. Narrow band output of a
    single filter per Station Board Data Path (i.e. per filter bank)
    can be saved in the memory and sent to the specified location.
    Number of bits to be saved is equal to the number of bits in the
    filter output, with exception of 7-bit output which is saved as
    8 bits of data. Duration can be specified in the number of 10
    millisecond interrupts. Duration=0 means perform data saving
    until "off" command is received or until the configuration is
    overwritten by another configuration."""
    subclass = None
    superclass = None
    def __init__(self, status=None, duration=0, destination=None):
        self.status = _cast(None, status)
        self.duration = _cast(int, duration)
        self.destination = _cast(None, destination)
        pass
    def factory(*args_, **kwargs_):
        if radarMode.subclass:
            return radarMode.subclass(*args_, **kwargs_)
        else:
            return radarMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def export(self, outfile, level, namespace_='widar:', name_='radarMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='radarMode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='radarMode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration="%s"' % self.gds_format_integer(self.duration, input_name='duration'))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='radarMode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='radarMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = %d,\n' % (self.duration,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            try:
                self.duration = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class radarMode


class cmMonitorControl(GeneratedsSuper):
    """Global parameters of VCI Configuration Mapper."""
    subclass = None
    superclass = None
    def __init__(self, vciSchemaValidation=None, sendConfigToCRM=None, sendConfigToBLBs=None, sendConfigToCBE=None, sendConfigToXBBs=None, query=None, flushCmibQueues=None, sendConfigToSTBs=None, queryCfgStatus=None, cfgQueue=None, actQueue=None, ctrlQueue=None, cmLogging=None, vciReporting=None, cmAlerts=None, cmDeleteSubarray=None):
        self.vciSchemaValidation = _cast(None, vciSchemaValidation)
        self.sendConfigToCRM = _cast(None, sendConfigToCRM)
        self.sendConfigToBLBs = _cast(None, sendConfigToBLBs)
        self.sendConfigToCBE = _cast(None, sendConfigToCBE)
        self.sendConfigToXBBs = _cast(None, sendConfigToXBBs)
        self.query = _cast(None, query)
        self.flushCmibQueues = _cast(None, flushCmibQueues)
        self.sendConfigToSTBs = _cast(None, sendConfigToSTBs)
        self.queryCfgStatus = queryCfgStatus
        self.cfgQueue = cfgQueue
        self.actQueue = actQueue
        self.ctrlQueue = ctrlQueue
        self.cmLogging = cmLogging
        self.vciReporting = vciReporting
        self.cmAlerts = cmAlerts
        self.cmDeleteSubarray = cmDeleteSubarray
    def factory(*args_, **kwargs_):
        if cmMonitorControl.subclass:
            return cmMonitorControl.subclass(*args_, **kwargs_)
        else:
            return cmMonitorControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryCfgStatus(self): return self.queryCfgStatus
    def set_queryCfgStatus(self, queryCfgStatus): self.queryCfgStatus = queryCfgStatus
    def get_cfgQueue(self): return self.cfgQueue
    def set_cfgQueue(self, cfgQueue): self.cfgQueue = cfgQueue
    def get_actQueue(self): return self.actQueue
    def set_actQueue(self, actQueue): self.actQueue = actQueue
    def get_ctrlQueue(self): return self.ctrlQueue
    def set_ctrlQueue(self, ctrlQueue): self.ctrlQueue = ctrlQueue
    def get_cmLogging(self): return self.cmLogging
    def set_cmLogging(self, cmLogging): self.cmLogging = cmLogging
    def get_vciReporting(self): return self.vciReporting
    def set_vciReporting(self, vciReporting): self.vciReporting = vciReporting
    def get_cmAlerts(self): return self.cmAlerts
    def set_cmAlerts(self, cmAlerts): self.cmAlerts = cmAlerts
    def get_cmDeleteSubarray(self): return self.cmDeleteSubarray
    def set_cmDeleteSubarray(self, cmDeleteSubarray): self.cmDeleteSubarray = cmDeleteSubarray
    def get_vciSchemaValidation(self): return self.vciSchemaValidation
    def set_vciSchemaValidation(self, vciSchemaValidation): self.vciSchemaValidation = vciSchemaValidation
    def get_sendConfigToCRM(self): return self.sendConfigToCRM
    def set_sendConfigToCRM(self, sendConfigToCRM): self.sendConfigToCRM = sendConfigToCRM
    def get_sendConfigToBLBs(self): return self.sendConfigToBLBs
    def set_sendConfigToBLBs(self, sendConfigToBLBs): self.sendConfigToBLBs = sendConfigToBLBs
    def get_sendConfigToCBE(self): return self.sendConfigToCBE
    def set_sendConfigToCBE(self, sendConfigToCBE): self.sendConfigToCBE = sendConfigToCBE
    def get_sendConfigToXBBs(self): return self.sendConfigToXBBs
    def set_sendConfigToXBBs(self, sendConfigToXBBs): self.sendConfigToXBBs = sendConfigToXBBs
    def get_query(self): return self.query
    def set_query(self, query): self.query = query
    def get_flushCmibQueues(self): return self.flushCmibQueues
    def set_flushCmibQueues(self, flushCmibQueues): self.flushCmibQueues = flushCmibQueues
    def get_sendConfigToSTBs(self): return self.sendConfigToSTBs
    def set_sendConfigToSTBs(self, sendConfigToSTBs): self.sendConfigToSTBs = sendConfigToSTBs
    def export(self, outfile, level, namespace_='widar:', name_='cmMonitorControl', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmMonitorControl')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmMonitorControl'):
        if self.vciSchemaValidation is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            outfile.write(' vciSchemaValidation=%s' % (quote_attrib(self.vciSchemaValidation), ))
        if self.sendConfigToCRM is not None and 'sendConfigToCRM' not in already_processed:
            already_processed.append('sendConfigToCRM')
            outfile.write(' sendConfigToCRM=%s' % (quote_attrib(self.sendConfigToCRM), ))
        if self.sendConfigToBLBs is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            outfile.write(' sendConfigToBLBs=%s' % (quote_attrib(self.sendConfigToBLBs), ))
        if self.sendConfigToCBE is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            outfile.write(' sendConfigToCBE=%s' % (quote_attrib(self.sendConfigToCBE), ))
        if self.sendConfigToXBBs is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            outfile.write(' sendConfigToXBBs=%s' % (quote_attrib(self.sendConfigToXBBs), ))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            outfile.write(' query=%s' % (quote_attrib(self.query), ))
        if self.flushCmibQueues is not None and 'flushCmibQueues' not in already_processed:
            already_processed.append('flushCmibQueues')
            outfile.write(' flushCmibQueues=%s' % (quote_attrib(self.flushCmibQueues), ))
        if self.sendConfigToSTBs is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            outfile.write(' sendConfigToSTBs=%s' % (quote_attrib(self.sendConfigToSTBs), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmMonitorControl', fromsubclass_=False):
        if self.queryCfgStatus:
            self.queryCfgStatus.export(outfile, level, namespace_, name_='queryCfgStatus')
        if self.cfgQueue:
            self.cfgQueue.export(outfile, level, namespace_, name_='cfgQueue')
        if self.actQueue:
            self.actQueue.export(outfile, level, namespace_, name_='actQueue')
        if self.ctrlQueue:
            self.ctrlQueue.export(outfile, level, namespace_, name_='ctrlQueue')
        if self.cmLogging:
            self.cmLogging.export(outfile, level, namespace_, name_='cmLogging')
        if self.vciReporting:
            self.vciReporting.export(outfile, level, namespace_, name_='vciReporting')
        if self.cmAlerts:
            self.cmAlerts.export(outfile, level, namespace_, name_='cmAlerts')
        if self.cmDeleteSubarray:
            self.cmDeleteSubarray.export(outfile, level, namespace_, name_='cmDeleteSubarray')
    def hasContent_(self):
        if (
            self.queryCfgStatus is not None or
            self.cfgQueue is not None or
            self.actQueue is not None or
            self.ctrlQueue is not None or
            self.cmLogging is not None or
            self.vciReporting is not None or
            self.cmAlerts is not None or
            self.cmDeleteSubarray is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmMonitorControl'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vciSchemaValidation is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            showIndent(outfile, level)
            outfile.write('vciSchemaValidation = %s,\n' % (self.vciSchemaValidation,))
        if self.sendConfigToCRM is not None and 'sendConfigToCRM' not in already_processed:
            already_processed.append('sendConfigToCRM')
            showIndent(outfile, level)
            outfile.write('sendConfigToCRM = %s,\n' % (self.sendConfigToCRM,))
        if self.sendConfigToBLBs is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToBLBs = %s,\n' % (self.sendConfigToBLBs,))
        if self.sendConfigToCBE is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            showIndent(outfile, level)
            outfile.write('sendConfigToCBE = %s,\n' % (self.sendConfigToCBE,))
        if self.sendConfigToXBBs is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToXBBs = %s,\n' % (self.sendConfigToXBBs,))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            showIndent(outfile, level)
            outfile.write('query = %s,\n' % (self.query,))
        if self.flushCmibQueues is not None and 'flushCmibQueues' not in already_processed:
            already_processed.append('flushCmibQueues')
            showIndent(outfile, level)
            outfile.write('flushCmibQueues = %s,\n' % (self.flushCmibQueues,))
        if self.sendConfigToSTBs is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToSTBs = %s,\n' % (self.sendConfigToSTBs,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.queryCfgStatus is not None:
            showIndent(outfile, level)
            outfile.write('queryCfgStatus=model_.queryCfgStatus(\n')
            self.queryCfgStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cfgQueue is not None:
            showIndent(outfile, level)
            outfile.write('cfgQueue=model_.cfgQueue(\n')
            self.cfgQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.actQueue is not None:
            showIndent(outfile, level)
            outfile.write('actQueue=model_.actQueue(\n')
            self.actQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ctrlQueue is not None:
            showIndent(outfile, level)
            outfile.write('ctrlQueue=model_.ctrlQueue(\n')
            self.ctrlQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmLogging is not None:
            showIndent(outfile, level)
            outfile.write('cmLogging=model_.cmLogging(\n')
            self.cmLogging.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vciReporting is not None:
            showIndent(outfile, level)
            outfile.write('vciReporting=model_.vciReporting(\n')
            self.vciReporting.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmAlerts is not None:
            showIndent(outfile, level)
            outfile.write('cmAlerts=model_.cmAlerts(\n')
            self.cmAlerts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmDeleteSubarray is not None:
            showIndent(outfile, level)
            outfile.write('cmDeleteSubarray=model_.cmDeleteSubarray(\n')
            self.cmDeleteSubarray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vciSchemaValidation', node)
        if value is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            self.vciSchemaValidation = value
        value = find_attr_value_('sendConfigToCRM', node)
        if value is not None and 'sendConfigToCRM' not in already_processed:
            already_processed.append('sendConfigToCRM')
            self.sendConfigToCRM = value
        value = find_attr_value_('sendConfigToBLBs', node)
        if value is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            self.sendConfigToBLBs = value
        value = find_attr_value_('sendConfigToCBE', node)
        if value is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            self.sendConfigToCBE = value
        value = find_attr_value_('sendConfigToXBBs', node)
        if value is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            self.sendConfigToXBBs = value
        value = find_attr_value_('query', node)
        if value is not None and 'query' not in already_processed:
            already_processed.append('query')
            self.query = value
        value = find_attr_value_('flushCmibQueues', node)
        if value is not None and 'flushCmibQueues' not in already_processed:
            already_processed.append('flushCmibQueues')
            self.flushCmibQueues = value
        value = find_attr_value_('sendConfigToSTBs', node)
        if value is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            self.sendConfigToSTBs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'queryCfgStatus':
            obj_ = queryCfgStatus.factory()
            obj_.build(child_)
            self.set_queryCfgStatus(obj_)
        elif nodeName_ == 'cfgQueue':
            obj_ = cfgQueue.factory()
            obj_.build(child_)
            self.set_cfgQueue(obj_)
        elif nodeName_ == 'actQueue':
            obj_ = actQueue.factory()
            obj_.build(child_)
            self.set_actQueue(obj_)
        elif nodeName_ == 'ctrlQueue':
            obj_ = ctrlQueue.factory()
            obj_.build(child_)
            self.set_ctrlQueue(obj_)
        elif nodeName_ == 'cmLogging':
            obj_ = cmLogging.factory()
            obj_.build(child_)
            self.set_cmLogging(obj_)
        elif nodeName_ == 'vciReporting':
            obj_ = vciReporting.factory()
            obj_.build(child_)
            self.set_vciReporting(obj_)
        elif nodeName_ == 'cmAlerts':
            obj_ = cmAlerts.factory()
            obj_.build(child_)
            self.set_cmAlerts(obj_)
        elif nodeName_ == 'cmDeleteSubarray':
            obj_ = cmDeleteSubarray.factory()
            obj_.build(child_)
            self.set_cmDeleteSubarray(obj_)
# end class cmMonitorControl


class vciReporting(GeneratedsSuper):
    """Specify destination address and port for VCI Responses/Reports.
    Enable/disable transmission of VCI Responses/Reports."""
    subclass = None
    superclass = None
    def __init__(self, transmit=None, destIpAddress=None, destPort=None):
        self.transmit = _cast(None, transmit)
        self.destIpAddress = _cast(None, destIpAddress)
        self.destPort = _cast(int, destPort)
        pass
    def factory(*args_, **kwargs_):
        if vciReporting.subclass:
            return vciReporting.subclass(*args_, **kwargs_)
        else:
            return vciReporting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transmit(self): return self.transmit
    def set_transmit(self, transmit): self.transmit = transmit
    def get_destIpAddress(self): return self.destIpAddress
    def set_destIpAddress(self, destIpAddress): self.destIpAddress = destIpAddress
    def get_destPort(self): return self.destPort
    def set_destPort(self, destPort): self.destPort = destPort
    def export(self, outfile, level, namespace_='widar:', name_='vciReporting', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vciReporting')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vciReporting'):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            outfile.write(' transmit=%s' % (quote_attrib(self.transmit), ))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            outfile.write(' destIpAddress=%s' % (self.gds_format_string(quote_attrib(self.destIpAddress).encode(ExternalEncoding), input_name='destIpAddress'), ))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            outfile.write(' destPort="%s"' % self.gds_format_integer(self.destPort, input_name='destPort'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vciReporting', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vciReporting'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            showIndent(outfile, level)
            outfile.write('transmit = %s,\n' % (self.transmit,))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            showIndent(outfile, level)
            outfile.write('destIpAddress = "%s",\n' % (self.destIpAddress,))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            showIndent(outfile, level)
            outfile.write('destPort = %d,\n' % (self.destPort,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transmit', node)
        if value is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            self.transmit = value
        value = find_attr_value_('destIpAddress', node)
        if value is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            self.destIpAddress = value
        value = find_attr_value_('destPort', node)
        if value is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            try:
                self.destPort = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vciReporting


class cmAlerts(GeneratedsSuper):
    """Specify destination address and port for xAlerts. Enable/disable
    transmission of xAlerts."""
    subclass = None
    superclass = None
    def __init__(self, transmit=None, destIpAddress=None, destPort=None):
        self.transmit = _cast(None, transmit)
        self.destIpAddress = _cast(None, destIpAddress)
        self.destPort = _cast(int, destPort)
        pass
    def factory(*args_, **kwargs_):
        if cmAlerts.subclass:
            return cmAlerts.subclass(*args_, **kwargs_)
        else:
            return cmAlerts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transmit(self): return self.transmit
    def set_transmit(self, transmit): self.transmit = transmit
    def get_destIpAddress(self): return self.destIpAddress
    def set_destIpAddress(self, destIpAddress): self.destIpAddress = destIpAddress
    def get_destPort(self): return self.destPort
    def set_destPort(self, destPort): self.destPort = destPort
    def export(self, outfile, level, namespace_='widar:', name_='cmAlerts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmAlerts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmAlerts'):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            outfile.write(' transmit=%s' % (quote_attrib(self.transmit), ))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            outfile.write(' destIpAddress=%s' % (self.gds_format_string(quote_attrib(self.destIpAddress).encode(ExternalEncoding), input_name='destIpAddress'), ))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            outfile.write(' destPort="%s"' % self.gds_format_integer(self.destPort, input_name='destPort'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmAlerts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmAlerts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            showIndent(outfile, level)
            outfile.write('transmit = %s,\n' % (self.transmit,))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            showIndent(outfile, level)
            outfile.write('destIpAddress = "%s",\n' % (self.destIpAddress,))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            showIndent(outfile, level)
            outfile.write('destPort = %d,\n' % (self.destPort,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transmit', node)
        if value is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            self.transmit = value
        value = find_attr_value_('destIpAddress', node)
        if value is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            self.destIpAddress = value
        value = find_attr_value_('destPort', node)
        if value is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            try:
                self.destPort = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmAlerts


class queryCfgStatus(GeneratedsSuper):
    """Request for configuration status report. One can specify: cfg=active
    or cfg=next or activation time or CorrModel ID. If more than one
    identification is specified, CM uses the first valid identifier,
    in following order: 1. cfg 2. actTime 3. CorrModel ID"""
    subclass = None
    superclass = None
    def __init__(self, actTime=None, cfg=None, corrModelId=None):
        self.actTime = _cast(None, actTime)
        self.cfg = _cast(None, cfg)
        self.corrModelId = _cast(float, corrModelId)
        pass
    def factory(*args_, **kwargs_):
        if queryCfgStatus.subclass:
            return queryCfgStatus.subclass(*args_, **kwargs_)
        else:
            return queryCfgStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actTime(self): return self.actTime
    def set_actTime(self, actTime): self.actTime = actTime
    def get_cfg(self): return self.cfg
    def set_cfg(self, cfg): self.cfg = cfg
    def get_corrModelId(self): return self.corrModelId
    def set_corrModelId(self, corrModelId): self.corrModelId = corrModelId
    def export(self, outfile, level, namespace_='widar:', name_='queryCfgStatus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='queryCfgStatus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='queryCfgStatus'):
        if self.actTime is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            outfile.write(' actTime=%s' % (self.gds_format_string(quote_attrib(self.actTime).encode(ExternalEncoding), input_name='actTime'), ))
        if self.cfg is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            outfile.write(' cfg=%s' % (quote_attrib(self.cfg), ))
        if self.corrModelId is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            outfile.write(' corrModelId="%s"' % self.gds_format_double(self.corrModelId, input_name='corrModelId'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='queryCfgStatus', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='queryCfgStatus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.actTime is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            showIndent(outfile, level)
            outfile.write('actTime = "%s",\n' % (self.actTime,))
        if self.cfg is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            showIndent(outfile, level)
            outfile.write('cfg = %s,\n' % (self.cfg,))
        if self.corrModelId is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            showIndent(outfile, level)
            outfile.write('corrModelId = %e,\n' % (self.corrModelId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actTime', node)
        if value is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            self.actTime = value
        value = find_attr_value_('cfg', node)
        if value is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            self.cfg = value
        value = find_attr_value_('corrModelId', node)
        if value is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            try:
                self.corrModelId = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (corrModelId): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class queryCfgStatus


class cfgQueue(GeneratedsSuper):
    """Monitor and control for the configuration queue."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cfgQueue.subclass:
            return cfgQueue.subclass(*args_, **kwargs_)
        else:
            return cfgQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cfgQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cfgQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cfgQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cfgQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cfgQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cfgQueue


class actQueue(GeneratedsSuper):
    """Monitor and control for the activation queue."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if actQueue.subclass:
            return actQueue.subclass(*args_, **kwargs_)
        else:
            return actQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='actQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='actQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='actQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='actQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class actQueue


class ctrlQueue(GeneratedsSuper):
    """Monitor and control for the queue that contains Control messages."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ctrlQueue.subclass:
            return ctrlQueue.subclass(*args_, **kwargs_)
        else:
            return ctrlQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='ctrlQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ctrlQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='ctrlQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='ctrlQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ctrlQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ctrlQueue


class cmDeleteSubarray(GeneratedsSuper):
    """Delete subarray with the specified Config ID. If configId==all
    delete all subarrays. This command is used when usr does not
    want to (or cannot) specify activation time. When this command
    is received, CM searches both the active configuration and all
    the scheduled configurations (in the Activation Queue) and
    deletes all the instances of a subarray with the specified
    Config ID."""
    subclass = None
    superclass = None
    def __init__(self, configId=None, valueOf_=None):
        self.configId = _cast(None, configId)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cmDeleteSubarray.subclass:
            return cmDeleteSubarray.subclass(*args_, **kwargs_)
        else:
            return cmDeleteSubarray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configId(self): return self.configId
    def set_configId(self, configId): self.configId = configId
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cmDeleteSubarray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmDeleteSubarray')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmDeleteSubarray'):
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            outfile.write(' configId=%s' % (self.gds_format_string(quote_attrib(self.configId).encode(ExternalEncoding), input_name='configId'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmDeleteSubarray', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmDeleteSubarray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            showIndent(outfile, level)
            outfile.write('configId = "%s",\n' % (self.configId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('configId', node)
        if value is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            self.configId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmDeleteSubarray


class cmLogging(GeneratedsSuper):
    """"""
    subclass = None
    superclass = None
    def __init__(self, level=None, logCrmMessages=None, logToFile=None, logCbeMessages=None, logBlbMessages=None, logXAlerts=None, logVciMessages=None, logStbMessages=None, logXbbMessages=None):
        self.level = _cast(None, level)
        self.logCrmMessages = _cast(None, logCrmMessages)
        self.logToFile = _cast(None, logToFile)
        self.logCbeMessages = _cast(None, logCbeMessages)
        self.logBlbMessages = _cast(None, logBlbMessages)
        self.logXAlerts = _cast(None, logXAlerts)
        self.logVciMessages = _cast(None, logVciMessages)
        self.logStbMessages = _cast(None, logStbMessages)
        self.logXbbMessages = _cast(None, logXbbMessages)
        pass
    def factory(*args_, **kwargs_):
        if cmLogging.subclass:
            return cmLogging.subclass(*args_, **kwargs_)
        else:
            return cmLogging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_logCrmMessages(self): return self.logCrmMessages
    def set_logCrmMessages(self, logCrmMessages): self.logCrmMessages = logCrmMessages
    def get_logToFile(self): return self.logToFile
    def set_logToFile(self, logToFile): self.logToFile = logToFile
    def get_logCbeMessages(self): return self.logCbeMessages
    def set_logCbeMessages(self, logCbeMessages): self.logCbeMessages = logCbeMessages
    def get_logBlbMessages(self): return self.logBlbMessages
    def set_logBlbMessages(self, logBlbMessages): self.logBlbMessages = logBlbMessages
    def get_logXAlerts(self): return self.logXAlerts
    def set_logXAlerts(self, logXAlerts): self.logXAlerts = logXAlerts
    def get_logVciMessages(self): return self.logVciMessages
    def set_logVciMessages(self, logVciMessages): self.logVciMessages = logVciMessages
    def get_logStbMessages(self): return self.logStbMessages
    def set_logStbMessages(self, logStbMessages): self.logStbMessages = logStbMessages
    def get_logXbbMessages(self): return self.logXbbMessages
    def set_logXbbMessages(self, logXbbMessages): self.logXbbMessages = logXbbMessages
    def export(self, outfile, level, namespace_='widar:', name_='cmLogging', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmLogging')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmLogging'):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.logCrmMessages is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            outfile.write(' logCrmMessages=%s' % (quote_attrib(self.logCrmMessages), ))
        if self.logToFile is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            outfile.write(' logToFile=%s' % (quote_attrib(self.logToFile), ))
        if self.logCbeMessages is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            outfile.write(' logCbeMessages=%s' % (quote_attrib(self.logCbeMessages), ))
        if self.logBlbMessages is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            outfile.write(' logBlbMessages=%s' % (quote_attrib(self.logBlbMessages), ))
        if self.logXAlerts is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            outfile.write(' logXAlerts=%s' % (quote_attrib(self.logXAlerts), ))
        if self.logVciMessages is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            outfile.write(' logVciMessages=%s' % (quote_attrib(self.logVciMessages), ))
        if self.logStbMessages is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            outfile.write(' logStbMessages=%s' % (quote_attrib(self.logStbMessages), ))
        if self.logXbbMessages is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            outfile.write(' logXbbMessages=%s' % (quote_attrib(self.logXbbMessages), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmLogging', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmLogging'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
        if self.logCrmMessages is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            showIndent(outfile, level)
            outfile.write('logCrmMessages = %s,\n' % (self.logCrmMessages,))
        if self.logToFile is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            showIndent(outfile, level)
            outfile.write('logToFile = %s,\n' % (self.logToFile,))
        if self.logCbeMessages is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            showIndent(outfile, level)
            outfile.write('logCbeMessages = %s,\n' % (self.logCbeMessages,))
        if self.logBlbMessages is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            showIndent(outfile, level)
            outfile.write('logBlbMessages = %s,\n' % (self.logBlbMessages,))
        if self.logXAlerts is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            showIndent(outfile, level)
            outfile.write('logXAlerts = %s,\n' % (self.logXAlerts,))
        if self.logVciMessages is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            showIndent(outfile, level)
            outfile.write('logVciMessages = %s,\n' % (self.logVciMessages,))
        if self.logStbMessages is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            showIndent(outfile, level)
            outfile.write('logStbMessages = %s,\n' % (self.logStbMessages,))
        if self.logXbbMessages is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            showIndent(outfile, level)
            outfile.write('logXbbMessages = %s,\n' % (self.logXbbMessages,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
        value = find_attr_value_('logCrmMessages', node)
        if value is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            self.logCrmMessages = value
        value = find_attr_value_('logToFile', node)
        if value is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            self.logToFile = value
        value = find_attr_value_('logCbeMessages', node)
        if value is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            self.logCbeMessages = value
        value = find_attr_value_('logBlbMessages', node)
        if value is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            self.logBlbMessages = value
        value = find_attr_value_('logXAlerts', node)
        if value is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            self.logXAlerts = value
        value = find_attr_value_('logVciMessages', node)
        if value is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            self.logVciMessages = value
        value = find_attr_value_('logStbMessages', node)
        if value is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            self.logStbMessages = value
        value = find_attr_value_('logXbbMessages', node)
        if value is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            self.logXbbMessages = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmLogging


class component(GeneratedsSuper):
    """This is an attempt to define an XML element that could be used to
    query or report status of any h/w or s/w component. Element
    component can be generated both by the VCI client and by the
    correlator. ID and type are enough to unquely identify any WIDAR
    component. Optionally, a name can be assigned, but VCI clinet
    can not use the name to identify component. Attributes xmlTag
    and status are specified only by the correlator. If an XML
    element is specified for the component, the message generated by
    the correlator"""
    subclass = None
    superclass = None
    def __init__(self, status=None, xmlTag=None, type_=None, id=None, name=None):
        self.status = _cast(None, status)
        self.xmlTag = _cast(None, xmlTag)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if component.subclass:
            return component.subclass(*args_, **kwargs_)
        else:
            return component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_xmlTag(self): return self.xmlTag
    def set_xmlTag(self, xmlTag): self.xmlTag = xmlTag
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='component', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='component')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='component'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.xmlTag is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            outfile.write(' xmlTag=%s' % (self.gds_format_string(quote_attrib(self.xmlTag).encode(ExternalEncoding), input_name='xmlTag'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='component', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='component'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = "%s",\n' % (self.status,))
        if self.xmlTag is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            showIndent(outfile, level)
            outfile.write('xmlTag = "%s",\n' % (self.xmlTag,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('xmlTag', node)
        if value is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            self.xmlTag = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class component


class originator(GeneratedsSuper):
    """Originator of the vciLog. Depending on the type of event, name of
    the class, method and/or thread may be provided."""
    subclass = None
    superclass = None
    def __init__(self, thread=None, classxx=None, componentID=None, componentType=None, logger=None, method=None):
        self.thread = _cast(None, thread)
        self.classxx = _cast(None, classxx)
        self.componentID = _cast(None, componentID)
        self.componentType = _cast(None, componentType)
        self.logger = _cast(None, logger)
        self.method = _cast(None, method)
        pass
    def factory(*args_, **kwargs_):
        if originator.subclass:
            return originator.subclass(*args_, **kwargs_)
        else:
            return originator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thread(self): return self.thread
    def set_thread(self, thread): self.thread = thread
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def get_componentID(self): return self.componentID
    def set_componentID(self, componentID): self.componentID = componentID
    def get_componentType(self): return self.componentType
    def set_componentType(self, componentType): self.componentType = componentType
    def get_logger(self): return self.logger
    def set_logger(self, logger): self.logger = logger
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def export(self, outfile, level, namespace_='widar:', name_='originator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='originator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='originator'):
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            outfile.write(' thread=%s' % (self.gds_format_string(quote_attrib(self.thread).encode(ExternalEncoding), input_name='thread'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            outfile.write(' componentID=%s' % (self.gds_format_string(quote_attrib(self.componentID).encode(ExternalEncoding), input_name='componentID'), ))
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            outfile.write(' componentType=%s' % (self.gds_format_string(quote_attrib(self.componentType).encode(ExternalEncoding), input_name='componentType'), ))
        if self.logger is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            outfile.write(' logger=%s' % (self.gds_format_string(quote_attrib(self.logger).encode(ExternalEncoding), input_name='logger'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='originator', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='originator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            showIndent(outfile, level)
            outfile.write('thread = "%s",\n' % (self.thread,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            showIndent(outfile, level)
            outfile.write('componentID = "%s",\n' % (self.componentID,))
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            showIndent(outfile, level)
            outfile.write('componentType = "%s",\n' % (self.componentType,))
        if self.logger is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            showIndent(outfile, level)
            outfile.write('logger = "%s",\n' % (self.logger,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = "%s",\n' % (self.method,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            self.thread = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
        value = find_attr_value_('componentID', node)
        if value is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            self.componentID = value
        value = find_attr_value_('componentType', node)
        if value is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            self.componentType = value
        value = find_attr_value_('logger', node)
        if value is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            self.logger = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class originator


class affectedComponent(GeneratedsSuper):
    """The component which is the source of the event or which is affected
    by the event. For example, if a crash is being reported : the
    component that crashed."""
    subclass = None
    superclass = None
    def __init__(self, componentType=None, method=None, componentID=None, thread=None, classxx=None):
        self.componentType = _cast(None, componentType)
        self.method = _cast(None, method)
        self.componentID = _cast(None, componentID)
        self.thread = _cast(None, thread)
        self.classxx = _cast(None, classxx)
        pass
    def factory(*args_, **kwargs_):
        if affectedComponent.subclass:
            return affectedComponent.subclass(*args_, **kwargs_)
        else:
            return affectedComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentType(self): return self.componentType
    def set_componentType(self, componentType): self.componentType = componentType
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_componentID(self): return self.componentID
    def set_componentID(self, componentID): self.componentID = componentID
    def get_thread(self): return self.thread
    def set_thread(self, thread): self.thread = thread
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='widar:', name_='affectedComponent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='affectedComponent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='affectedComponent'):
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            outfile.write(' componentType=%s' % (self.gds_format_string(quote_attrib(self.componentType).encode(ExternalEncoding), input_name='componentType'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            outfile.write(' componentID=%s' % (self.gds_format_string(quote_attrib(self.componentID).encode(ExternalEncoding), input_name='componentID'), ))
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            outfile.write(' thread=%s' % (self.gds_format_string(quote_attrib(self.thread).encode(ExternalEncoding), input_name='thread'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='affectedComponent', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='affectedComponent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            showIndent(outfile, level)
            outfile.write('componentType = "%s",\n' % (self.componentType,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = "%s",\n' % (self.method,))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            showIndent(outfile, level)
            outfile.write('componentID = "%s",\n' % (self.componentID,))
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            showIndent(outfile, level)
            outfile.write('thread = "%s",\n' % (self.thread,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentType', node)
        if value is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            self.componentType = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
        value = find_attr_value_('componentID', node)
        if value is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            self.componentID = value
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            self.thread = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class affectedComponent


class trowable(GeneratedsSuper):
    """Used to log Java exceptions (object trowable)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, message=None, stackTrace=None, trowable=None):
        self.type_ = type_
        self.message = message
        if stackTrace is None:
            self.stackTrace = []
        else:
            self.stackTrace = stackTrace
        if trowable is None:
            self.trowable = []
        else:
            self.trowable = trowable
    def factory(*args_, **kwargs_):
        if trowable.subclass:
            return trowable.subclass(*args_, **kwargs_)
        else:
            return trowable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_stackTrace(self): return self.stackTrace
    def set_stackTrace(self, stackTrace): self.stackTrace = stackTrace
    def add_stackTrace(self, value): self.stackTrace.append(value)
    def insert_stackTrace(self, index, value): self.stackTrace[index] = value
    def get_trowable(self): return self.trowable
    def set_trowable(self, trowable): self.trowable = trowable
    def add_trowable(self, value): self.trowable.append(value)
    def insert_trowable(self, index, value): self.trowable[index] = value
    def export(self, outfile, level, namespace_='widar:', name_='trowable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trowable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='trowable'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='trowable', fromsubclass_=False):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        for stackTrace_ in self.stackTrace:
            showIndent(outfile, level)
            outfile.write('<%sstackTrace>%s</%sstackTrace>\n' % (namespace_, self.gds_format_string(quote_xml(stackTrace_).encode(ExternalEncoding), input_name='stackTrace'), namespace_))
        for trowable_ in self.trowable:
            trowable_.export(outfile, level, namespace_, name_='trowable')
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.message is not None or
            self.stackTrace or
            self.trowable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='trowable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('stackTrace=[\n')
        level += 1
        for stackTrace_ in self.stackTrace:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stackTrace_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('trowable=[\n')
        level += 1
        for trowable_ in self.trowable:
            showIndent(outfile, level)
            outfile.write('model_.trowable(\n')
            trowable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'stackTrace':
            stackTrace_ = child_.text
            stackTrace_ = self.gds_validate_string(stackTrace_, node, 'stackTrace')
            self.stackTrace.append(stackTrace_)
        elif nodeName_ == 'trowable':
            obj_ = trowable.factory()
            obj_.build(child_)
            self.trowable.append(obj_)
# end class trowable


class widarHost(GeneratedsSuper):
    """Set of parameters that unequely define a WIDAR host computer
    (physical device). Obviously, IP address can be used to uniqely
    define a computer system, while type and instance are more
    sutiable as information to be stored for future reference."""
    subclass = None
    superclass = None
    def __init__(self, instance=None, type_=None, destIP4address=None):
        self.instance = _cast(None, instance)
        self.type_ = _cast(None, type_)
        self.destIP4address = _cast(None, destIP4address)
        pass
    def factory(*args_, **kwargs_):
        if widarHost.subclass:
            return widarHost.subclass(*args_, **kwargs_)
        else:
            return widarHost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_destIP4address(self): return self.destIP4address
    def set_destIP4address(self, destIP4address): self.destIP4address = destIP4address
    def export(self, outfile, level, namespace_='widar:', name_='widarHost', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='widarHost')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='widarHost'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            outfile.write(' destIP4address=%s' % (quote_attrib(self.destIP4address), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='widarHost', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='widarHost'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            showIndent(outfile, level)
            outfile.write('destIP4address = %s,\n' % (self.destIP4address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('destIP4address', node)
        if value is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            self.destIP4address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class widarHost


class MsgCommentType(GeneratedsSuper):
    """Decription used in log / alarm messages."""
    subclass = None
    superclass = None
    def __init__(self, code=None, level=None, description=None, property=None):
        self.code = _cast(None, code)
        self.level = _cast(None, level)
        if description is None:
            self.description = []
        else:
            self.description = description
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if MsgCommentType.subclass:
            return MsgCommentType.subclass(*args_, **kwargs_)
        else:
            return MsgCommentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property(self, index, value): self.property[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def export(self, outfile, level, namespace_='widar:', name_='MsgCommentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MsgCommentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='MsgCommentType'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='MsgCommentType', fromsubclass_=False):
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(description_).encode(ExternalEncoding), input_name='description'), namespace_))
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.description or
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MsgCommentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            showIndent(outfile, level)
            outfile.write('code = "%s",\n' % (self.code,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.property(\n')
            property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.append('code')
            self.code = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'property':
            obj_ = property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class MsgCommentType


class property(GeneratedsSuper):
    """Used to report status of the parameters which are not defined in the
    WIDAR XML Schema."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if property.subclass:
            return property.subclass(*args_, **kwargs_)
        else:
            return property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='widar:', name_='property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='property'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='property', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class property


class moduleLocation(GeneratedsSuper):
    """Module Location Id as specified in the System Numbering Plan.
    Defines the physical location of the module."""
    subclass = None
    superclass = None
    def __init__(self, slot=None, crate=None, rack=None):
        self.slot = _cast(None, slot)
        self.crate = _cast(None, crate)
        self.rack = _cast(None, rack)
        pass
    def factory(*args_, **kwargs_):
        if moduleLocation.subclass:
            return moduleLocation.subclass(*args_, **kwargs_)
        else:
            return moduleLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_slot(self): return self.slot
    def set_slot(self, slot): self.slot = slot
    def get_crate(self): return self.crate
    def set_crate(self, crate): self.crate = crate
    def get_rack(self): return self.rack
    def set_rack(self, rack): self.rack = rack
    def export(self, outfile, level, namespace_='widar:', name_='moduleLocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moduleLocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='moduleLocation'):
        if self.slot is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            outfile.write(' slot=%s' % (quote_attrib(self.slot), ))
        if self.crate is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            outfile.write(' crate=%s' % (quote_attrib(self.crate), ))
        if self.rack is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            outfile.write(' rack=%s' % (quote_attrib(self.rack), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='moduleLocation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='moduleLocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.slot is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            showIndent(outfile, level)
            outfile.write('slot = %s,\n' % (self.slot,))
        if self.crate is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            showIndent(outfile, level)
            outfile.write('crate = %s,\n' % (self.crate,))
        if self.rack is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            showIndent(outfile, level)
            outfile.write('rack = %s,\n' % (self.rack,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('slot', node)
        if value is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            self.slot = value
        value = find_attr_value_('crate', node)
        if value is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            self.crate = value
        value = find_attr_value_('rack', node)
        if value is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            self.rack = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class moduleLocation


class inputStateCounts(GeneratedsSuper):
    """control input state count monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if inputStateCounts.subclass:
            return inputStateCounts.subclass(*args_, **kwargs_)
        else:
            return inputStateCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='inputStateCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='inputStateCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='inputStateCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='inputStateCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='inputStateCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class inputStateCounts


class tickIntervalCounts(GeneratedsSuper):
    """control tick interval monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if tickIntervalCounts.subclass:
            return tickIntervalCounts.subclass(*args_, **kwargs_)
        else:
            return tickIntervalCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='tickIntervalCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tickIntervalCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='tickIntervalCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='tickIntervalCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tickIntervalCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tickIntervalCounts


class clipCounts(GeneratedsSuper):
    """control sampler clip monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if clipCounts.subclass:
            return clipCounts.subclass(*args_, **kwargs_)
        else:
            return clipCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='clipCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clipCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='clipCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='clipCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='clipCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clipCounts


class powerCounts(GeneratedsSuper):
    """control power monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if powerCounts.subclass:
            return powerCounts.subclass(*args_, **kwargs_)
        else:
            return powerCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='powerCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='powerCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='powerCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='powerCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='powerCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class powerCounts


class errorCounts(GeneratedsSuper):
    """error counts"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if errorCounts.subclass:
            return errorCounts.subclass(*args_, **kwargs_)
        else:
            return errorCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='errorCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='errorCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='errorCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='errorCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='errorCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class errorCounts


class rfiCounts(GeneratedsSuper):
    """control radio frequency interference monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if rfiCounts.subclass:
            return rfiCounts.subclass(*args_, **kwargs_)
        else:
            return rfiCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='rfiCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rfiCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='rfiCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='rfiCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rfiCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rfiCounts


class outputStateCounts(GeneratedsSuper):
    """control output state count monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if outputStateCounts.subclass:
            return outputStateCounts.subclass(*args_, **kwargs_)
        else:
            return outputStateCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='outputStateCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='outputStateCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='outputStateCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='outputStateCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='outputStateCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class outputStateCounts


class crcTable(GeneratedsSuper):
    """control CRC status monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, resetAction=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.resetAction = _cast(None, resetAction)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if crcTable.subclass:
            return crcTable.subclass(*args_, **kwargs_)
        else:
            return crcTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_resetAction(self): return self.resetAction
    def set_resetAction(self, resetAction): self.resetAction = resetAction
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='crcTable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crcTable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='crcTable'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.resetAction is not None and 'resetAction' not in already_processed:
            already_processed.append('resetAction')
            outfile.write(' resetAction=%s' % (self.gds_format_string(quote_attrib(self.resetAction).encode(ExternalEncoding), input_name='resetAction'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='crcTable', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='crcTable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.resetAction is not None and 'resetAction' not in already_processed:
            already_processed.append('resetAction')
            showIndent(outfile, level)
            outfile.write('resetAction = "%s",\n' % (self.resetAction,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('resetAction', node)
        if value is not None and 'resetAction' not in already_processed:
            already_processed.append('resetAction')
            self.resetAction = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class crcTable


class toneExtraction(GeneratedsSuper):
    """control CRC status monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, numTones=None, integFactor='10', dwellTime=None):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.numTones = _cast(int, numTones)
        self.integFactor = _cast(None, integFactor)
        self.dwellTime = _cast(int, dwellTime)
        pass
    def factory(*args_, **kwargs_):
        if toneExtraction.subclass:
            return toneExtraction.subclass(*args_, **kwargs_)
        else:
            return toneExtraction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_numTones(self): return self.numTones
    def set_numTones(self, numTones): self.numTones = numTones
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_dwellTime(self): return self.dwellTime
    def set_dwellTime(self, dwellTime): self.dwellTime = dwellTime
    def export(self, outfile, level, namespace_='widar:', name_='toneExtraction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='toneExtraction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='toneExtraction'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.numTones is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            outfile.write(' numTones="%s"' % self.gds_format_integer(self.numTones, input_name='numTones'))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            outfile.write(' dwellTime="%s"' % self.gds_format_integer(self.dwellTime, input_name='dwellTime'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='toneExtraction', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='toneExtraction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.numTones is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            showIndent(outfile, level)
            outfile.write('numTones = %d,\n' % (self.numTones,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            showIndent(outfile, level)
            outfile.write('dwellTime = %d,\n' % (self.dwellTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('numTones', node)
        if value is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            try:
                self.numTones = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
        value = find_attr_value_('dwellTime', node)
        if value is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            try:
                self.dwellTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class toneExtraction


class noiseDiode(GeneratedsSuper):
    """Noise Diode configuration."""
    subclass = None
    superclass = None
    def __init__(self, status='enable', phase=0.0, dutyCycle='50.0', periodMilliSec='9.6'):
        self.status = _cast(None, status)
        self.phase = _cast(float, phase)
        self.dutyCycle = _cast(None, dutyCycle)
        self.periodMilliSec = _cast(None, periodMilliSec)
        pass
    def factory(*args_, **kwargs_):
        if noiseDiode.subclass:
            return noiseDiode.subclass(*args_, **kwargs_)
        else:
            return noiseDiode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_dutyCycle(self): return self.dutyCycle
    def set_dutyCycle(self, dutyCycle): self.dutyCycle = dutyCycle
    def get_periodMilliSec(self): return self.periodMilliSec
    def set_periodMilliSec(self, periodMilliSec): self.periodMilliSec = periodMilliSec
    def export(self, outfile, level, namespace_='widar:', name_='noiseDiode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noiseDiode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='noiseDiode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            outfile.write(' phase="%s"' % self.gds_format_double(self.phase, input_name='phase'))
        if self.dutyCycle is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            outfile.write(' dutyCycle=%s' % (quote_attrib(self.dutyCycle), ))
        if self.periodMilliSec is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            outfile.write(' periodMilliSec=%s' % (quote_attrib(self.periodMilliSec), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='noiseDiode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='noiseDiode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            showIndent(outfile, level)
            outfile.write('phase = %e,\n' % (self.phase,))
        if self.dutyCycle is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            showIndent(outfile, level)
            outfile.write('dutyCycle = %s,\n' % (self.dutyCycle,))
        if self.periodMilliSec is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            showIndent(outfile, level)
            outfile.write('periodMilliSec = %s,\n' % (self.periodMilliSec,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            try:
                self.phase = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (phase): %s' % exp)
        value = find_attr_value_('dutyCycle', node)
        if value is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            self.dutyCycle = value
        value = find_attr_value_('periodMilliSec', node)
        if value is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            self.periodMilliSec = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class noiseDiode


class pulsarGating(GeneratedsSuper):
    """Pulsar Gating. Period in milliseconds (or frequency in Hz). Gate
    width is specified as percent of the period (when the gate is
    on). Epoch is specified as UT (or should it be the same as
    activation time)."""
    subclass = None
    superclass = None
    def __init__(self, status='disable', period=None, firstDerivative=None, epoch=None, secondDerivative=None, gateWidth='0.5'):
        self.status = _cast(None, status)
        self.period = _cast(float, period)
        self.firstDerivative = _cast(int, firstDerivative)
        self.epoch = _cast(None, epoch)
        self.secondDerivative = _cast(int, secondDerivative)
        self.gateWidth = _cast(None, gateWidth)
        pass
    def factory(*args_, **kwargs_):
        if pulsarGating.subclass:
            return pulsarGating.subclass(*args_, **kwargs_)
        else:
            return pulsarGating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_firstDerivative(self): return self.firstDerivative
    def set_firstDerivative(self, firstDerivative): self.firstDerivative = firstDerivative
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_secondDerivative(self): return self.secondDerivative
    def set_secondDerivative(self, secondDerivative): self.secondDerivative = secondDerivative
    def get_gateWidth(self): return self.gateWidth
    def set_gateWidth(self, gateWidth): self.gateWidth = gateWidth
    def export(self, outfile, level, namespace_='widar:', name_='pulsarGating', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pulsarGating')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='pulsarGating'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_double(self.period, input_name='period'))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            outfile.write(' firstDerivative="%s"' % self.gds_format_integer(self.firstDerivative, input_name='firstDerivative'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            outfile.write(' secondDerivative="%s"' % self.gds_format_integer(self.secondDerivative, input_name='secondDerivative'))
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            outfile.write(' gateWidth=%s' % (quote_attrib(self.gateWidth), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='pulsarGating', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pulsarGating'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %e,\n' % (self.period,))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            showIndent(outfile, level)
            outfile.write('firstDerivative = %d,\n' % (self.firstDerivative,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            showIndent(outfile, level)
            outfile.write('secondDerivative = %d,\n' % (self.secondDerivative,))
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            showIndent(outfile, level)
            outfile.write('gateWidth = %s,\n' % (self.gateWidth,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (period): %s' % exp)
        value = find_attr_value_('firstDerivative', node)
        if value is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            try:
                self.firstDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('secondDerivative', node)
        if value is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            try:
                self.secondDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gateWidth', node)
        if value is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            self.gateWidth = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pulsarGating


class gateModel(GeneratedsSuper):
    """Model for pulsar gating. Period in milliseconds. Gate width is
    specified as percent of the period (when the gate is on). Epoch
    is specified as UT (or should it be the same as activation
    time)."""
    subclass = None
    superclass = None
    def __init__(self, gateWidth='0.5', period=None, epoch=None):
        self.gateWidth = _cast(None, gateWidth)
        self.period = _cast(float, period)
        self.epoch = _cast(None, epoch)
        pass
    def factory(*args_, **kwargs_):
        if gateModel.subclass:
            return gateModel.subclass(*args_, **kwargs_)
        else:
            return gateModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gateWidth(self): return self.gateWidth
    def set_gateWidth(self, gateWidth): self.gateWidth = gateWidth
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def export(self, outfile, level, namespace_='widar:', name_='gateModel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gateModel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='gateModel'):
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            outfile.write(' gateWidth=%s' % (quote_attrib(self.gateWidth), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_double(self.period, input_name='period'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='gateModel', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gateModel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            showIndent(outfile, level)
            outfile.write('gateWidth = %s,\n' % (self.gateWidth,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %e,\n' % (self.period,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gateWidth', node)
        if value is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            self.gateWidth = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (period): %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gateModel


class modelCoeff(GeneratedsSuper):
    """Coefficent for the gate models is the same as for delay models. This
    format will be used during the testing. When the full system is
    installed ASCII representation may be replaced by hexBinary."""
    subclass = None
    superclass = None
    def __init__(self, cff=None, index=None):
        self.cff = _cast(float, cff)
        self.index = _cast(int, index)
        pass
    def factory(*args_, **kwargs_):
        if modelCoeff.subclass:
            return modelCoeff.subclass(*args_, **kwargs_)
        else:
            return modelCoeff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cff(self): return self.cff
    def set_cff(self, cff): self.cff = cff
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def export(self, outfile, level, namespace_='widar:', name_='modelCoeff', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modelCoeff')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='modelCoeff'):
        if self.cff is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            outfile.write(' cff="%s"' % self.gds_format_double(self.cff, input_name='cff'))
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='modelCoeff', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modelCoeff'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cff is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            showIndent(outfile, level)
            outfile.write('cff = %e,\n' % (self.cff,))
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            showIndent(outfile, level)
            outfile.write('index = %d,\n' % (self.index,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cff', node)
        if value is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            try:
                self.cff = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (cff): %s' % exp)
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.append('index')
            try:
                self.index = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modelCoeff


class wbcProductByBandId(GeneratedsSuper):
    """Wideband Correlator Product. Specifies the product ID and input data
    streams that should be correlated. This format is used when
    there are multiple basebands in a Station Board input data
    stream. Data path and input band identifiers are used to specify
    the product."""
    subclass = None
    superclass = None
    def __init__(self, spectChannels=None, laggedDpId=None, promptDpId=None, promptBandId=None, laggedBandId=None, prodId=None, integFactor=1):
        self.spectChannels = _cast(None, spectChannels)
        self.laggedDpId = _cast(None, laggedDpId)
        self.promptDpId = _cast(None, promptDpId)
        self.promptBandId = _cast(None, promptBandId)
        self.laggedBandId = _cast(None, laggedBandId)
        self.prodId = _cast(None, prodId)
        self.integFactor = _cast(int, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if wbcProductByBandId.subclass:
            return wbcProductByBandId.subclass(*args_, **kwargs_)
        else:
            return wbcProductByBandId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectChannels(self): return self.spectChannels
    def set_spectChannels(self, spectChannels): self.spectChannels = spectChannels
    def get_laggedDpId(self): return self.laggedDpId
    def set_laggedDpId(self, laggedDpId): self.laggedDpId = laggedDpId
    def get_promptDpId(self): return self.promptDpId
    def set_promptDpId(self, promptDpId): self.promptDpId = promptDpId
    def get_promptBandId(self): return self.promptBandId
    def set_promptBandId(self, promptBandId): self.promptBandId = promptBandId
    def get_laggedBandId(self): return self.laggedBandId
    def set_laggedBandId(self, laggedBandId): self.laggedBandId = laggedBandId
    def get_prodId(self): return self.prodId
    def set_prodId(self, prodId): self.prodId = prodId
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='wbcProductByBandId', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wbcProductByBandId')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wbcProductByBandId'):
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            outfile.write(' spectChannels=%s' % (quote_attrib(self.spectChannels), ))
        if self.laggedDpId is not None and 'laggedDpId' not in already_processed:
            already_processed.append('laggedDpId')
            outfile.write(' laggedDpId=%s' % (quote_attrib(self.laggedDpId), ))
        if self.promptDpId is not None and 'promptDpId' not in already_processed:
            already_processed.append('promptDpId')
            outfile.write(' promptDpId=%s' % (quote_attrib(self.promptDpId), ))
        if self.promptBandId is not None and 'promptBandId' not in already_processed:
            already_processed.append('promptBandId')
            outfile.write(' promptBandId=%s' % (quote_attrib(self.promptBandId), ))
        if self.laggedBandId is not None and 'laggedBandId' not in already_processed:
            already_processed.append('laggedBandId')
            outfile.write(' laggedBandId=%s' % (quote_attrib(self.laggedBandId), ))
        if self.prodId is not None and 'prodId' not in already_processed:
            already_processed.append('prodId')
            outfile.write(' prodId=%s' % (quote_attrib(self.prodId), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor="%s"' % self.gds_format_integer(self.integFactor, input_name='integFactor'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wbcProductByBandId', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wbcProductByBandId'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            showIndent(outfile, level)
            outfile.write('spectChannels = %s,\n' % (self.spectChannels,))
        if self.laggedDpId is not None and 'laggedDpId' not in already_processed:
            already_processed.append('laggedDpId')
            showIndent(outfile, level)
            outfile.write('laggedDpId = %s,\n' % (self.laggedDpId,))
        if self.promptDpId is not None and 'promptDpId' not in already_processed:
            already_processed.append('promptDpId')
            showIndent(outfile, level)
            outfile.write('promptDpId = %s,\n' % (self.promptDpId,))
        if self.promptBandId is not None and 'promptBandId' not in already_processed:
            already_processed.append('promptBandId')
            showIndent(outfile, level)
            outfile.write('promptBandId = %s,\n' % (self.promptBandId,))
        if self.laggedBandId is not None and 'laggedBandId' not in already_processed:
            already_processed.append('laggedBandId')
            showIndent(outfile, level)
            outfile.write('laggedBandId = %s,\n' % (self.laggedBandId,))
        if self.prodId is not None and 'prodId' not in already_processed:
            already_processed.append('prodId')
            showIndent(outfile, level)
            outfile.write('prodId = %s,\n' % (self.prodId,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %d,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectChannels', node)
        if value is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            self.spectChannels = value
        value = find_attr_value_('laggedDpId', node)
        if value is not None and 'laggedDpId' not in already_processed:
            already_processed.append('laggedDpId')
            self.laggedDpId = value
        value = find_attr_value_('promptDpId', node)
        if value is not None and 'promptDpId' not in already_processed:
            already_processed.append('promptDpId')
            self.promptDpId = value
        value = find_attr_value_('promptBandId', node)
        if value is not None and 'promptBandId' not in already_processed:
            already_processed.append('promptBandId')
            self.promptBandId = value
        value = find_attr_value_('laggedBandId', node)
        if value is not None and 'laggedBandId' not in already_processed:
            already_processed.append('laggedBandId')
            self.laggedBandId = value
        value = find_attr_value_('prodId', node)
        if value is not None and 'prodId' not in already_processed:
            already_processed.append('prodId')
            self.prodId = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            try:
                self.integFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wbcProductByBandId


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'antenna'
        rootClass = antenna
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'antenna'
        rootClass = antenna
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="antenna",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'antenna'
        rootClass = antenna
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from vcicommon_mcast import *\n\n')
##     sys.stdout.write('import vcicommon_mcast as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "MsgCommentType",
    "actQueue",
    "affectedComponent",
    "antenna",
    "cfgQueue",
    "clipCounts",
    "cmAlerts",
    "cmDeleteSubarray",
    "cmLogging",
    "cmMonitorControl",
    "component",
    "crcTable",
    "ctrlQueue",
    "errorCounts",
    "gateModel",
    "host",
    "inputStateCounts",
    "modelCoeff",
    "moduleLocation",
    "monitorData",
    "noiseDiode",
    "originator",
    "outputStateCounts",
    "powerCounts",
    "property",
    "pulsarGating",
    "queryCfgStatus",
    "radarMode",
    "rfiCounts",
    "stbDataProducts",
    "tickIntervalCounts",
    "toneExtraction",
    "trowable",
    "vciReporting",
    "wbcPolProduct",
    "wbcProductByBandId",
    "widarHost"
    ]
