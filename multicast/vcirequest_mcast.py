#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Fri Sep 30 10:46:01 2011 by generateDS.py version 2.6a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class vciRequest(GeneratedsSuper):
    """VCI Request is a "wrapper" element. A single vciRequest may contain
    several configuration for several components and/or stations.
    vciRequest can contain several activationTriggers. Element
    vciRequest can not contain configuration for more than one
    subarray."""
    subclass = None
    superclass = None
    def __init__(self, msgId=None, desc=None, version=None, timeStamp=None, component=None, stationHw=None, subArray=None, activationTrigger=None, cmMonitorControl=None):
        self.msgId = _cast(int, msgId)
        self.desc = _cast(None, desc)
        self.version = _cast(None, version)
        self.timeStamp = _cast(None, timeStamp)
        if component is None:
            self.component = []
        else:
            self.component = component
        if stationHw is None:
            self.stationHw = []
        else:
            self.stationHw = stationHw
        self.subArray = subArray
        if activationTrigger is None:
            self.activationTrigger = []
        else:
            self.activationTrigger = activationTrigger
        self.cmMonitorControl = cmMonitorControl
    def factory(*args_, **kwargs_):
        if vciRequest.subclass:
            return vciRequest.subclass(*args_, **kwargs_)
        else:
            return vciRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_component(self): return self.component
    def set_component(self, component): self.component = component
    def add_component(self, value): self.component.append(value)
    def insert_component(self, index, value): self.component[index] = value
    def get_stationHw(self): return self.stationHw
    def set_stationHw(self, stationHw): self.stationHw = stationHw
    def add_stationHw(self, value): self.stationHw.append(value)
    def insert_stationHw(self, index, value): self.stationHw[index] = value
    def get_subArray(self): return self.subArray
    def set_subArray(self, subArray): self.subArray = subArray
    def get_activationTrigger(self): return self.activationTrigger
    def set_activationTrigger(self, activationTrigger): self.activationTrigger = activationTrigger
    def add_activationTrigger(self, value): self.activationTrigger.append(value)
    def insert_activationTrigger(self, index, value): self.activationTrigger[index] = value
    def get_cmMonitorControl(self): return self.cmMonitorControl
    def set_cmMonitorControl(self, cmMonitorControl): self.cmMonitorControl = cmMonitorControl
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def export(self, outfile, level, namespace_='widar:', name_='vciRequest', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vciRequest')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vciRequest'):
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.append('desc')
            outfile.write(' desc=%s' % (self.gds_format_string(quote_attrib(self.desc).encode(ExternalEncoding), input_name='desc'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vciRequest', fromsubclass_=False):
        for component_ in self.component:
            component_.export(outfile, level, namespace_, name_='component')
        for stationHw_ in self.stationHw:
            stationHw_.export(outfile, level, namespace_, name_='stationHw')
        if self.subArray:
            self.subArray.export(outfile, level, namespace_, name_='subArray')
        for activationTrigger_ in self.activationTrigger:
            activationTrigger_.export(outfile, level, namespace_, name_='activationTrigger')
        if self.cmMonitorControl:
            self.cmMonitorControl.export(outfile, level, namespace_, name_='cmMonitorControl')
    def hasContent_(self):
        if (
            self.component or
            self.stationHw or
            self.subArray is not None or
            self.activationTrigger or
            self.cmMonitorControl is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vciRequest'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.append('desc')
            showIndent(outfile, level)
            outfile.write('desc = "%s",\n' % (self.desc,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = %s,\n' % (self.version,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('component=[\n')
        level += 1
        for component_ in self.component:
            showIndent(outfile, level)
            outfile.write('model_.component(\n')
            component_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('stationHw=[\n')
        level += 1
        for stationHw_ in self.stationHw:
            showIndent(outfile, level)
            outfile.write('model_.stationHw(\n')
            stationHw_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.subArray is not None:
            showIndent(outfile, level)
            outfile.write('subArray=model_.subArray(\n')
            self.subArray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('activationTrigger=[\n')
        level += 1
        for activationTrigger_ in self.activationTrigger:
            showIndent(outfile, level)
            outfile.write('model_.activationTrigger(\n')
            activationTrigger_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cmMonitorControl is not None:
            showIndent(outfile, level)
            outfile.write('cmMonitorControl=model_.cmMonitorControl(\n')
            self.cmMonitorControl.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.append('desc')
            self.desc = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'component':
            obj_ = component.factory()
            obj_.build(child_)
            self.component.append(obj_)
        elif nodeName_ == 'stationHw':
            obj_ = stationHw.factory()
            obj_.build(child_)
            self.stationHw.append(obj_)
        elif nodeName_ == 'subArray':
            obj_ = subArray.factory()
            obj_.build(child_)
            self.set_subArray(obj_)
        elif nodeName_ == 'activationTrigger':
            obj_ = activationTrigger.factory()
            obj_.build(child_)
            self.activationTrigger.append(obj_)
        elif nodeName_ == 'cmMonitorControl':
            obj_ = cmMonitorControl.factory()
            obj_.build(child_)
            self.set_cmMonitorControl(obj_)
# end class vciRequest


class activationTrigger(GeneratedsSuper):
    """VCI Configuration Activation Trigger. Activation time for the
    configuration request messages with the same activation
    identifier."""
    subclass = None
    superclass = None
    def __init__(self, rollback='0', msgId=None, timeStamp=None, activationId=None, mappingTime=None, fastSwitching='0', query='no', activationTime=None):
        self.rollback = _cast(None, rollback)
        self.msgId = _cast(int, msgId)
        self.timeStamp = _cast(None, timeStamp)
        self.activationId = _cast(None, activationId)
        self.mappingTime = _cast(None, mappingTime)
        self.fastSwitching = _cast(None, fastSwitching)
        self.query = _cast(None, query)
        self.activationTime = _cast(None, activationTime)
        pass
    def factory(*args_, **kwargs_):
        if activationTrigger.subclass:
            return activationTrigger.subclass(*args_, **kwargs_)
        else:
            return activationTrigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rollback(self): return self.rollback
    def set_rollback(self, rollback): self.rollback = rollback
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_activationId(self): return self.activationId
    def set_activationId(self, activationId): self.activationId = activationId
    def get_mappingTime(self): return self.mappingTime
    def set_mappingTime(self, mappingTime): self.mappingTime = mappingTime
    def get_fastSwitching(self): return self.fastSwitching
    def set_fastSwitching(self, fastSwitching): self.fastSwitching = fastSwitching
    def get_query(self): return self.query
    def set_query(self, query): self.query = query
    def get_activationTime(self): return self.activationTime
    def set_activationTime(self, activationTime): self.activationTime = activationTime
    def export(self, outfile, level, namespace_='widar:', name_='activationTrigger', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activationTrigger')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='activationTrigger'):
        if self.rollback is not None and 'rollback' not in already_processed:
            already_processed.append('rollback')
            outfile.write(' rollback=%s' % (quote_attrib(self.rollback), ))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            outfile.write(' activationId=%s' % (self.gds_format_string(quote_attrib(self.activationId).encode(ExternalEncoding), input_name='activationId'), ))
        if self.mappingTime is not None and 'mappingTime' not in already_processed:
            already_processed.append('mappingTime')
            outfile.write(' mappingTime=%s' % (self.gds_format_string(quote_attrib(self.mappingTime).encode(ExternalEncoding), input_name='mappingTime'), ))
        if self.fastSwitching is not None and 'fastSwitching' not in already_processed:
            already_processed.append('fastSwitching')
            outfile.write(' fastSwitching=%s' % (quote_attrib(self.fastSwitching), ))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            outfile.write(' query=%s' % (quote_attrib(self.query), ))
        if self.activationTime is not None and 'activationTime' not in already_processed:
            already_processed.append('activationTime')
            outfile.write(' activationTime=%s' % (self.gds_format_string(quote_attrib(self.activationTime).encode(ExternalEncoding), input_name='activationTime'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='activationTrigger', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activationTrigger'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rollback is not None and 'rollback' not in already_processed:
            already_processed.append('rollback')
            showIndent(outfile, level)
            outfile.write('rollback = %s,\n' % (self.rollback,))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            showIndent(outfile, level)
            outfile.write('activationId = "%s",\n' % (self.activationId,))
        if self.mappingTime is not None and 'mappingTime' not in already_processed:
            already_processed.append('mappingTime')
            showIndent(outfile, level)
            outfile.write('mappingTime = "%s",\n' % (self.mappingTime,))
        if self.fastSwitching is not None and 'fastSwitching' not in already_processed:
            already_processed.append('fastSwitching')
            showIndent(outfile, level)
            outfile.write('fastSwitching = %s,\n' % (self.fastSwitching,))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            showIndent(outfile, level)
            outfile.write('query = %s,\n' % (self.query,))
        if self.activationTime is not None and 'activationTime' not in already_processed:
            already_processed.append('activationTime')
            showIndent(outfile, level)
            outfile.write('activationTime = "%s",\n' % (self.activationTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rollback', node)
        if value is not None and 'rollback' not in already_processed:
            already_processed.append('rollback')
            self.rollback = value
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
        value = find_attr_value_('activationId', node)
        if value is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            self.activationId = value
        value = find_attr_value_('mappingTime', node)
        if value is not None and 'mappingTime' not in already_processed:
            already_processed.append('mappingTime')
            self.mappingTime = value
        value = find_attr_value_('fastSwitching', node)
        if value is not None and 'fastSwitching' not in already_processed:
            already_processed.append('fastSwitching')
            self.fastSwitching = value
        value = find_attr_value_('query', node)
        if value is not None and 'query' not in already_processed:
            already_processed.append('query')
            self.query = value
        value = find_attr_value_('activationTime', node)
        if value is not None and 'activationTime' not in already_processed:
            already_processed.append('activationTime')
            self.activationTime = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class activationTrigger


class stationHw(GeneratedsSuper):
    """Assigns Station ID to a group of Station Boards that receive input
    from the same antenna. This element assigns Baseband ID to a
    Station Board Data Path. Primary purpose of this element is
    resource allocation. Additional elements and atributes have been
    added, that allow user to specify station specific attributes
    that are not likely to change for every scan: - Antenna ID and
    other antenna parameters, - Noise Diode parameters, - Parameters
    related to generation of monitor data. If, at the Activation
    Time, a station with the same Station ID already exists, it is
    replaced by the new configuration. A (previously configured)
    station that belongs to a subarray cannot be re-configured.
    Station ID and Baseband IDs assigned here are used when
    specifying subarray configuration."""
    subclass = None
    superclass = None
    def __init__(self, name=None, timeStamp=None, msgId=None, mappingOrder=None, activationId=None, sid=None, action=None, baseBandHw=None, noiseDiode=None, antenna=None, monitorData=None):
        self.name = _cast(None, name)
        self.timeStamp = _cast(None, timeStamp)
        self.msgId = _cast(int, msgId)
        self.mappingOrder = _cast(int, mappingOrder)
        self.activationId = _cast(None, activationId)
        self.sid = _cast(None, sid)
        self.action = _cast(None, action)
        if baseBandHw is None:
            self.baseBandHw = []
        else:
            self.baseBandHw = baseBandHw
        self.noiseDiode = noiseDiode
        self.antenna = antenna
        self.monitorData = monitorData
    def factory(*args_, **kwargs_):
        if stationHw.subclass:
            return stationHw.subclass(*args_, **kwargs_)
        else:
            return stationHw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseBandHw(self): return self.baseBandHw
    def set_baseBandHw(self, baseBandHw): self.baseBandHw = baseBandHw
    def add_baseBandHw(self, value): self.baseBandHw.append(value)
    def insert_baseBandHw(self, index, value): self.baseBandHw[index] = value
    def get_noiseDiode(self): return self.noiseDiode
    def set_noiseDiode(self, noiseDiode): self.noiseDiode = noiseDiode
    def get_antenna(self): return self.antenna
    def set_antenna(self, antenna): self.antenna = antenna
    def get_monitorData(self): return self.monitorData
    def set_monitorData(self, monitorData): self.monitorData = monitorData
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_mappingOrder(self): return self.mappingOrder
    def set_mappingOrder(self, mappingOrder): self.mappingOrder = mappingOrder
    def get_activationId(self): return self.activationId
    def set_activationId(self, activationId): self.activationId = activationId
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def export(self, outfile, level, namespace_='widar:', name_='stationHw', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stationHw')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stationHw'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            outfile.write(' mappingOrder="%s"' % self.gds_format_integer(self.mappingOrder, input_name='mappingOrder'))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            outfile.write(' activationId=%s' % (self.gds_format_string(quote_attrib(self.activationId).encode(ExternalEncoding), input_name='activationId'), ))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stationHw', fromsubclass_=False):
        for baseBandHw_ in self.baseBandHw:
            baseBandHw_.export(outfile, level, namespace_, name_='baseBandHw')
        if self.noiseDiode:
            self.noiseDiode.export(outfile, level, namespace_, name_='noiseDiode')
        if self.antenna:
            self.antenna.export(outfile, level, namespace_, name_='antenna')
        if self.monitorData:
            self.monitorData.export(outfile, level, namespace_, name_='monitorData')
    def hasContent_(self):
        if (
            self.baseBandHw or
            self.noiseDiode is not None or
            self.antenna is not None or
            self.monitorData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stationHw'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            showIndent(outfile, level)
            outfile.write('mappingOrder = %d,\n' % (self.mappingOrder,))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            showIndent(outfile, level)
            outfile.write('activationId = "%s",\n' % (self.activationId,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('baseBandHw=[\n')
        level += 1
        for baseBandHw_ in self.baseBandHw:
            showIndent(outfile, level)
            outfile.write('model_.baseBandHw(\n')
            baseBandHw_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.noiseDiode is not None:
            showIndent(outfile, level)
            outfile.write('noiseDiode=model_.noiseDiode(\n')
            self.noiseDiode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.antenna is not None:
            showIndent(outfile, level)
            outfile.write('antenna=model_.antenna(\n')
            self.antenna.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.monitorData is not None:
            showIndent(outfile, level)
            outfile.write('monitorData=model_.monitorData(\n')
            self.monitorData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('mappingOrder', node)
        if value is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            try:
                self.mappingOrder = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('activationId', node)
        if value is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            self.activationId = value
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseBandHw':
            obj_ = baseBandHw.factory()
            obj_.build(child_)
            self.baseBandHw.append(obj_)
        elif nodeName_ == 'noiseDiode':
            obj_ = noiseDiode.factory()
            obj_.build(child_)
            self.set_noiseDiode(obj_)
        elif nodeName_ == 'antenna':
            obj_ = antenna.factory()
            obj_.build(child_)
            self.set_antenna(obj_)
        elif nodeName_ == 'monitorData':
            obj_ = monitorData.factory()
            obj_.build(child_)
            self.set_monitorData(obj_)
# end class stationHw


class baseBandHw(GeneratedsSuper):
    """Used to: assign Baseband ID to a Station Board Data Path."""
    subclass = None
    superclass = None
    def __init__(self, stationBoardMlid=None, dataPath=None, name=None, bbid=None):
        self.stationBoardMlid = _cast(None, stationBoardMlid)
        self.dataPath = _cast(None, dataPath)
        self.name = _cast(None, name)
        self.bbid = _cast(None, bbid)
        pass
    def factory(*args_, **kwargs_):
        if baseBandHw.subclass:
            return baseBandHw.subclass(*args_, **kwargs_)
        else:
            return baseBandHw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stationBoardMlid(self): return self.stationBoardMlid
    def set_stationBoardMlid(self, stationBoardMlid): self.stationBoardMlid = stationBoardMlid
    def get_dataPath(self): return self.dataPath
    def set_dataPath(self, dataPath): self.dataPath = dataPath
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_bbid(self): return self.bbid
    def set_bbid(self, bbid): self.bbid = bbid
    def export(self, outfile, level, namespace_='widar:', name_='baseBandHw', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseBandHw')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='baseBandHw'):
        if self.stationBoardMlid is not None and 'stationBoardMlid' not in already_processed:
            already_processed.append('stationBoardMlid')
            outfile.write(' stationBoardMlid=%s' % (self.gds_format_string(quote_attrib(self.stationBoardMlid).encode(ExternalEncoding), input_name='stationBoardMlid'), ))
        if self.dataPath is not None and 'dataPath' not in already_processed:
            already_processed.append('dataPath')
            outfile.write(' dataPath=%s' % (quote_attrib(self.dataPath), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            outfile.write(' bbid=%s' % (quote_attrib(self.bbid), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='baseBandHw', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='baseBandHw'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.stationBoardMlid is not None and 'stationBoardMlid' not in already_processed:
            already_processed.append('stationBoardMlid')
            showIndent(outfile, level)
            outfile.write('stationBoardMlid = "%s",\n' % (self.stationBoardMlid,))
        if self.dataPath is not None and 'dataPath' not in already_processed:
            already_processed.append('dataPath')
            showIndent(outfile, level)
            outfile.write('dataPath = %s,\n' % (self.dataPath,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            showIndent(outfile, level)
            outfile.write('bbid = %s,\n' % (self.bbid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('stationBoardMlid', node)
        if value is not None and 'stationBoardMlid' not in already_processed:
            already_processed.append('stationBoardMlid')
            self.stationBoardMlid = value
        value = find_attr_value_('dataPath', node)
        if value is not None and 'dataPath' not in already_processed:
            already_processed.append('dataPath')
            self.dataPath = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('bbid', node)
        if value is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            self.bbid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class baseBandHw


class subArray(GeneratedsSuper):
    """Subarray Configuration Contains: - list of stations that belong to
    the subarray, - description of input data (basebands), and -
    specification for desired output products. Station IDs and
    BaseBandIDs used here must be defined using element stationHw. A
    station can have up to four baseband pairs or up to 8 single
    basebands. A combination of baseband pairs and singletons is
    also allowed. dtEpoch is epoch for DumpTrig signal. Applies for
    all basebands/subbands. Element modifySummedArray should be
    specified only if action is "modify"."""
    subclass = None
    superclass = None
    def __init__(self, subarrayId=None, scanId=None, name=None, msgId=None, reConfigureCompleteBaselineBoards=False, mappingOrder=None, modelErrorReportingThreshold=None, dtEpoch=None, activationId=None, observationTime=None, timeStamp=None, action='create', configId=None, targetRqRms=None, listOfStations=None, stationInputOutput=None, baseline=None, modifySummedArray=None, stbDataProducts=None, monitorData=None):
        self.subarrayId = _cast(None, subarrayId)
        self.scanId = _cast(None, scanId)
        self.name = _cast(None, name)
        self.msgId = _cast(int, msgId)
        self.reConfigureCompleteBaselineBoards = _cast(bool, reConfigureCompleteBaselineBoards)
        self.mappingOrder = _cast(int, mappingOrder)
        self.modelErrorReportingThreshold = _cast(int, modelErrorReportingThreshold)
        self.dtEpoch = _cast(None, dtEpoch)
        self.activationId = _cast(None, activationId)
        self.observationTime = _cast(None, observationTime)
        self.timeStamp = _cast(None, timeStamp)
        self.action = _cast(None, action)
        self.configId = _cast(None, configId)
        self.targetRqRms = _cast(None, targetRqRms)
        self.listOfStations = listOfStations
        if stationInputOutput is None:
            self.stationInputOutput = []
        else:
            self.stationInputOutput = stationInputOutput
        if baseline is None:
            self.baseline = []
        else:
            self.baseline = baseline
        self.modifySummedArray = modifySummedArray
        self.stbDataProducts = stbDataProducts
        self.monitorData = monitorData
    def factory(*args_, **kwargs_):
        if subArray.subclass:
            return subArray.subclass(*args_, **kwargs_)
        else:
            return subArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_listOfStations(self): return self.listOfStations
    def set_listOfStations(self, listOfStations): self.listOfStations = listOfStations
    def get_stationInputOutput(self): return self.stationInputOutput
    def set_stationInputOutput(self, stationInputOutput): self.stationInputOutput = stationInputOutput
    def add_stationInputOutput(self, value): self.stationInputOutput.append(value)
    def insert_stationInputOutput(self, index, value): self.stationInputOutput[index] = value
    def get_baseline(self): return self.baseline
    def set_baseline(self, baseline): self.baseline = baseline
    def add_baseline(self, value): self.baseline.append(value)
    def insert_baseline(self, index, value): self.baseline[index] = value
    def get_modifySummedArray(self): return self.modifySummedArray
    def set_modifySummedArray(self, modifySummedArray): self.modifySummedArray = modifySummedArray
    def get_stbDataProducts(self): return self.stbDataProducts
    def set_stbDataProducts(self, stbDataProducts): self.stbDataProducts = stbDataProducts
    def get_monitorData(self): return self.monitorData
    def set_monitorData(self, monitorData): self.monitorData = monitorData
    def get_subarrayId(self): return self.subarrayId
    def set_subarrayId(self, subarrayId): self.subarrayId = subarrayId
    def get_scanId(self): return self.scanId
    def set_scanId(self, scanId): self.scanId = scanId
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_reConfigureCompleteBaselineBoards(self): return self.reConfigureCompleteBaselineBoards
    def set_reConfigureCompleteBaselineBoards(self, reConfigureCompleteBaselineBoards): self.reConfigureCompleteBaselineBoards = reConfigureCompleteBaselineBoards
    def get_mappingOrder(self): return self.mappingOrder
    def set_mappingOrder(self, mappingOrder): self.mappingOrder = mappingOrder
    def get_modelErrorReportingThreshold(self): return self.modelErrorReportingThreshold
    def set_modelErrorReportingThreshold(self, modelErrorReportingThreshold): self.modelErrorReportingThreshold = modelErrorReportingThreshold
    def get_dtEpoch(self): return self.dtEpoch
    def set_dtEpoch(self, dtEpoch): self.dtEpoch = dtEpoch
    def get_activationId(self): return self.activationId
    def set_activationId(self, activationId): self.activationId = activationId
    def get_observationTime(self): return self.observationTime
    def set_observationTime(self, observationTime): self.observationTime = observationTime
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_configId(self): return self.configId
    def set_configId(self, configId): self.configId = configId
    def get_targetRqRms(self): return self.targetRqRms
    def set_targetRqRms(self, targetRqRms): self.targetRqRms = targetRqRms
    def export(self, outfile, level, namespace_='widar:', name_='subArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='subArray'):
        if self.subarrayId is not None and 'subarrayId' not in already_processed:
            already_processed.append('subarrayId')
            outfile.write(' subarrayId=%s' % (self.gds_format_string(quote_attrib(self.subarrayId).encode(ExternalEncoding), input_name='subarrayId'), ))
        if self.scanId is not None and 'scanId' not in already_processed:
            already_processed.append('scanId')
            outfile.write(' scanId=%s' % (self.gds_format_string(quote_attrib(self.scanId).encode(ExternalEncoding), input_name='scanId'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.reConfigureCompleteBaselineBoards is not None and 'reConfigureCompleteBaselineBoards' not in already_processed:
            already_processed.append('reConfigureCompleteBaselineBoards')
            outfile.write(' reConfigureCompleteBaselineBoards="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.reConfigureCompleteBaselineBoards)), input_name='reConfigureCompleteBaselineBoards'))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            outfile.write(' mappingOrder="%s"' % self.gds_format_integer(self.mappingOrder, input_name='mappingOrder'))
        if self.modelErrorReportingThreshold is not None and 'modelErrorReportingThreshold' not in already_processed:
            already_processed.append('modelErrorReportingThreshold')
            outfile.write(' modelErrorReportingThreshold="%s"' % self.gds_format_integer(self.modelErrorReportingThreshold, input_name='modelErrorReportingThreshold'))
        if self.dtEpoch is not None and 'dtEpoch' not in already_processed:
            already_processed.append('dtEpoch')
            outfile.write(' dtEpoch=%s' % (self.gds_format_string(quote_attrib(self.dtEpoch).encode(ExternalEncoding), input_name='dtEpoch'), ))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            outfile.write(' activationId=%s' % (self.gds_format_string(quote_attrib(self.activationId).encode(ExternalEncoding), input_name='activationId'), ))
        if self.observationTime is not None and 'observationTime' not in already_processed:
            already_processed.append('observationTime')
            outfile.write(' observationTime=%s' % (self.gds_format_string(quote_attrib(self.observationTime).encode(ExternalEncoding), input_name='observationTime'), ))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            outfile.write(' configId=%s' % (self.gds_format_string(quote_attrib(self.configId).encode(ExternalEncoding), input_name='configId'), ))
        if self.targetRqRms is not None and 'targetRqRms' not in already_processed:
            already_processed.append('targetRqRms')
            outfile.write(' targetRqRms=%s' % (self.gds_format_string(quote_attrib(self.targetRqRms).encode(ExternalEncoding), input_name='targetRqRms'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='subArray', fromsubclass_=False):
        if self.listOfStations:
            self.listOfStations.export(outfile, level, namespace_, name_='listOfStations')
        for stationInputOutput_ in self.stationInputOutput:
            stationInputOutput_.export(outfile, level, namespace_, name_='stationInputOutput')
        for baseline_ in self.baseline:
            baseline_.export(outfile, level, namespace_, name_='baseline')
        if self.modifySummedArray:
            self.modifySummedArray.export(outfile, level, namespace_, name_='modifySummedArray')
        if self.stbDataProducts:
            self.stbDataProducts.export(outfile, level, namespace_, name_='stbDataProducts')
        if self.monitorData:
            self.monitorData.export(outfile, level, namespace_, name_='monitorData')
    def hasContent_(self):
        if (
            self.listOfStations is not None or
            self.stationInputOutput or
            self.baseline or
            self.modifySummedArray is not None or
            self.stbDataProducts is not None or
            self.monitorData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subarrayId is not None and 'subarrayId' not in already_processed:
            already_processed.append('subarrayId')
            showIndent(outfile, level)
            outfile.write('subarrayId = "%s",\n' % (self.subarrayId,))
        if self.scanId is not None and 'scanId' not in already_processed:
            already_processed.append('scanId')
            showIndent(outfile, level)
            outfile.write('scanId = "%s",\n' % (self.scanId,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.reConfigureCompleteBaselineBoards is not None and 'reConfigureCompleteBaselineBoards' not in already_processed:
            already_processed.append('reConfigureCompleteBaselineBoards')
            showIndent(outfile, level)
            outfile.write('reConfigureCompleteBaselineBoards = %s,\n' % (self.reConfigureCompleteBaselineBoards,))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            showIndent(outfile, level)
            outfile.write('mappingOrder = %d,\n' % (self.mappingOrder,))
        if self.modelErrorReportingThreshold is not None and 'modelErrorReportingThreshold' not in already_processed:
            already_processed.append('modelErrorReportingThreshold')
            showIndent(outfile, level)
            outfile.write('modelErrorReportingThreshold = %d,\n' % (self.modelErrorReportingThreshold,))
        if self.dtEpoch is not None and 'dtEpoch' not in already_processed:
            already_processed.append('dtEpoch')
            showIndent(outfile, level)
            outfile.write('dtEpoch = "%s",\n' % (self.dtEpoch,))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            showIndent(outfile, level)
            outfile.write('activationId = "%s",\n' % (self.activationId,))
        if self.observationTime is not None and 'observationTime' not in already_processed:
            already_processed.append('observationTime')
            showIndent(outfile, level)
            outfile.write('observationTime = "%s",\n' % (self.observationTime,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            showIndent(outfile, level)
            outfile.write('configId = "%s",\n' % (self.configId,))
        if self.targetRqRms is not None and 'targetRqRms' not in already_processed:
            already_processed.append('targetRqRms')
            showIndent(outfile, level)
            outfile.write('targetRqRms = "%s",\n' % (self.targetRqRms,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.listOfStations is not None:
            showIndent(outfile, level)
            outfile.write('listOfStations=model_.listOfStations(\n')
            self.listOfStations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stationInputOutput=[\n')
        level += 1
        for stationInputOutput_ in self.stationInputOutput:
            showIndent(outfile, level)
            outfile.write('model_.stationInputOutput(\n')
            stationInputOutput_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('baseline=[\n')
        level += 1
        for baseline_ in self.baseline:
            showIndent(outfile, level)
            outfile.write('model_.baseline(\n')
            baseline_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.modifySummedArray is not None:
            showIndent(outfile, level)
            outfile.write('modifySummedArray=model_.modifySummedArray(\n')
            self.modifySummedArray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.stbDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('stbDataProducts=model_.stbDataProducts(\n')
            self.stbDataProducts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.monitorData is not None:
            showIndent(outfile, level)
            outfile.write('monitorData=model_.monitorData(\n')
            self.monitorData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subarrayId', node)
        if value is not None and 'subarrayId' not in already_processed:
            already_processed.append('subarrayId')
            self.subarrayId = value
        value = find_attr_value_('scanId', node)
        if value is not None and 'scanId' not in already_processed:
            already_processed.append('scanId')
            self.scanId = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('reConfigureCompleteBaselineBoards', node)
        if value is not None and 'reConfigureCompleteBaselineBoards' not in already_processed:
            already_processed.append('reConfigureCompleteBaselineBoards')
            if value in ('true', '1'):
                self.reConfigureCompleteBaselineBoards = True
            elif value in ('false', '0'):
                self.reConfigureCompleteBaselineBoards = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('mappingOrder', node)
        if value is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            try:
                self.mappingOrder = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('modelErrorReportingThreshold', node)
        if value is not None and 'modelErrorReportingThreshold' not in already_processed:
            already_processed.append('modelErrorReportingThreshold')
            try:
                self.modelErrorReportingThreshold = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dtEpoch', node)
        if value is not None and 'dtEpoch' not in already_processed:
            already_processed.append('dtEpoch')
            self.dtEpoch = value
        value = find_attr_value_('activationId', node)
        if value is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            self.activationId = value
        value = find_attr_value_('observationTime', node)
        if value is not None and 'observationTime' not in already_processed:
            already_processed.append('observationTime')
            self.observationTime = value
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('configId', node)
        if value is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            self.configId = value
        value = find_attr_value_('targetRqRms', node)
        if value is not None and 'targetRqRms' not in already_processed:
            already_processed.append('targetRqRms')
            self.targetRqRms = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'listOfStations':
            obj_ = listOfStations.factory()
            obj_.build(child_)
            self.set_listOfStations(obj_)
        elif nodeName_ == 'stationInputOutput':
            obj_ = stationInputOutput.factory()
            obj_.build(child_)
            self.stationInputOutput.append(obj_)
        elif nodeName_ == 'baseline':
            obj_ = baseline.factory()
            obj_.build(child_)
            self.baseline.append(obj_)
        elif nodeName_ == 'modifySummedArray':
            obj_ = modifySummedArray.factory()
            obj_.build(child_)
            self.set_modifySummedArray(obj_)
        elif nodeName_ == 'stbDataProducts':
            obj_ = stbDataProducts.factory()
            obj_.build(child_)
            self.set_stbDataProducts(obj_)
        elif nodeName_ == 'monitorData':
            obj_ = monitorData.factory()
            obj_.build(child_)
            self.set_monitorData(obj_)
# end class subArray


class listOfStations(GeneratedsSuper):
    """List of stations that belong to the subarray. Only known stations
    (i.e. stations that were previously defined using stationHw) can
    be listed here."""
    subclass = None
    superclass = None
    def __init__(self, action='add', station=None):
        self.action = _cast(None, action)
        if station is None:
            self.station = []
        else:
            self.station = station
    def factory(*args_, **kwargs_):
        if listOfStations.subclass:
            return listOfStations.subclass(*args_, **kwargs_)
        else:
            return listOfStations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def add_station(self, value): self.station.append(value)
    def insert_station(self, index, value): self.station[index] = value
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def export(self, outfile, level, namespace_='widar:', name_='listOfStations', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='listOfStations')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='listOfStations'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='listOfStations', fromsubclass_=False):
        for station_ in self.station:
            station_.export(outfile, level, namespace_, name_='station')
    def hasContent_(self):
        if (
            self.station
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='listOfStations'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('station=[\n')
        level += 1
        for station_ in self.station:
            showIndent(outfile, level)
            outfile.write('model_.station(\n')
            station_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'station':
            obj_ = station.factory()
            obj_.build(child_)
            self.station.append(obj_)
# end class listOfStations


class station(GeneratedsSuper):
    """Element station is used to specify the list of stations (antennas)
    that belong to a subarray. The list of stations can be specified
    either in subarray/listOfStations or in
    subarray/stationInputOutput. Preffered use: subarrayInputOutput.
    (Subarray/listOfStations is the older version preserved for
    backwards compatibility.) The only attributes (other than name)
    that can be specified in this element are Local Oscillator and
    Frequency Shift. These parameters are different for each
    antenna. Normally, Local Oscillator and Frequency Shift are
    specified in the delay models, but, for testing purposes they
    can be specified here. LO and Frequency Shift can be specified
    in: - VCI screate subarray, - VCI modify subarray, or - STB
    Delay Models."""
    subclass = None
    superclass = None
    def __init__(self, action=None, name=None, sid=None, bb=None):
        self.action = _cast(None, action)
        self.name = _cast(None, name)
        self.sid = _cast(None, sid)
        if bb is None:
            self.bb = []
        else:
            self.bb = bb
    def factory(*args_, **kwargs_):
        if station.subclass:
            return station.subclass(*args_, **kwargs_)
        else:
            return station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bb(self): return self.bb
    def set_bb(self, bb): self.bb = bb
    def add_bb(self, value): self.bb.append(value)
    def insert_bb(self, index, value): self.bb[index] = value
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def export(self, outfile, level, namespace_='widar:', name_='station', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='station')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='station'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='station', fromsubclass_=False):
        for bb_ in self.bb:
            bb_.export(outfile, level, namespace_, name_='bb')
    def hasContent_(self):
        if (
            self.bb
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='station'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bb=[\n')
        level += 1
        for bb_ in self.bb:
            showIndent(outfile, level)
            outfile.write('model_.bb(\n')
            bb_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bb':
            obj_ = bb.factory()
            obj_.build(child_)
            self.bb.append(obj_)
# end class station


class bb(GeneratedsSuper):
    """Baseband parameters that are different for each antenna (station)."""
    subclass = None
    superclass = None
    def __init__(self, freqShift=None, localOsc=None, bbid=None):
        self.freqShift = _cast(float, freqShift)
        self.localOsc = _cast(float, localOsc)
        self.bbid = _cast(None, bbid)
        pass
    def factory(*args_, **kwargs_):
        if bb.subclass:
            return bb.subclass(*args_, **kwargs_)
        else:
            return bb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_freqShift(self): return self.freqShift
    def set_freqShift(self, freqShift): self.freqShift = freqShift
    def get_localOsc(self): return self.localOsc
    def set_localOsc(self, localOsc): self.localOsc = localOsc
    def get_bbid(self): return self.bbid
    def set_bbid(self, bbid): self.bbid = bbid
    def export(self, outfile, level, namespace_='widar:', name_='bb', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bb')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='bb'):
        if self.freqShift is not None and 'freqShift' not in already_processed:
            already_processed.append('freqShift')
            outfile.write(' freqShift="%s"' % self.gds_format_double(self.freqShift, input_name='freqShift'))
        if self.localOsc is not None and 'localOsc' not in already_processed:
            already_processed.append('localOsc')
            outfile.write(' localOsc="%s"' % self.gds_format_double(self.localOsc, input_name='localOsc'))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            outfile.write(' bbid=%s' % (quote_attrib(self.bbid), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='bb', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bb'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.freqShift is not None and 'freqShift' not in already_processed:
            already_processed.append('freqShift')
            showIndent(outfile, level)
            outfile.write('freqShift = %e,\n' % (self.freqShift,))
        if self.localOsc is not None and 'localOsc' not in already_processed:
            already_processed.append('localOsc')
            showIndent(outfile, level)
            outfile.write('localOsc = %e,\n' % (self.localOsc,))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            showIndent(outfile, level)
            outfile.write('bbid = %s,\n' % (self.bbid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('freqShift', node)
        if value is not None and 'freqShift' not in already_processed:
            already_processed.append('freqShift')
            try:
                self.freqShift = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (freqShift): %s' % exp)
        value = find_attr_value_('localOsc', node)
        if value is not None and 'localOsc' not in already_processed:
            already_processed.append('localOsc')
            try:
                self.localOsc = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (localOsc): %s' % exp)
        value = find_attr_value_('bbid', node)
        if value is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            self.bbid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bb


class bbParams(GeneratedsSuper):
    """This element can be used to specify parameters for individual
    Basebands. The parameters (attributes) specified here can be
    different for Basebands that belong to the same pair. Typically,
    these parameters are same for all the stations in a subarray,
    but they can be specified for each station individually. Removed
    attributes: xs:attribute name="fshift_kHz" type="xs:double"
    use="optional" xs:attribute name="lo_o_MHz" type="xs:double"
    use="optional" """
    subclass = None
    superclass = None
    def __init__(self, sourceType=None, sourceId=None, sideband=None, bbid=None, polarization=None, phaseModelInsertion=None, sbParams=None):
        self.sourceType = _cast(None, sourceType)
        self.sourceId = _cast(None, sourceId)
        self.sideband = _cast(None, sideband)
        self.bbid = _cast(None, bbid)
        self.polarization = _cast(None, polarization)
        self.phaseModelInsertion = _cast(None, phaseModelInsertion)
        if sbParams is None:
            self.sbParams = []
        else:
            self.sbParams = sbParams
    def factory(*args_, **kwargs_):
        if bbParams.subclass:
            return bbParams.subclass(*args_, **kwargs_)
        else:
            return bbParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sbParams(self): return self.sbParams
    def set_sbParams(self, sbParams): self.sbParams = sbParams
    def add_sbParams(self, value): self.sbParams.append(value)
    def insert_sbParams(self, index, value): self.sbParams[index] = value
    def get_sourceType(self): return self.sourceType
    def set_sourceType(self, sourceType): self.sourceType = sourceType
    def get_sourceId(self): return self.sourceId
    def set_sourceId(self, sourceId): self.sourceId = sourceId
    def get_sideband(self): return self.sideband
    def set_sideband(self, sideband): self.sideband = sideband
    def get_bbid(self): return self.bbid
    def set_bbid(self, bbid): self.bbid = bbid
    def get_polarization(self): return self.polarization
    def set_polarization(self, polarization): self.polarization = polarization
    def get_phaseModelInsertion(self): return self.phaseModelInsertion
    def set_phaseModelInsertion(self, phaseModelInsertion): self.phaseModelInsertion = phaseModelInsertion
    def export(self, outfile, level, namespace_='widar:', name_='bbParams', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bbParams')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='bbParams'):
        if self.sourceType is not None and 'sourceType' not in already_processed:
            already_processed.append('sourceType')
            outfile.write(' sourceType=%s' % (quote_attrib(self.sourceType), ))
        if self.sourceId is not None and 'sourceId' not in already_processed:
            already_processed.append('sourceId')
            outfile.write(' sourceId=%s' % (quote_attrib(self.sourceId), ))
        if self.sideband is not None and 'sideband' not in already_processed:
            already_processed.append('sideband')
            outfile.write(' sideband=%s' % (quote_attrib(self.sideband), ))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            outfile.write(' bbid=%s' % (quote_attrib(self.bbid), ))
        if self.polarization is not None and 'polarization' not in already_processed:
            already_processed.append('polarization')
            outfile.write(' polarization=%s' % (quote_attrib(self.polarization), ))
        if self.phaseModelInsertion is not None and 'phaseModelInsertion' not in already_processed:
            already_processed.append('phaseModelInsertion')
            outfile.write(' phaseModelInsertion=%s' % (quote_attrib(self.phaseModelInsertion), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='bbParams', fromsubclass_=False):
        for sbParams_ in self.sbParams:
            sbParams_.export(outfile, level, namespace_, name_='sbParams')
    def hasContent_(self):
        if (
            self.sbParams
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bbParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceType is not None and 'sourceType' not in already_processed:
            already_processed.append('sourceType')
            showIndent(outfile, level)
            outfile.write('sourceType = %s,\n' % (self.sourceType,))
        if self.sourceId is not None and 'sourceId' not in already_processed:
            already_processed.append('sourceId')
            showIndent(outfile, level)
            outfile.write('sourceId = %s,\n' % (self.sourceId,))
        if self.sideband is not None and 'sideband' not in already_processed:
            already_processed.append('sideband')
            showIndent(outfile, level)
            outfile.write('sideband = %s,\n' % (self.sideband,))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            showIndent(outfile, level)
            outfile.write('bbid = %s,\n' % (self.bbid,))
        if self.polarization is not None and 'polarization' not in already_processed:
            already_processed.append('polarization')
            showIndent(outfile, level)
            outfile.write('polarization = %s,\n' % (self.polarization,))
        if self.phaseModelInsertion is not None and 'phaseModelInsertion' not in already_processed:
            already_processed.append('phaseModelInsertion')
            showIndent(outfile, level)
            outfile.write('phaseModelInsertion = %s,\n' % (self.phaseModelInsertion,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sbParams=[\n')
        level += 1
        for sbParams_ in self.sbParams:
            showIndent(outfile, level)
            outfile.write('model_.sbParams(\n')
            sbParams_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceType', node)
        if value is not None and 'sourceType' not in already_processed:
            already_processed.append('sourceType')
            self.sourceType = value
        value = find_attr_value_('sourceId', node)
        if value is not None and 'sourceId' not in already_processed:
            already_processed.append('sourceId')
            self.sourceId = value
        value = find_attr_value_('sideband', node)
        if value is not None and 'sideband' not in already_processed:
            already_processed.append('sideband')
            self.sideband = value
        value = find_attr_value_('bbid', node)
        if value is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            self.bbid = value
        value = find_attr_value_('polarization', node)
        if value is not None and 'polarization' not in already_processed:
            already_processed.append('polarization')
            self.polarization = value
        value = find_attr_value_('phaseModelInsertion', node)
        if value is not None and 'phaseModelInsertion' not in already_processed:
            already_processed.append('phaseModelInsertion')
            self.phaseModelInsertion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sbParams':
            obj_ = sbParams.factory()
            obj_.build(child_)
            self.sbParams.append(obj_)
# end class bbParams


class sbParams(GeneratedsSuper):
    """This element is a child of the element bbParams and will be
    specified for each Baseband individually (not for a Baseband
    pair). Tone extraction and radar mode will typically be set the
    same way for all the stations in a subarray, but can be
    specified for individual stations, if needed. Normally, Station
    Board filter will be selected by the correlator software. User
    may want to explicitely specify the Filter ID during the testing
    or to awoid use of the damaged hardware."""
    subclass = None
    superclass = None
    def __init__(self, sbid=None, filter=None, name=None, radarMode=None, toneExtraction=None):
        self.sbid = _cast(None, sbid)
        self.filter = _cast(None, filter)
        self.name = _cast(None, name)
        self.radarMode = radarMode
        self.toneExtraction = toneExtraction
    def factory(*args_, **kwargs_):
        if sbParams.subclass:
            return sbParams.subclass(*args_, **kwargs_)
        else:
            return sbParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radarMode(self): return self.radarMode
    def set_radarMode(self, radarMode): self.radarMode = radarMode
    def get_toneExtraction(self): return self.toneExtraction
    def set_toneExtraction(self, toneExtraction): self.toneExtraction = toneExtraction
    def get_sbid(self): return self.sbid
    def set_sbid(self, sbid): self.sbid = sbid
    def get_filter(self): return self.filter
    def set_filter(self, filter): self.filter = filter
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='sbParams', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sbParams')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='sbParams'):
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            outfile.write(' sbid=%s' % (quote_attrib(self.sbid), ))
        if self.filter is not None and 'filter' not in already_processed:
            already_processed.append('filter')
            outfile.write(' filter=%s' % (quote_attrib(self.filter), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='sbParams', fromsubclass_=False):
        if self.radarMode:
            self.radarMode.export(outfile, level, namespace_, name_='radarMode')
        if self.toneExtraction:
            self.toneExtraction.export(outfile, level, namespace_, name_='toneExtraction')
    def hasContent_(self):
        if (
            self.radarMode is not None or
            self.toneExtraction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sbParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            showIndent(outfile, level)
            outfile.write('sbid = %s,\n' % (self.sbid,))
        if self.filter is not None and 'filter' not in already_processed:
            already_processed.append('filter')
            showIndent(outfile, level)
            outfile.write('filter = %s,\n' % (self.filter,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.radarMode is not None:
            showIndent(outfile, level)
            outfile.write('radarMode=model_.radarMode(\n')
            self.radarMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.toneExtraction is not None:
            showIndent(outfile, level)
            outfile.write('toneExtraction=model_.toneExtraction(\n')
            self.toneExtraction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sbid', node)
        if value is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            self.sbid = value
        value = find_attr_value_('filter', node)
        if value is not None and 'filter' not in already_processed:
            already_processed.append('filter')
            self.filter = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'radarMode':
            obj_ = radarMode.factory()
            obj_.build(child_)
            self.set_radarMode(obj_)
        elif nodeName_ == 'toneExtraction':
            obj_ = toneExtraction.factory()
            obj_.build(child_)
            self.set_toneExtraction(obj_)
# end class sbParams


class stationInputOutput(GeneratedsSuper):
    """Specification of input and output data: baseband parameters, for
    each baseband (pair) the list of subbands, for each subband the
    list of desired products. VCI Client may specify
    stationInputOutput for each station individually, or use id=ALL
    to apply the same configuration to all the stations in the
    subarray. Element subarray may have one element
    stationInputOutput that defines configuration for all the
    stations, and one or more elements stationInputOutput that
    define configuration for stations that are not exactly the same
    as others. Station ID and Baseband IDs used here must be already
    defined using stationHw."""
    subclass = None
    superclass = None
    def __init__(self, name=None, sid='all', station=None, bbParams=None, baseBand=None, stbDataProducts=None, monitorData=None):
        self.name = _cast(None, name)
        self.sid = _cast(None, sid)
        if station is None:
            self.station = []
        else:
            self.station = station
        if bbParams is None:
            self.bbParams = []
        else:
            self.bbParams = bbParams
        if baseBand is None:
            self.baseBand = []
        else:
            self.baseBand = baseBand
        self.stbDataProducts = stbDataProducts
        self.monitorData = monitorData
    def factory(*args_, **kwargs_):
        if stationInputOutput.subclass:
            return stationInputOutput.subclass(*args_, **kwargs_)
        else:
            return stationInputOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def add_station(self, value): self.station.append(value)
    def insert_station(self, index, value): self.station[index] = value
    def get_bbParams(self): return self.bbParams
    def set_bbParams(self, bbParams): self.bbParams = bbParams
    def add_bbParams(self, value): self.bbParams.append(value)
    def insert_bbParams(self, index, value): self.bbParams[index] = value
    def get_baseBand(self): return self.baseBand
    def set_baseBand(self, baseBand): self.baseBand = baseBand
    def add_baseBand(self, value): self.baseBand.append(value)
    def insert_baseBand(self, index, value): self.baseBand[index] = value
    def get_stbDataProducts(self): return self.stbDataProducts
    def set_stbDataProducts(self, stbDataProducts): self.stbDataProducts = stbDataProducts
    def get_monitorData(self): return self.monitorData
    def set_monitorData(self, monitorData): self.monitorData = monitorData
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def export(self, outfile, level, namespace_='widar:', name_='stationInputOutput', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stationInputOutput')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stationInputOutput'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (self.gds_format_string(quote_attrib(self.sid).encode(ExternalEncoding), input_name='sid'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stationInputOutput', fromsubclass_=False):
        for station_ in self.station:
            station_.export(outfile, level, namespace_, name_='station')
        for bbParams_ in self.bbParams:
            bbParams_.export(outfile, level, namespace_, name_='bbParams')
        for baseBand_ in self.baseBand:
            baseBand_.export(outfile, level, namespace_, name_='baseBand')
        if self.stbDataProducts:
            self.stbDataProducts.export(outfile, level, namespace_, name_='stbDataProducts')
        if self.monitorData:
            self.monitorData.export(outfile, level, namespace_, name_='monitorData')
    def hasContent_(self):
        if (
            self.station or
            self.bbParams or
            self.baseBand or
            self.stbDataProducts is not None or
            self.monitorData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stationInputOutput'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = "%s",\n' % (self.sid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('station=[\n')
        level += 1
        for station_ in self.station:
            showIndent(outfile, level)
            outfile.write('model_.station(\n')
            station_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('bbParams=[\n')
        level += 1
        for bbParams_ in self.bbParams:
            showIndent(outfile, level)
            outfile.write('model_.bbParams(\n')
            bbParams_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('baseBand=[\n')
        level += 1
        for baseBand_ in self.baseBand:
            showIndent(outfile, level)
            outfile.write('model_.baseBand(\n')
            baseBand_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.stbDataProducts is not None:
            showIndent(outfile, level)
            outfile.write('stbDataProducts=model_.stbDataProducts(\n')
            self.stbDataProducts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.monitorData is not None:
            showIndent(outfile, level)
            outfile.write('monitorData=model_.monitorData(\n')
            self.monitorData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'station':
            obj_ = station.factory()
            obj_.build(child_)
            self.station.append(obj_)
        elif nodeName_ == 'bbParams':
            obj_ = bbParams.factory()
            obj_.build(child_)
            self.bbParams.append(obj_)
        elif nodeName_ == 'baseBand':
            obj_ = baseBand.factory()
            obj_.build(child_)
            self.baseBand.append(obj_)
        elif nodeName_ == 'stbDataProducts':
            obj_ = stbDataProducts.factory()
            obj_.build(child_)
            self.set_stbDataProducts(obj_)
        elif nodeName_ == 'monitorData':
            obj_ = monitorData.factory()
            obj_.build(child_)
            self.set_monitorData(obj_)
# end class stationInputOutput


class baseBand(GeneratedsSuper):
    """swbbName is BaseBand name for Spectral Window (BDF), swbbName is
    forwarded to CBE (BDF) and to Station Boards, so that it can be
    inserted into output related to switched power (power counts).
    swPwrEpoch - epoch for data related to switched power data
    generated by Station Board, if not specified as as DumpTrig
    epoch. swPwrInteg - integration time for switched power data
    generated by Station Board, if not specified, same as LTA dump
    time. Specified in milliseconds, value must be in hundreds of
    milliseconds. defaultFilterGain - If present, set default values
    for active filter stages Default values for filter gain are
    determined by CMIB software based on filter setup. "Target RMS",
    if specified, will override filter gains set as result of this
    attribute. In other words, either this attribute or "target RMS"
    should be specified. Howver, it is possible to set
    "defaultFilterGain" for all the stages and re-quantizer, and
    then adjust gain only for a subset of stages. requantRms -
    Target RMS for re-qunatizer. If specified, invoke filter gain
    adjustment to get output RMS as specified. stage1Rms - Target
    RMS for filter stage 1. If specified, invoke filter gain
    adjustment to get output RMS as specified by this attribute.
    stage2Rms - Target RMS for filter stage 2. If specified, invoke
    filter gain adjustment to get output RMS as specified by this
    attribute. stage3Rms - Target RMS for filter stage 3. If
    specified, invoke filter gain adjustment to get output RMS as
    specified by this attribute. stage4Rms - Target RMS for filter
    stage 4. If specified, invoke filter gain adjustment to get
    output RMS as specified by this attribute. Not sure if Station
    ID definition is needed at all: Station ID, if specified here
    overrides the Station ID specified in the parent element. This
    may be used in configurations other than EVLA and perhaps for
    testing."""
    subclass = None
    superclass = None
    def __init__(self, swPwrEpoch=None, delayModelsValid=1, name=None, swbbName=None, defaultFilterGain=None, stage2Rms=None, bbB=None, bbA=None, requantRms=None, bw=None, swPwrInteg=None, sid=None, singlePhaseCenter='yes', stage1Rms=None, stage3Rms=None, inQuant=None, stage4Rms=None, subBand=None, pulsarGating=None, wideBandCorrelator=None):
        self.swPwrEpoch = _cast(None, swPwrEpoch)
        self.delayModelsValid = _cast(int, delayModelsValid)
        self.name = _cast(None, name)
        self.swbbName = _cast(None, swbbName)
        self.defaultFilterGain = _cast(None, defaultFilterGain)
        self.stage2Rms = _cast(float, stage2Rms)
        self.bbB = _cast(None, bbB)
        self.bbA = _cast(None, bbA)
        self.requantRms = _cast(float, requantRms)
        self.bw = _cast(None, bw)
        self.swPwrInteg = _cast(int, swPwrInteg)
        self.sid = _cast(None, sid)
        self.singlePhaseCenter = _cast(None, singlePhaseCenter)
        self.stage1Rms = _cast(float, stage1Rms)
        self.stage3Rms = _cast(float, stage3Rms)
        self.inQuant = _cast(None, inQuant)
        self.stage4Rms = _cast(float, stage4Rms)
        if subBand is None:
            self.subBand = []
        else:
            self.subBand = subBand
        self.pulsarGating = pulsarGating
        self.wideBandCorrelator = wideBandCorrelator
    def factory(*args_, **kwargs_):
        if baseBand.subclass:
            return baseBand.subclass(*args_, **kwargs_)
        else:
            return baseBand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subBand(self): return self.subBand
    def set_subBand(self, subBand): self.subBand = subBand
    def add_subBand(self, value): self.subBand.append(value)
    def insert_subBand(self, index, value): self.subBand[index] = value
    def get_pulsarGating(self): return self.pulsarGating
    def set_pulsarGating(self, pulsarGating): self.pulsarGating = pulsarGating
    def get_wideBandCorrelator(self): return self.wideBandCorrelator
    def set_wideBandCorrelator(self, wideBandCorrelator): self.wideBandCorrelator = wideBandCorrelator
    def get_swPwrEpoch(self): return self.swPwrEpoch
    def set_swPwrEpoch(self, swPwrEpoch): self.swPwrEpoch = swPwrEpoch
    def get_delayModelsValid(self): return self.delayModelsValid
    def set_delayModelsValid(self, delayModelsValid): self.delayModelsValid = delayModelsValid
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_swbbName(self): return self.swbbName
    def set_swbbName(self, swbbName): self.swbbName = swbbName
    def get_defaultFilterGain(self): return self.defaultFilterGain
    def set_defaultFilterGain(self, defaultFilterGain): self.defaultFilterGain = defaultFilterGain
    def get_stage2Rms(self): return self.stage2Rms
    def set_stage2Rms(self, stage2Rms): self.stage2Rms = stage2Rms
    def get_bbB(self): return self.bbB
    def set_bbB(self, bbB): self.bbB = bbB
    def get_bbA(self): return self.bbA
    def set_bbA(self, bbA): self.bbA = bbA
    def get_requantRms(self): return self.requantRms
    def set_requantRms(self, requantRms): self.requantRms = requantRms
    def get_bw(self): return self.bw
    def set_bw(self, bw): self.bw = bw
    def get_swPwrInteg(self): return self.swPwrInteg
    def set_swPwrInteg(self, swPwrInteg): self.swPwrInteg = swPwrInteg
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_singlePhaseCenter(self): return self.singlePhaseCenter
    def set_singlePhaseCenter(self, singlePhaseCenter): self.singlePhaseCenter = singlePhaseCenter
    def get_stage1Rms(self): return self.stage1Rms
    def set_stage1Rms(self, stage1Rms): self.stage1Rms = stage1Rms
    def get_stage3Rms(self): return self.stage3Rms
    def set_stage3Rms(self, stage3Rms): self.stage3Rms = stage3Rms
    def get_inQuant(self): return self.inQuant
    def set_inQuant(self, inQuant): self.inQuant = inQuant
    def get_stage4Rms(self): return self.stage4Rms
    def set_stage4Rms(self, stage4Rms): self.stage4Rms = stage4Rms
    def export(self, outfile, level, namespace_='widar:', name_='baseBand', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseBand')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='baseBand'):
        if self.swPwrEpoch is not None and 'swPwrEpoch' not in already_processed:
            already_processed.append('swPwrEpoch')
            outfile.write(' swPwrEpoch=%s' % (self.gds_format_string(quote_attrib(self.swPwrEpoch).encode(ExternalEncoding), input_name='swPwrEpoch'), ))
        if self.delayModelsValid is not None and 'delayModelsValid' not in already_processed:
            already_processed.append('delayModelsValid')
            outfile.write(' delayModelsValid="%s"' % self.gds_format_integer(self.delayModelsValid, input_name='delayModelsValid'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.swbbName is not None and 'swbbName' not in already_processed:
            already_processed.append('swbbName')
            outfile.write(' swbbName=%s' % (quote_attrib(self.swbbName), ))
        if self.defaultFilterGain is not None and 'defaultFilterGain' not in already_processed:
            already_processed.append('defaultFilterGain')
            outfile.write(' defaultFilterGain=%s' % (self.gds_format_string(quote_attrib(self.defaultFilterGain).encode(ExternalEncoding), input_name='defaultFilterGain'), ))
        if self.stage2Rms is not None and 'stage2Rms' not in already_processed:
            already_processed.append('stage2Rms')
            outfile.write(' stage2Rms="%s"' % self.gds_format_double(self.stage2Rms, input_name='stage2Rms'))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            outfile.write(' bbB=%s' % (quote_attrib(self.bbB), ))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            outfile.write(' bbA=%s' % (quote_attrib(self.bbA), ))
        if self.requantRms is not None and 'requantRms' not in already_processed:
            already_processed.append('requantRms')
            outfile.write(' requantRms="%s"' % self.gds_format_double(self.requantRms, input_name='requantRms'))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            outfile.write(' bw=%s' % (quote_attrib(self.bw), ))
        if self.swPwrInteg is not None and 'swPwrInteg' not in already_processed:
            already_processed.append('swPwrInteg')
            outfile.write(' swPwrInteg="%s"' % self.gds_format_integer(self.swPwrInteg, input_name='swPwrInteg'))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
        if self.singlePhaseCenter is not None and 'singlePhaseCenter' not in already_processed:
            already_processed.append('singlePhaseCenter')
            outfile.write(' singlePhaseCenter=%s' % (quote_attrib(self.singlePhaseCenter), ))
        if self.stage1Rms is not None and 'stage1Rms' not in already_processed:
            already_processed.append('stage1Rms')
            outfile.write(' stage1Rms="%s"' % self.gds_format_double(self.stage1Rms, input_name='stage1Rms'))
        if self.stage3Rms is not None and 'stage3Rms' not in already_processed:
            already_processed.append('stage3Rms')
            outfile.write(' stage3Rms="%s"' % self.gds_format_double(self.stage3Rms, input_name='stage3Rms'))
        if self.inQuant is not None and 'inQuant' not in already_processed:
            already_processed.append('inQuant')
            outfile.write(' inQuant=%s' % (quote_attrib(self.inQuant), ))
        if self.stage4Rms is not None and 'stage4Rms' not in already_processed:
            already_processed.append('stage4Rms')
            outfile.write(' stage4Rms="%s"' % self.gds_format_double(self.stage4Rms, input_name='stage4Rms'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='baseBand', fromsubclass_=False):
        for subBand_ in self.subBand:
            subBand_.export(outfile, level, namespace_, name_='subBand')
        if self.pulsarGating:
            self.pulsarGating.export(outfile, level, namespace_, name_='pulsarGating')
        if self.wideBandCorrelator:
            self.wideBandCorrelator.export(outfile, level, namespace_, name_='wideBandCorrelator')
    def hasContent_(self):
        if (
            self.subBand or
            self.pulsarGating is not None or
            self.wideBandCorrelator is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='baseBand'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.swPwrEpoch is not None and 'swPwrEpoch' not in already_processed:
            already_processed.append('swPwrEpoch')
            showIndent(outfile, level)
            outfile.write('swPwrEpoch = "%s",\n' % (self.swPwrEpoch,))
        if self.delayModelsValid is not None and 'delayModelsValid' not in already_processed:
            already_processed.append('delayModelsValid')
            showIndent(outfile, level)
            outfile.write('delayModelsValid = %d,\n' % (self.delayModelsValid,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.swbbName is not None and 'swbbName' not in already_processed:
            already_processed.append('swbbName')
            showIndent(outfile, level)
            outfile.write('swbbName = %s,\n' % (self.swbbName,))
        if self.defaultFilterGain is not None and 'defaultFilterGain' not in already_processed:
            already_processed.append('defaultFilterGain')
            showIndent(outfile, level)
            outfile.write('defaultFilterGain = "%s",\n' % (self.defaultFilterGain,))
        if self.stage2Rms is not None and 'stage2Rms' not in already_processed:
            already_processed.append('stage2Rms')
            showIndent(outfile, level)
            outfile.write('stage2Rms = %e,\n' % (self.stage2Rms,))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            showIndent(outfile, level)
            outfile.write('bbB = %s,\n' % (self.bbB,))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            showIndent(outfile, level)
            outfile.write('bbA = %s,\n' % (self.bbA,))
        if self.requantRms is not None and 'requantRms' not in already_processed:
            already_processed.append('requantRms')
            showIndent(outfile, level)
            outfile.write('requantRms = %e,\n' % (self.requantRms,))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            showIndent(outfile, level)
            outfile.write('bw = %s,\n' % (self.bw,))
        if self.swPwrInteg is not None and 'swPwrInteg' not in already_processed:
            already_processed.append('swPwrInteg')
            showIndent(outfile, level)
            outfile.write('swPwrInteg = %d,\n' % (self.swPwrInteg,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
        if self.singlePhaseCenter is not None and 'singlePhaseCenter' not in already_processed:
            already_processed.append('singlePhaseCenter')
            showIndent(outfile, level)
            outfile.write('singlePhaseCenter = %s,\n' % (self.singlePhaseCenter,))
        if self.stage1Rms is not None and 'stage1Rms' not in already_processed:
            already_processed.append('stage1Rms')
            showIndent(outfile, level)
            outfile.write('stage1Rms = %e,\n' % (self.stage1Rms,))
        if self.stage3Rms is not None and 'stage3Rms' not in already_processed:
            already_processed.append('stage3Rms')
            showIndent(outfile, level)
            outfile.write('stage3Rms = %e,\n' % (self.stage3Rms,))
        if self.inQuant is not None and 'inQuant' not in already_processed:
            already_processed.append('inQuant')
            showIndent(outfile, level)
            outfile.write('inQuant = %s,\n' % (self.inQuant,))
        if self.stage4Rms is not None and 'stage4Rms' not in already_processed:
            already_processed.append('stage4Rms')
            showIndent(outfile, level)
            outfile.write('stage4Rms = %e,\n' % (self.stage4Rms,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subBand=[\n')
        level += 1
        for subBand_ in self.subBand:
            showIndent(outfile, level)
            outfile.write('model_.subBand(\n')
            subBand_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.pulsarGating is not None:
            showIndent(outfile, level)
            outfile.write('pulsarGating=model_.pulsarGating(\n')
            self.pulsarGating.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.wideBandCorrelator is not None:
            showIndent(outfile, level)
            outfile.write('wideBandCorrelator=model_.wideBandCorrelator(\n')
            self.wideBandCorrelator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('swPwrEpoch', node)
        if value is not None and 'swPwrEpoch' not in already_processed:
            already_processed.append('swPwrEpoch')
            self.swPwrEpoch = value
        value = find_attr_value_('delayModelsValid', node)
        if value is not None and 'delayModelsValid' not in already_processed:
            already_processed.append('delayModelsValid')
            try:
                self.delayModelsValid = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('swbbName', node)
        if value is not None and 'swbbName' not in already_processed:
            already_processed.append('swbbName')
            self.swbbName = value
        value = find_attr_value_('defaultFilterGain', node)
        if value is not None and 'defaultFilterGain' not in already_processed:
            already_processed.append('defaultFilterGain')
            self.defaultFilterGain = value
        value = find_attr_value_('stage2Rms', node)
        if value is not None and 'stage2Rms' not in already_processed:
            already_processed.append('stage2Rms')
            try:
                self.stage2Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage2Rms): %s' % exp)
        value = find_attr_value_('bbB', node)
        if value is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            self.bbB = value
        value = find_attr_value_('bbA', node)
        if value is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            self.bbA = value
        value = find_attr_value_('requantRms', node)
        if value is not None and 'requantRms' not in already_processed:
            already_processed.append('requantRms')
            try:
                self.requantRms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (requantRms): %s' % exp)
        value = find_attr_value_('bw', node)
        if value is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            self.bw = value
        value = find_attr_value_('swPwrInteg', node)
        if value is not None and 'swPwrInteg' not in already_processed:
            already_processed.append('swPwrInteg')
            try:
                self.swPwrInteg = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
        value = find_attr_value_('singlePhaseCenter', node)
        if value is not None and 'singlePhaseCenter' not in already_processed:
            already_processed.append('singlePhaseCenter')
            self.singlePhaseCenter = value
        value = find_attr_value_('stage1Rms', node)
        if value is not None and 'stage1Rms' not in already_processed:
            already_processed.append('stage1Rms')
            try:
                self.stage1Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage1Rms): %s' % exp)
        value = find_attr_value_('stage3Rms', node)
        if value is not None and 'stage3Rms' not in already_processed:
            already_processed.append('stage3Rms')
            try:
                self.stage3Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage3Rms): %s' % exp)
        value = find_attr_value_('inQuant', node)
        if value is not None and 'inQuant' not in already_processed:
            already_processed.append('inQuant')
            self.inQuant = value
        value = find_attr_value_('stage4Rms', node)
        if value is not None and 'stage4Rms' not in already_processed:
            already_processed.append('stage4Rms')
            try:
                self.stage4Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage4Rms): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subBand':
            obj_ = subBand.factory()
            obj_.build(child_)
            self.subBand.append(obj_)
        elif nodeName_ == 'pulsarGating':
            obj_ = pulsarGating.factory()
            obj_.build(child_)
            self.set_pulsarGating(obj_)
        elif nodeName_ == 'wideBandCorrelator':
            obj_ = wideBandCorrelator.factory()
            obj_.build(child_)
            self.set_wideBandCorrelator(obj_)
# end class baseBand


class subBand(GeneratedsSuper):
    """Subband configuration specifies filter configuration and output
    products. swIndex is index of the Spectral Window (BDF). WIDAR
    correlator does not use swIndex; swIndex is forwarded to CBE
    (BDF).."""
    subclass = None
    superclass = None
    def __init__(self, mixerPhaseErrorCorr='no', rqNumBits=None, name=None, sbid=None, pulsarGatingPhase=0, centralFreq=None, bw=None, useMixer='no', swIndex=None, signalToNoise='0', polProducts=None, autoCorrMode=None, pulsarBinning=None, burstMode=None, summedArray=None, modifySummedArray=None, radarMode=None, toneExtraction=None):
        self.mixerPhaseErrorCorr = _cast(None, mixerPhaseErrorCorr)
        self.rqNumBits = _cast(None, rqNumBits)
        self.name = _cast(None, name)
        self.sbid = _cast(None, sbid)
        self.pulsarGatingPhase = _cast(int, pulsarGatingPhase)
        self.centralFreq = _cast(int, centralFreq)
        self.bw = _cast(None, bw)
        self.useMixer = _cast(None, useMixer)
        self.swIndex = _cast(int, swIndex)
        self.signalToNoise = _cast(None, signalToNoise)
        self.polProducts = polProducts
        self.autoCorrMode = autoCorrMode
        self.pulsarBinning = pulsarBinning
        self.burstMode = burstMode
        if summedArray is None:
            self.summedArray = []
        else:
            self.summedArray = summedArray
        self.modifySummedArray = modifySummedArray
        self.radarMode = radarMode
        self.toneExtraction = toneExtraction
    def factory(*args_, **kwargs_):
        if subBand.subclass:
            return subBand.subclass(*args_, **kwargs_)
        else:
            return subBand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polProducts(self): return self.polProducts
    def set_polProducts(self, polProducts): self.polProducts = polProducts
    def get_autoCorrMode(self): return self.autoCorrMode
    def set_autoCorrMode(self, autoCorrMode): self.autoCorrMode = autoCorrMode
    def get_pulsarBinning(self): return self.pulsarBinning
    def set_pulsarBinning(self, pulsarBinning): self.pulsarBinning = pulsarBinning
    def get_burstMode(self): return self.burstMode
    def set_burstMode(self, burstMode): self.burstMode = burstMode
    def get_summedArray(self): return self.summedArray
    def set_summedArray(self, summedArray): self.summedArray = summedArray
    def add_summedArray(self, value): self.summedArray.append(value)
    def insert_summedArray(self, index, value): self.summedArray[index] = value
    def get_modifySummedArray(self): return self.modifySummedArray
    def set_modifySummedArray(self, modifySummedArray): self.modifySummedArray = modifySummedArray
    def get_radarMode(self): return self.radarMode
    def set_radarMode(self, radarMode): self.radarMode = radarMode
    def get_toneExtraction(self): return self.toneExtraction
    def set_toneExtraction(self, toneExtraction): self.toneExtraction = toneExtraction
    def get_mixerPhaseErrorCorr(self): return self.mixerPhaseErrorCorr
    def set_mixerPhaseErrorCorr(self, mixerPhaseErrorCorr): self.mixerPhaseErrorCorr = mixerPhaseErrorCorr
    def get_rqNumBits(self): return self.rqNumBits
    def set_rqNumBits(self, rqNumBits): self.rqNumBits = rqNumBits
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sbid(self): return self.sbid
    def set_sbid(self, sbid): self.sbid = sbid
    def get_pulsarGatingPhase(self): return self.pulsarGatingPhase
    def set_pulsarGatingPhase(self, pulsarGatingPhase): self.pulsarGatingPhase = pulsarGatingPhase
    def get_centralFreq(self): return self.centralFreq
    def set_centralFreq(self, centralFreq): self.centralFreq = centralFreq
    def get_bw(self): return self.bw
    def set_bw(self, bw): self.bw = bw
    def get_useMixer(self): return self.useMixer
    def set_useMixer(self, useMixer): self.useMixer = useMixer
    def get_swIndex(self): return self.swIndex
    def set_swIndex(self, swIndex): self.swIndex = swIndex
    def get_signalToNoise(self): return self.signalToNoise
    def set_signalToNoise(self, signalToNoise): self.signalToNoise = signalToNoise
    def export(self, outfile, level, namespace_='widar:', name_='subBand', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subBand')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='subBand'):
        if self.mixerPhaseErrorCorr is not None and 'mixerPhaseErrorCorr' not in already_processed:
            already_processed.append('mixerPhaseErrorCorr')
            outfile.write(' mixerPhaseErrorCorr=%s' % (quote_attrib(self.mixerPhaseErrorCorr), ))
        if self.rqNumBits is not None and 'rqNumBits' not in already_processed:
            already_processed.append('rqNumBits')
            outfile.write(' rqNumBits=%s' % (quote_attrib(self.rqNumBits), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            outfile.write(' sbid=%s' % (quote_attrib(self.sbid), ))
        if self.pulsarGatingPhase is not None and 'pulsarGatingPhase' not in already_processed:
            already_processed.append('pulsarGatingPhase')
            outfile.write(' pulsarGatingPhase="%s"' % self.gds_format_integer(self.pulsarGatingPhase, input_name='pulsarGatingPhase'))
        if self.centralFreq is not None and 'centralFreq' not in already_processed:
            already_processed.append('centralFreq')
            outfile.write(' centralFreq="%s"' % self.gds_format_integer(self.centralFreq, input_name='centralFreq'))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            outfile.write(' bw=%s' % (quote_attrib(self.bw), ))
        if self.useMixer is not None and 'useMixer' not in already_processed:
            already_processed.append('useMixer')
            outfile.write(' useMixer=%s' % (quote_attrib(self.useMixer), ))
        if self.swIndex is not None and 'swIndex' not in already_processed:
            already_processed.append('swIndex')
            outfile.write(' swIndex="%s"' % self.gds_format_integer(self.swIndex, input_name='swIndex'))
        if self.signalToNoise is not None and 'signalToNoise' not in already_processed:
            already_processed.append('signalToNoise')
            outfile.write(' signalToNoise=%s' % (quote_attrib(self.signalToNoise), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='subBand', fromsubclass_=False):
        if self.polProducts:
            self.polProducts.export(outfile, level, namespace_, name_='polProducts')
        if self.autoCorrMode:
            self.autoCorrMode.export(outfile, level, namespace_, name_='autoCorrMode')
        if self.pulsarBinning:
            self.pulsarBinning.export(outfile, level, namespace_, name_='pulsarBinning')
        if self.burstMode:
            self.burstMode.export(outfile, level, namespace_, name_='burstMode')
        for summedArray_ in self.summedArray:
            summedArray_.export(outfile, level, namespace_, name_='summedArray')
        if self.modifySummedArray:
            self.modifySummedArray.export(outfile, level, namespace_, name_='modifySummedArray')
        if self.radarMode:
            self.radarMode.export(outfile, level, namespace_, name_='radarMode')
        if self.toneExtraction:
            self.toneExtraction.export(outfile, level, namespace_, name_='toneExtraction')
    def hasContent_(self):
        if (
            self.polProducts is not None or
            self.autoCorrMode is not None or
            self.pulsarBinning is not None or
            self.burstMode is not None or
            self.summedArray or
            self.modifySummedArray is not None or
            self.radarMode is not None or
            self.toneExtraction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subBand'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mixerPhaseErrorCorr is not None and 'mixerPhaseErrorCorr' not in already_processed:
            already_processed.append('mixerPhaseErrorCorr')
            showIndent(outfile, level)
            outfile.write('mixerPhaseErrorCorr = %s,\n' % (self.mixerPhaseErrorCorr,))
        if self.rqNumBits is not None and 'rqNumBits' not in already_processed:
            already_processed.append('rqNumBits')
            showIndent(outfile, level)
            outfile.write('rqNumBits = %s,\n' % (self.rqNumBits,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            showIndent(outfile, level)
            outfile.write('sbid = %s,\n' % (self.sbid,))
        if self.pulsarGatingPhase is not None and 'pulsarGatingPhase' not in already_processed:
            already_processed.append('pulsarGatingPhase')
            showIndent(outfile, level)
            outfile.write('pulsarGatingPhase = %d,\n' % (self.pulsarGatingPhase,))
        if self.centralFreq is not None and 'centralFreq' not in already_processed:
            already_processed.append('centralFreq')
            showIndent(outfile, level)
            outfile.write('centralFreq = %d,\n' % (self.centralFreq,))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            showIndent(outfile, level)
            outfile.write('bw = %s,\n' % (self.bw,))
        if self.useMixer is not None and 'useMixer' not in already_processed:
            already_processed.append('useMixer')
            showIndent(outfile, level)
            outfile.write('useMixer = %s,\n' % (self.useMixer,))
        if self.swIndex is not None and 'swIndex' not in already_processed:
            already_processed.append('swIndex')
            showIndent(outfile, level)
            outfile.write('swIndex = %d,\n' % (self.swIndex,))
        if self.signalToNoise is not None and 'signalToNoise' not in already_processed:
            already_processed.append('signalToNoise')
            showIndent(outfile, level)
            outfile.write('signalToNoise = %s,\n' % (self.signalToNoise,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.polProducts is not None:
            showIndent(outfile, level)
            outfile.write('polProducts=model_.polProducts(\n')
            self.polProducts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoCorrMode is not None:
            showIndent(outfile, level)
            outfile.write('autoCorrMode=model_.autoCorrMode(\n')
            self.autoCorrMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pulsarBinning is not None:
            showIndent(outfile, level)
            outfile.write('pulsarBinning=model_.pulsarBinning(\n')
            self.pulsarBinning.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.burstMode is not None:
            showIndent(outfile, level)
            outfile.write('burstMode=model_.burstMode(\n')
            self.burstMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('summedArray=[\n')
        level += 1
        for summedArray_ in self.summedArray:
            showIndent(outfile, level)
            outfile.write('model_.summedArray(\n')
            summedArray_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.modifySummedArray is not None:
            showIndent(outfile, level)
            outfile.write('modifySummedArray=model_.modifySummedArray(\n')
            self.modifySummedArray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.radarMode is not None:
            showIndent(outfile, level)
            outfile.write('radarMode=model_.radarMode(\n')
            self.radarMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.toneExtraction is not None:
            showIndent(outfile, level)
            outfile.write('toneExtraction=model_.toneExtraction(\n')
            self.toneExtraction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mixerPhaseErrorCorr', node)
        if value is not None and 'mixerPhaseErrorCorr' not in already_processed:
            already_processed.append('mixerPhaseErrorCorr')
            self.mixerPhaseErrorCorr = value
        value = find_attr_value_('rqNumBits', node)
        if value is not None and 'rqNumBits' not in already_processed:
            already_processed.append('rqNumBits')
            self.rqNumBits = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('sbid', node)
        if value is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            self.sbid = value
        value = find_attr_value_('pulsarGatingPhase', node)
        if value is not None and 'pulsarGatingPhase' not in already_processed:
            already_processed.append('pulsarGatingPhase')
            try:
                self.pulsarGatingPhase = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('centralFreq', node)
        if value is not None and 'centralFreq' not in already_processed:
            already_processed.append('centralFreq')
            try:
                self.centralFreq = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('bw', node)
        if value is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            self.bw = value
        value = find_attr_value_('useMixer', node)
        if value is not None and 'useMixer' not in already_processed:
            already_processed.append('useMixer')
            self.useMixer = value
        value = find_attr_value_('swIndex', node)
        if value is not None and 'swIndex' not in already_processed:
            already_processed.append('swIndex')
            try:
                self.swIndex = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('signalToNoise', node)
        if value is not None and 'signalToNoise' not in already_processed:
            already_processed.append('signalToNoise')
            self.signalToNoise = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polProducts':
            obj_ = polProducts.factory()
            obj_.build(child_)
            self.set_polProducts(obj_)
        elif nodeName_ == 'autoCorrMode':
            obj_ = autoCorrMode.factory()
            obj_.build(child_)
            self.set_autoCorrMode(obj_)
        elif nodeName_ == 'pulsarBinning':
            obj_ = pulsarBinning.factory()
            obj_.build(child_)
            self.set_pulsarBinning(obj_)
        elif nodeName_ == 'burstMode':
            obj_ = burstMode.factory()
            obj_.build(child_)
            self.set_burstMode(obj_)
        elif nodeName_ == 'summedArray':
            obj_ = summedArray.factory()
            obj_.build(child_)
            self.summedArray.append(obj_)
        elif nodeName_ == 'modifySummedArray':
            obj_ = modifySummedArray.factory()
            obj_.build(child_)
            self.set_modifySummedArray(obj_)
        elif nodeName_ == 'radarMode':
            obj_ = radarMode.factory()
            obj_.build(child_)
            self.set_radarMode(obj_)
        elif nodeName_ == 'toneExtraction':
            obj_ = toneExtraction.factory()
            obj_.build(child_)
            self.set_toneExtraction(obj_)
# end class subBand


class polProducts(GeneratedsSuper):
    """Polarization products that use the same integration factors
    (DUMPTRIG) and share same boards. For now, user can specify only
    one instance of this element, which means that user can not
    specify two groups of polarization products, where each group
    uses different DUMPTRIG."""
    subclass = None
    superclass = None
    def __init__(self, autoCorrMode='off', pp=None, blbProdIntegration=None, blbPair=None, blbSingle=None, stationPacking=None, productPacking=None, autoCorrSubset=None):
        self.autoCorrMode = _cast(None, autoCorrMode)
        if pp is None:
            self.pp = []
        else:
            self.pp = pp
        self.blbProdIntegration = blbProdIntegration
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        if blbSingle is None:
            self.blbSingle = []
        else:
            self.blbSingle = blbSingle
        self.stationPacking = stationPacking
        self.productPacking = productPacking
        self.autoCorrSubset = autoCorrSubset
    def factory(*args_, **kwargs_):
        if polProducts.subclass:
            return polProducts.subclass(*args_, **kwargs_)
        else:
            return polProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pp(self): return self.pp
    def set_pp(self, pp): self.pp = pp
    def add_pp(self, value): self.pp.append(value)
    def insert_pp(self, index, value): self.pp[index] = value
    def get_blbProdIntegration(self): return self.blbProdIntegration
    def set_blbProdIntegration(self, blbProdIntegration): self.blbProdIntegration = blbProdIntegration
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbSingle(self): return self.blbSingle
    def set_blbSingle(self, blbSingle): self.blbSingle = blbSingle
    def add_blbSingle(self, value): self.blbSingle.append(value)
    def insert_blbSingle(self, index, value): self.blbSingle[index] = value
    def get_stationPacking(self): return self.stationPacking
    def set_stationPacking(self, stationPacking): self.stationPacking = stationPacking
    def get_productPacking(self): return self.productPacking
    def set_productPacking(self, productPacking): self.productPacking = productPacking
    def get_autoCorrSubset(self): return self.autoCorrSubset
    def set_autoCorrSubset(self, autoCorrSubset): self.autoCorrSubset = autoCorrSubset
    def get_autoCorrMode(self): return self.autoCorrMode
    def set_autoCorrMode(self, autoCorrMode): self.autoCorrMode = autoCorrMode
    def export(self, outfile, level, namespace_='widar:', name_='polProducts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polProducts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='polProducts'):
        if self.autoCorrMode is not None and 'autoCorrMode' not in already_processed:
            already_processed.append('autoCorrMode')
            outfile.write(' autoCorrMode=%s' % (quote_attrib(self.autoCorrMode), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='polProducts', fromsubclass_=False):
        for pp_ in self.pp:
            pp_.export(outfile, level, namespace_, name_='pp')
        if self.blbProdIntegration:
            self.blbProdIntegration.export(outfile, level, namespace_, name_='blbProdIntegration')
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        for blbSingle_ in self.blbSingle:
            blbSingle_.export(outfile, level, namespace_, name_='blbSingle')
        if self.stationPacking:
            self.stationPacking.export(outfile, level, namespace_, name_='stationPacking')
        if self.productPacking:
            self.productPacking.export(outfile, level, namespace_, name_='productPacking')
        if self.autoCorrSubset:
            self.autoCorrSubset.export(outfile, level, namespace_, name_='autoCorrSubset')
    def hasContent_(self):
        if (
            self.pp or
            self.blbProdIntegration is not None or
            self.blbPair or
            self.blbSingle or
            self.stationPacking is not None or
            self.productPacking is not None or
            self.autoCorrSubset is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polProducts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.autoCorrMode is not None and 'autoCorrMode' not in already_processed:
            already_processed.append('autoCorrMode')
            showIndent(outfile, level)
            outfile.write('autoCorrMode = %s,\n' % (self.autoCorrMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pp=[\n')
        level += 1
        for pp_ in self.pp:
            showIndent(outfile, level)
            outfile.write('model_.pp(\n')
            pp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.blbProdIntegration is not None:
            showIndent(outfile, level)
            outfile.write('blbProdIntegration=model_.blbProdIntegration(\n')
            self.blbProdIntegration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbSingle=[\n')
        level += 1
        for blbSingle_ in self.blbSingle:
            showIndent(outfile, level)
            outfile.write('model_.blbSingle(\n')
            blbSingle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.stationPacking is not None:
            showIndent(outfile, level)
            outfile.write('stationPacking=model_.stationPacking(\n')
            self.stationPacking.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.productPacking is not None:
            showIndent(outfile, level)
            outfile.write('productPacking=model_.productPacking(\n')
            self.productPacking.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoCorrSubset is not None:
            showIndent(outfile, level)
            outfile.write('autoCorrSubset=model_.autoCorrSubset(\n')
            self.autoCorrSubset.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('autoCorrMode', node)
        if value is not None and 'autoCorrMode' not in already_processed:
            already_processed.append('autoCorrMode')
            self.autoCorrMode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pp':
            obj_ = pp.factory()
            obj_.build(child_)
            self.pp.append(obj_)
        elif nodeName_ == 'blbProdIntegration':
            obj_ = blbProdIntegration.factory()
            obj_.build(child_)
            self.set_blbProdIntegration(obj_)
        elif nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbSingle':
            obj_ = blbSingle.factory()
            obj_.build(child_)
            self.blbSingle.append(obj_)
        elif nodeName_ == 'stationPacking':
            obj_ = stationPacking.factory()
            obj_.build(child_)
            self.set_stationPacking(obj_)
        elif nodeName_ == 'productPacking':
            obj_ = productPacking.factory()
            obj_.build(child_)
            self.set_productPacking(obj_)
        elif nodeName_ == 'autoCorrSubset':
            obj_ = autoCorrSubset.factory()
            obj_.build(child_)
            self.set_autoCorrSubset(obj_)
# end class polProducts


class pp(GeneratedsSuper):
    """Polarization product."""
    subclass = None
    superclass = None
    def __init__(self, spectralChannels=None, id=None, correlation=None):
        self.spectralChannels = _cast(None, spectralChannels)
        self.id = _cast(None, id)
        self.correlation = _cast(None, correlation)
        pass
    def factory(*args_, **kwargs_):
        if pp.subclass:
            return pp.subclass(*args_, **kwargs_)
        else:
            return pp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectralChannels(self): return self.spectralChannels
    def set_spectralChannels(self, spectralChannels): self.spectralChannels = spectralChannels
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_correlation(self): return self.correlation
    def set_correlation(self, correlation): self.correlation = correlation
    def export(self, outfile, level, namespace_='widar:', name_='pp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pp')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='pp'):
        if self.spectralChannels is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            outfile.write(' spectralChannels=%s' % (quote_attrib(self.spectralChannels), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.correlation is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            outfile.write(' correlation=%s' % (quote_attrib(self.correlation), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='pp', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectralChannels is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            showIndent(outfile, level)
            outfile.write('spectralChannels = %s,\n' % (self.spectralChannels,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.correlation is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            showIndent(outfile, level)
            outfile.write('correlation = %s,\n' % (self.correlation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectralChannels', node)
        if value is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            self.spectralChannels = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('correlation', node)
        if value is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            self.correlation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pp


class blbProdIntegration(GeneratedsSuper):
    """Integration Time defined as: Minimum Hardware Integration Time
    (MHIT) in microseconds. H/W integration factor (h/w integration
    time specified as multiple of the minimum h/w integration time).
    LTA integration factor (LTA integration time specified as
    multiple of the h/w integration time). CBE integration factor
    (CBE integration time specified as multiple of the LTA
    integration time)."""
    subclass = None
    superclass = None
    def __init__(self, minIntegTime=None, ccIntegFactor=1, ltaIntegFactor=1, cbeIntegFactor=1, recirculation=None):
        self.minIntegTime = _cast(None, minIntegTime)
        self.ccIntegFactor = _cast(int, ccIntegFactor)
        self.ltaIntegFactor = _cast(int, ltaIntegFactor)
        self.cbeIntegFactor = _cast(int, cbeIntegFactor)
        self.recirculation = _cast(None, recirculation)
        pass
    def factory(*args_, **kwargs_):
        if blbProdIntegration.subclass:
            return blbProdIntegration.subclass(*args_, **kwargs_)
        else:
            return blbProdIntegration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minIntegTime(self): return self.minIntegTime
    def set_minIntegTime(self, minIntegTime): self.minIntegTime = minIntegTime
    def get_ccIntegFactor(self): return self.ccIntegFactor
    def set_ccIntegFactor(self, ccIntegFactor): self.ccIntegFactor = ccIntegFactor
    def get_ltaIntegFactor(self): return self.ltaIntegFactor
    def set_ltaIntegFactor(self, ltaIntegFactor): self.ltaIntegFactor = ltaIntegFactor
    def get_cbeIntegFactor(self): return self.cbeIntegFactor
    def set_cbeIntegFactor(self, cbeIntegFactor): self.cbeIntegFactor = cbeIntegFactor
    def get_recirculation(self): return self.recirculation
    def set_recirculation(self, recirculation): self.recirculation = recirculation
    def export(self, outfile, level, namespace_='widar:', name_='blbProdIntegration', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='blbProdIntegration')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='blbProdIntegration'):
        if self.minIntegTime is not None and 'minIntegTime' not in already_processed:
            already_processed.append('minIntegTime')
            outfile.write(' minIntegTime=%s' % (quote_attrib(self.minIntegTime), ))
        if self.ccIntegFactor is not None and 'ccIntegFactor' not in already_processed:
            already_processed.append('ccIntegFactor')
            outfile.write(' ccIntegFactor="%s"' % self.gds_format_integer(self.ccIntegFactor, input_name='ccIntegFactor'))
        if self.ltaIntegFactor is not None and 'ltaIntegFactor' not in already_processed:
            already_processed.append('ltaIntegFactor')
            outfile.write(' ltaIntegFactor="%s"' % self.gds_format_integer(self.ltaIntegFactor, input_name='ltaIntegFactor'))
        if self.cbeIntegFactor is not None and 'cbeIntegFactor' not in already_processed:
            already_processed.append('cbeIntegFactor')
            outfile.write(' cbeIntegFactor="%s"' % self.gds_format_integer(self.cbeIntegFactor, input_name='cbeIntegFactor'))
        if self.recirculation is not None and 'recirculation' not in already_processed:
            already_processed.append('recirculation')
            outfile.write(' recirculation=%s' % (quote_attrib(self.recirculation), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='blbProdIntegration', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='blbProdIntegration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.minIntegTime is not None and 'minIntegTime' not in already_processed:
            already_processed.append('minIntegTime')
            showIndent(outfile, level)
            outfile.write('minIntegTime = %s,\n' % (self.minIntegTime,))
        if self.ccIntegFactor is not None and 'ccIntegFactor' not in already_processed:
            already_processed.append('ccIntegFactor')
            showIndent(outfile, level)
            outfile.write('ccIntegFactor = %d,\n' % (self.ccIntegFactor,))
        if self.ltaIntegFactor is not None and 'ltaIntegFactor' not in already_processed:
            already_processed.append('ltaIntegFactor')
            showIndent(outfile, level)
            outfile.write('ltaIntegFactor = %d,\n' % (self.ltaIntegFactor,))
        if self.cbeIntegFactor is not None and 'cbeIntegFactor' not in already_processed:
            already_processed.append('cbeIntegFactor')
            showIndent(outfile, level)
            outfile.write('cbeIntegFactor = %d,\n' % (self.cbeIntegFactor,))
        if self.recirculation is not None and 'recirculation' not in already_processed:
            already_processed.append('recirculation')
            showIndent(outfile, level)
            outfile.write('recirculation = %s,\n' % (self.recirculation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minIntegTime', node)
        if value is not None and 'minIntegTime' not in already_processed:
            already_processed.append('minIntegTime')
            self.minIntegTime = value
        value = find_attr_value_('ccIntegFactor', node)
        if value is not None and 'ccIntegFactor' not in already_processed:
            already_processed.append('ccIntegFactor')
            try:
                self.ccIntegFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ltaIntegFactor', node)
        if value is not None and 'ltaIntegFactor' not in already_processed:
            already_processed.append('ltaIntegFactor')
            try:
                self.ltaIntegFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cbeIntegFactor', node)
        if value is not None and 'cbeIntegFactor' not in already_processed:
            already_processed.append('cbeIntegFactor')
            try:
                self.cbeIntegFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('recirculation', node)
        if value is not None and 'recirculation' not in already_processed:
            already_processed.append('recirculation')
            self.recirculation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class blbProdIntegration


class blbPair(GeneratedsSuper):
    """Lists Baseline Board Pairs to be used for a particular subband"""
    subclass = None
    superclass = None
    def __init__(self, quadrant=None, numBlbPairs=None, firstBlbPair=None):
        self.quadrant = _cast(None, quadrant)
        self.numBlbPairs = _cast(None, numBlbPairs)
        self.firstBlbPair = _cast(None, firstBlbPair)
        pass
    def factory(*args_, **kwargs_):
        if blbPair.subclass:
            return blbPair.subclass(*args_, **kwargs_)
        else:
            return blbPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quadrant(self): return self.quadrant
    def set_quadrant(self, quadrant): self.quadrant = quadrant
    def get_numBlbPairs(self): return self.numBlbPairs
    def set_numBlbPairs(self, numBlbPairs): self.numBlbPairs = numBlbPairs
    def get_firstBlbPair(self): return self.firstBlbPair
    def set_firstBlbPair(self, firstBlbPair): self.firstBlbPair = firstBlbPair
    def export(self, outfile, level, namespace_='widar:', name_='blbPair', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='blbPair')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='blbPair'):
        if self.quadrant is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            outfile.write(' quadrant=%s' % (quote_attrib(self.quadrant), ))
        if self.numBlbPairs is not None and 'numBlbPairs' not in already_processed:
            already_processed.append('numBlbPairs')
            outfile.write(' numBlbPairs=%s' % (quote_attrib(self.numBlbPairs), ))
        if self.firstBlbPair is not None and 'firstBlbPair' not in already_processed:
            already_processed.append('firstBlbPair')
            outfile.write(' firstBlbPair=%s' % (quote_attrib(self.firstBlbPair), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='blbPair', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='blbPair'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quadrant is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            showIndent(outfile, level)
            outfile.write('quadrant = %s,\n' % (self.quadrant,))
        if self.numBlbPairs is not None and 'numBlbPairs' not in already_processed:
            already_processed.append('numBlbPairs')
            showIndent(outfile, level)
            outfile.write('numBlbPairs = %s,\n' % (self.numBlbPairs,))
        if self.firstBlbPair is not None and 'firstBlbPair' not in already_processed:
            already_processed.append('firstBlbPair')
            showIndent(outfile, level)
            outfile.write('firstBlbPair = %s,\n' % (self.firstBlbPair,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quadrant', node)
        if value is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            self.quadrant = value
        value = find_attr_value_('numBlbPairs', node)
        if value is not None and 'numBlbPairs' not in already_processed:
            already_processed.append('numBlbPairs')
            self.numBlbPairs = value
        value = find_attr_value_('firstBlbPair', node)
        if value is not None and 'firstBlbPair' not in already_processed:
            already_processed.append('firstBlbPair')
            self.firstBlbPair = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class blbPair


class blbSingle(GeneratedsSuper):
    """This element is used when a single Baseline Board is used to obtain
    specifieed product(s). In this context the Baseline Board is not
    identified by its MLID (rack-crate-slot), instead it is
    identified as a member of a Baseline Board pair."""
    subclass = None
    superclass = None
    def __init__(self, quadrant=None, blbIndex=None, blbPair=None):
        self.quadrant = _cast(None, quadrant)
        self.blbIndex = _cast(None, blbIndex)
        self.blbPair = _cast(None, blbPair)
        pass
    def factory(*args_, **kwargs_):
        if blbSingle.subclass:
            return blbSingle.subclass(*args_, **kwargs_)
        else:
            return blbSingle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quadrant(self): return self.quadrant
    def set_quadrant(self, quadrant): self.quadrant = quadrant
    def get_blbIndex(self): return self.blbIndex
    def set_blbIndex(self, blbIndex): self.blbIndex = blbIndex
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def export(self, outfile, level, namespace_='widar:', name_='blbSingle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='blbSingle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='blbSingle'):
        if self.quadrant is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            outfile.write(' quadrant=%s' % (quote_attrib(self.quadrant), ))
        if self.blbIndex is not None and 'blbIndex' not in already_processed:
            already_processed.append('blbIndex')
            outfile.write(' blbIndex=%s' % (quote_attrib(self.blbIndex), ))
        if self.blbPair is not None and 'blbPair' not in already_processed:
            already_processed.append('blbPair')
            outfile.write(' blbPair=%s' % (quote_attrib(self.blbPair), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='blbSingle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='blbSingle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quadrant is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            showIndent(outfile, level)
            outfile.write('quadrant = %s,\n' % (self.quadrant,))
        if self.blbIndex is not None and 'blbIndex' not in already_processed:
            already_processed.append('blbIndex')
            showIndent(outfile, level)
            outfile.write('blbIndex = %s,\n' % (self.blbIndex,))
        if self.blbPair is not None and 'blbPair' not in already_processed:
            already_processed.append('blbPair')
            showIndent(outfile, level)
            outfile.write('blbPair = %s,\n' % (self.blbPair,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quadrant', node)
        if value is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            self.quadrant = value
        value = find_attr_value_('blbIndex', node)
        if value is not None and 'blbIndex' not in already_processed:
            already_processed.append('blbIndex')
            self.blbIndex = value
        value = find_attr_value_('blbPair', node)
        if value is not None and 'blbPair' not in already_processed:
            already_processed.append('blbPair')
            self.blbPair = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class blbSingle


class summedArray(GeneratedsSuper):
    """The sum of the subarray. Baseline Boards: If specified in
    summedArray choice applies both for cc and vdif. If not
    specified at all, CM will use the Baseline Boards assifned to
    polProducts."""
    subclass = None
    superclass = None
    def __init__(self, integTime=10, autoIntegration=True, continuousInteg=True, headroom6dB=False, zeroFillInvalidData=True, applyIntegInHw=True, sid=None, excludeStations=None, blbPair=None, blbSingle=None, cc=None, vdif=None):
        self.integTime = _cast(int, integTime)
        self.autoIntegration = _cast(bool, autoIntegration)
        self.continuousInteg = _cast(bool, continuousInteg)
        self.headroom6dB = _cast(bool, headroom6dB)
        self.zeroFillInvalidData = _cast(bool, zeroFillInvalidData)
        self.applyIntegInHw = _cast(bool, applyIntegInHw)
        self.sid = _cast(None, sid)
        self.excludeStations = _cast(None, excludeStations)
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        if blbSingle is None:
            self.blbSingle = []
        else:
            self.blbSingle = blbSingle
        self.cc = cc
        self.vdif = vdif
    def factory(*args_, **kwargs_):
        if summedArray.subclass:
            return summedArray.subclass(*args_, **kwargs_)
        else:
            return summedArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbSingle(self): return self.blbSingle
    def set_blbSingle(self, blbSingle): self.blbSingle = blbSingle
    def add_blbSingle(self, value): self.blbSingle.append(value)
    def insert_blbSingle(self, index, value): self.blbSingle[index] = value
    def get_cc(self): return self.cc
    def set_cc(self, cc): self.cc = cc
    def get_vdif(self): return self.vdif
    def set_vdif(self, vdif): self.vdif = vdif
    def get_integTime(self): return self.integTime
    def set_integTime(self, integTime): self.integTime = integTime
    def get_autoIntegration(self): return self.autoIntegration
    def set_autoIntegration(self, autoIntegration): self.autoIntegration = autoIntegration
    def get_continuousInteg(self): return self.continuousInteg
    def set_continuousInteg(self, continuousInteg): self.continuousInteg = continuousInteg
    def get_headroom6dB(self): return self.headroom6dB
    def set_headroom6dB(self, headroom6dB): self.headroom6dB = headroom6dB
    def get_zeroFillInvalidData(self): return self.zeroFillInvalidData
    def set_zeroFillInvalidData(self, zeroFillInvalidData): self.zeroFillInvalidData = zeroFillInvalidData
    def get_applyIntegInHw(self): return self.applyIntegInHw
    def set_applyIntegInHw(self, applyIntegInHw): self.applyIntegInHw = applyIntegInHw
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_excludeStations(self): return self.excludeStations
    def set_excludeStations(self, excludeStations): self.excludeStations = excludeStations
    def export(self, outfile, level, namespace_='widar:', name_='summedArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='summedArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='summedArray'):
        if self.integTime is not None and 'integTime' not in already_processed:
            already_processed.append('integTime')
            outfile.write(' integTime="%s"' % self.gds_format_integer(self.integTime, input_name='integTime'))
        if self.autoIntegration is not None and 'autoIntegration' not in already_processed:
            already_processed.append('autoIntegration')
            outfile.write(' autoIntegration="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.autoIntegration)), input_name='autoIntegration'))
        if self.continuousInteg is not None and 'continuousInteg' not in already_processed:
            already_processed.append('continuousInteg')
            outfile.write(' continuousInteg="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.continuousInteg)), input_name='continuousInteg'))
        if self.headroom6dB is not None and 'headroom6dB' not in already_processed:
            already_processed.append('headroom6dB')
            outfile.write(' headroom6dB="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.headroom6dB)), input_name='headroom6dB'))
        if self.zeroFillInvalidData is not None and 'zeroFillInvalidData' not in already_processed:
            already_processed.append('zeroFillInvalidData')
            outfile.write(' zeroFillInvalidData="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.zeroFillInvalidData)), input_name='zeroFillInvalidData'))
        if self.applyIntegInHw is not None and 'applyIntegInHw' not in already_processed:
            already_processed.append('applyIntegInHw')
            outfile.write(' applyIntegInHw="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.applyIntegInHw)), input_name='applyIntegInHw'))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            outfile.write(' excludeStations=%s' % (quote_attrib(self.excludeStations), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='summedArray', fromsubclass_=False):
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        for blbSingle_ in self.blbSingle:
            blbSingle_.export(outfile, level, namespace_, name_='blbSingle')
        if self.cc:
            self.cc.export(outfile, level, namespace_, name_='cc')
        if self.vdif:
            self.vdif.export(outfile, level, namespace_, name_='vdif')
    def hasContent_(self):
        if (
            self.blbPair or
            self.blbSingle or
            self.cc is not None or
            self.vdif is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='summedArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.integTime is not None and 'integTime' not in already_processed:
            already_processed.append('integTime')
            showIndent(outfile, level)
            outfile.write('integTime = %d,\n' % (self.integTime,))
        if self.autoIntegration is not None and 'autoIntegration' not in already_processed:
            already_processed.append('autoIntegration')
            showIndent(outfile, level)
            outfile.write('autoIntegration = %s,\n' % (self.autoIntegration,))
        if self.continuousInteg is not None and 'continuousInteg' not in already_processed:
            already_processed.append('continuousInteg')
            showIndent(outfile, level)
            outfile.write('continuousInteg = %s,\n' % (self.continuousInteg,))
        if self.headroom6dB is not None and 'headroom6dB' not in already_processed:
            already_processed.append('headroom6dB')
            showIndent(outfile, level)
            outfile.write('headroom6dB = %s,\n' % (self.headroom6dB,))
        if self.zeroFillInvalidData is not None and 'zeroFillInvalidData' not in already_processed:
            already_processed.append('zeroFillInvalidData')
            showIndent(outfile, level)
            outfile.write('zeroFillInvalidData = %s,\n' % (self.zeroFillInvalidData,))
        if self.applyIntegInHw is not None and 'applyIntegInHw' not in already_processed:
            already_processed.append('applyIntegInHw')
            showIndent(outfile, level)
            outfile.write('applyIntegInHw = %s,\n' % (self.applyIntegInHw,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            showIndent(outfile, level)
            outfile.write('excludeStations = %s,\n' % (self.excludeStations,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbSingle=[\n')
        level += 1
        for blbSingle_ in self.blbSingle:
            showIndent(outfile, level)
            outfile.write('model_.blbSingle(\n')
            blbSingle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cc is not None:
            showIndent(outfile, level)
            outfile.write('cc=model_.cc(\n')
            self.cc.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vdif is not None:
            showIndent(outfile, level)
            outfile.write('vdif=model_.vdif(\n')
            self.vdif.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('integTime', node)
        if value is not None and 'integTime' not in already_processed:
            already_processed.append('integTime')
            try:
                self.integTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('autoIntegration', node)
        if value is not None and 'autoIntegration' not in already_processed:
            already_processed.append('autoIntegration')
            if value in ('true', '1'):
                self.autoIntegration = True
            elif value in ('false', '0'):
                self.autoIntegration = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('continuousInteg', node)
        if value is not None and 'continuousInteg' not in already_processed:
            already_processed.append('continuousInteg')
            if value in ('true', '1'):
                self.continuousInteg = True
            elif value in ('false', '0'):
                self.continuousInteg = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('headroom6dB', node)
        if value is not None and 'headroom6dB' not in already_processed:
            already_processed.append('headroom6dB')
            if value in ('true', '1'):
                self.headroom6dB = True
            elif value in ('false', '0'):
                self.headroom6dB = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('zeroFillInvalidData', node)
        if value is not None and 'zeroFillInvalidData' not in already_processed:
            already_processed.append('zeroFillInvalidData')
            if value in ('true', '1'):
                self.zeroFillInvalidData = True
            elif value in ('false', '0'):
                self.zeroFillInvalidData = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('applyIntegInHw', node)
        if value is not None and 'applyIntegInHw' not in already_processed:
            already_processed.append('applyIntegInHw')
            if value in ('true', '1'):
                self.applyIntegInHw = True
            elif value in ('false', '0'):
                self.applyIntegInHw = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
        value = find_attr_value_('excludeStations', node)
        if value is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            self.excludeStations = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbSingle':
            obj_ = blbSingle.factory()
            obj_.build(child_)
            self.blbSingle.append(obj_)
        elif nodeName_ == 'cc':
            obj_ = cc.factory()
            obj_.build(child_)
            self.set_cc(obj_)
        elif nodeName_ == 'vdif':
            obj_ = vdif.factory()
            obj_.build(child_)
            self.set_vdif(obj_)
# end class summedArray


class modifySummedArray(GeneratedsSuper):
    """Modify summed array - If the action=modify can be specified in
    element subarray or per subband."""
    subclass = None
    superclass = None
    def __init__(self, excludeStations=None, vdifEnableA=False, vdifEnableB=False):
        self.excludeStations = _cast(None, excludeStations)
        self.vdifEnableA = _cast(bool, vdifEnableA)
        self.vdifEnableB = _cast(bool, vdifEnableB)
        pass
    def factory(*args_, **kwargs_):
        if modifySummedArray.subclass:
            return modifySummedArray.subclass(*args_, **kwargs_)
        else:
            return modifySummedArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_excludeStations(self): return self.excludeStations
    def set_excludeStations(self, excludeStations): self.excludeStations = excludeStations
    def get_vdifEnableA(self): return self.vdifEnableA
    def set_vdifEnableA(self, vdifEnableA): self.vdifEnableA = vdifEnableA
    def get_vdifEnableB(self): return self.vdifEnableB
    def set_vdifEnableB(self, vdifEnableB): self.vdifEnableB = vdifEnableB
    def export(self, outfile, level, namespace_='widar:', name_='modifySummedArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modifySummedArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='modifySummedArray'):
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            outfile.write(' excludeStations=%s' % (quote_attrib(self.excludeStations), ))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            outfile.write(' vdifEnableA="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableA)), input_name='vdifEnableA'))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            outfile.write(' vdifEnableB="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableB)), input_name='vdifEnableB'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='modifySummedArray', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modifySummedArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            showIndent(outfile, level)
            outfile.write('excludeStations = %s,\n' % (self.excludeStations,))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            showIndent(outfile, level)
            outfile.write('vdifEnableA = %s,\n' % (self.vdifEnableA,))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            showIndent(outfile, level)
            outfile.write('vdifEnableB = %s,\n' % (self.vdifEnableB,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('excludeStations', node)
        if value is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            self.excludeStations = value
        value = find_attr_value_('vdifEnableA', node)
        if value is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            if value in ('true', '1'):
                self.vdifEnableA = True
            elif value in ('false', '0'):
                self.vdifEnableA = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdifEnableB', node)
        if value is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            if value in ('true', '1'):
                self.vdifEnableB = True
            elif value in ('false', '0'):
                self.vdifEnableB = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modifySummedArray


class cc(GeneratedsSuper):
    """Send summed data to the Correlator Chip Array"""
    subclass = None
    superclass = None
    def __init__(self, agcEnabled=True, requantGain=None, agcRms=None, pp=None, blbPair=None, blbSingle=None, blbProdIntegration=None):
        self.agcEnabled = _cast(bool, agcEnabled)
        self.requantGain = _cast(None, requantGain)
        self.agcRms = _cast(float, agcRms)
        if pp is None:
            self.pp = []
        else:
            self.pp = pp
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        if blbSingle is None:
            self.blbSingle = []
        else:
            self.blbSingle = blbSingle
        self.blbProdIntegration = blbProdIntegration
    def factory(*args_, **kwargs_):
        if cc.subclass:
            return cc.subclass(*args_, **kwargs_)
        else:
            return cc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pp(self): return self.pp
    def set_pp(self, pp): self.pp = pp
    def add_pp(self, value): self.pp.append(value)
    def insert_pp(self, index, value): self.pp[index] = value
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbSingle(self): return self.blbSingle
    def set_blbSingle(self, blbSingle): self.blbSingle = blbSingle
    def add_blbSingle(self, value): self.blbSingle.append(value)
    def insert_blbSingle(self, index, value): self.blbSingle[index] = value
    def get_blbProdIntegration(self): return self.blbProdIntegration
    def set_blbProdIntegration(self, blbProdIntegration): self.blbProdIntegration = blbProdIntegration
    def get_agcEnabled(self): return self.agcEnabled
    def set_agcEnabled(self, agcEnabled): self.agcEnabled = agcEnabled
    def get_requantGain(self): return self.requantGain
    def set_requantGain(self, requantGain): self.requantGain = requantGain
    def get_agcRms(self): return self.agcRms
    def set_agcRms(self, agcRms): self.agcRms = agcRms
    def export(self, outfile, level, namespace_='widar:', name_='cc', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cc')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cc'):
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            outfile.write(' agcEnabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.agcEnabled)), input_name='agcEnabled'))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            outfile.write(' requantGain=%s' % (quote_attrib(self.requantGain), ))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            outfile.write(' agcRms="%s"' % self.gds_format_float(self.agcRms, input_name='agcRms'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cc', fromsubclass_=False):
        for pp_ in self.pp:
            pp_.export(outfile, level, namespace_, name_='pp')
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        for blbSingle_ in self.blbSingle:
            blbSingle_.export(outfile, level, namespace_, name_='blbSingle')
        if self.blbProdIntegration:
            self.blbProdIntegration.export(outfile, level, namespace_, name_='blbProdIntegration')
    def hasContent_(self):
        if (
            self.pp or
            self.blbPair or
            self.blbSingle or
            self.blbProdIntegration is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cc'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            showIndent(outfile, level)
            outfile.write('agcEnabled = %s,\n' % (self.agcEnabled,))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            showIndent(outfile, level)
            outfile.write('requantGain = %s,\n' % (self.requantGain,))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            showIndent(outfile, level)
            outfile.write('agcRms = %f,\n' % (self.agcRms,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pp=[\n')
        level += 1
        for pp_ in self.pp:
            showIndent(outfile, level)
            outfile.write('model_.pp(\n')
            pp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbSingle=[\n')
        level += 1
        for blbSingle_ in self.blbSingle:
            showIndent(outfile, level)
            outfile.write('model_.blbSingle(\n')
            blbSingle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.blbProdIntegration is not None:
            showIndent(outfile, level)
            outfile.write('blbProdIntegration=model_.blbProdIntegration(\n')
            self.blbProdIntegration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agcEnabled', node)
        if value is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            if value in ('true', '1'):
                self.agcEnabled = True
            elif value in ('false', '0'):
                self.agcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('requantGain', node)
        if value is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            self.requantGain = value
        value = find_attr_value_('agcRms', node)
        if value is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            try:
                self.agcRms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (agcRms): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pp':
            obj_ = pp.factory()
            obj_.build(child_)
            self.pp.append(obj_)
        elif nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbSingle':
            obj_ = blbSingle.factory()
            obj_.build(child_)
            self.blbSingle.append(obj_)
        elif nodeName_ == 'blbProdIntegration':
            obj_ = blbProdIntegration.factory()
            obj_.build(child_)
            self.set_blbProdIntegration(obj_)
# end class cc


class vdif(GeneratedsSuper):
    """Send the sum to VDIF"""
    subclass = None
    superclass = None
    def __init__(self, bThread=None, bDestIP=None, frameSize=None, aDestMAC='12:34:56:78:90:00', requantGain=None, agcEnabled=True, aDestPort='12002', epoch=None, aThread=None, aDestIP='192.168.0.21', stationId=None, bDestMAC=None, vdifEnableA=False, epochOffset=None, vdifEnableB=False, bDestPort=None, numBits='2', packetDelay='0', agcRms=None, blbPair=None, blbSingle=None):
        self.bThread = _cast(None, bThread)
        self.bDestIP = _cast(None, bDestIP)
        self.frameSize = _cast(None, frameSize)
        self.aDestMAC = _cast(None, aDestMAC)
        self.requantGain = _cast(None, requantGain)
        self.agcEnabled = _cast(bool, agcEnabled)
        self.aDestPort = _cast(None, aDestPort)
        self.epoch = _cast(None, epoch)
        self.aThread = _cast(None, aThread)
        self.aDestIP = _cast(None, aDestIP)
        self.stationId = _cast(None, stationId)
        self.bDestMAC = _cast(None, bDestMAC)
        self.vdifEnableA = _cast(bool, vdifEnableA)
        self.epochOffset = _cast(int, epochOffset)
        self.vdifEnableB = _cast(bool, vdifEnableB)
        self.bDestPort = _cast(None, bDestPort)
        self.numBits = _cast(None, numBits)
        self.packetDelay = _cast(None, packetDelay)
        self.agcRms = _cast(float, agcRms)
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        if blbSingle is None:
            self.blbSingle = []
        else:
            self.blbSingle = blbSingle
    def factory(*args_, **kwargs_):
        if vdif.subclass:
            return vdif.subclass(*args_, **kwargs_)
        else:
            return vdif(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbSingle(self): return self.blbSingle
    def set_blbSingle(self, blbSingle): self.blbSingle = blbSingle
    def add_blbSingle(self, value): self.blbSingle.append(value)
    def insert_blbSingle(self, index, value): self.blbSingle[index] = value
    def get_bThread(self): return self.bThread
    def set_bThread(self, bThread): self.bThread = bThread
    def get_bDestIP(self): return self.bDestIP
    def set_bDestIP(self, bDestIP): self.bDestIP = bDestIP
    def get_frameSize(self): return self.frameSize
    def set_frameSize(self, frameSize): self.frameSize = frameSize
    def get_aDestMAC(self): return self.aDestMAC
    def set_aDestMAC(self, aDestMAC): self.aDestMAC = aDestMAC
    def get_requantGain(self): return self.requantGain
    def set_requantGain(self, requantGain): self.requantGain = requantGain
    def get_agcEnabled(self): return self.agcEnabled
    def set_agcEnabled(self, agcEnabled): self.agcEnabled = agcEnabled
    def get_aDestPort(self): return self.aDestPort
    def set_aDestPort(self, aDestPort): self.aDestPort = aDestPort
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_aThread(self): return self.aThread
    def set_aThread(self, aThread): self.aThread = aThread
    def get_aDestIP(self): return self.aDestIP
    def set_aDestIP(self, aDestIP): self.aDestIP = aDestIP
    def get_stationId(self): return self.stationId
    def set_stationId(self, stationId): self.stationId = stationId
    def get_bDestMAC(self): return self.bDestMAC
    def set_bDestMAC(self, bDestMAC): self.bDestMAC = bDestMAC
    def get_vdifEnableA(self): return self.vdifEnableA
    def set_vdifEnableA(self, vdifEnableA): self.vdifEnableA = vdifEnableA
    def get_epochOffset(self): return self.epochOffset
    def set_epochOffset(self, epochOffset): self.epochOffset = epochOffset
    def get_vdifEnableB(self): return self.vdifEnableB
    def set_vdifEnableB(self, vdifEnableB): self.vdifEnableB = vdifEnableB
    def get_bDestPort(self): return self.bDestPort
    def set_bDestPort(self, bDestPort): self.bDestPort = bDestPort
    def get_numBits(self): return self.numBits
    def set_numBits(self, numBits): self.numBits = numBits
    def get_packetDelay(self): return self.packetDelay
    def set_packetDelay(self, packetDelay): self.packetDelay = packetDelay
    def get_agcRms(self): return self.agcRms
    def set_agcRms(self, agcRms): self.agcRms = agcRms
    def export(self, outfile, level, namespace_='widar:', name_='vdif', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vdif')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vdif'):
        if self.bThread is not None and 'bThread' not in already_processed:
            already_processed.append('bThread')
            outfile.write(' bThread=%s' % (quote_attrib(self.bThread), ))
        if self.bDestIP is not None and 'bDestIP' not in already_processed:
            already_processed.append('bDestIP')
            outfile.write(' bDestIP=%s' % (quote_attrib(self.bDestIP), ))
        if self.frameSize is not None and 'frameSize' not in already_processed:
            already_processed.append('frameSize')
            outfile.write(' frameSize=%s' % (quote_attrib(self.frameSize), ))
        if self.aDestMAC is not None and 'aDestMAC' not in already_processed:
            already_processed.append('aDestMAC')
            outfile.write(' aDestMAC=%s' % (self.gds_format_string(quote_attrib(self.aDestMAC).encode(ExternalEncoding), input_name='aDestMAC'), ))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            outfile.write(' requantGain=%s' % (quote_attrib(self.requantGain), ))
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            outfile.write(' agcEnabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.agcEnabled)), input_name='agcEnabled'))
        if self.aDestPort is not None and 'aDestPort' not in already_processed:
            already_processed.append('aDestPort')
            outfile.write(' aDestPort=%s' % (self.gds_format_string(quote_attrib(self.aDestPort).encode(ExternalEncoding), input_name='aDestPort'), ))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (quote_attrib(self.epoch), ))
        if self.aThread is not None and 'aThread' not in already_processed:
            already_processed.append('aThread')
            outfile.write(' aThread=%s' % (quote_attrib(self.aThread), ))
        if self.aDestIP is not None and 'aDestIP' not in already_processed:
            already_processed.append('aDestIP')
            outfile.write(' aDestIP=%s' % (quote_attrib(self.aDestIP), ))
        if self.stationId is not None and 'stationId' not in already_processed:
            already_processed.append('stationId')
            outfile.write(' stationId=%s' % (quote_attrib(self.stationId), ))
        if self.bDestMAC is not None and 'bDestMAC' not in already_processed:
            already_processed.append('bDestMAC')
            outfile.write(' bDestMAC=%s' % (self.gds_format_string(quote_attrib(self.bDestMAC).encode(ExternalEncoding), input_name='bDestMAC'), ))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            outfile.write(' vdifEnableA="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableA)), input_name='vdifEnableA'))
        if self.epochOffset is not None and 'epochOffset' not in already_processed:
            already_processed.append('epochOffset')
            outfile.write(' epochOffset="%s"' % self.gds_format_integer(self.epochOffset, input_name='epochOffset'))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            outfile.write(' vdifEnableB="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableB)), input_name='vdifEnableB'))
        if self.bDestPort is not None and 'bDestPort' not in already_processed:
            already_processed.append('bDestPort')
            outfile.write(' bDestPort=%s' % (self.gds_format_string(quote_attrib(self.bDestPort).encode(ExternalEncoding), input_name='bDestPort'), ))
        if self.numBits is not None and 'numBits' not in already_processed:
            already_processed.append('numBits')
            outfile.write(' numBits=%s' % (quote_attrib(self.numBits), ))
        if self.packetDelay is not None and 'packetDelay' not in already_processed:
            already_processed.append('packetDelay')
            outfile.write(' packetDelay=%s' % (quote_attrib(self.packetDelay), ))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            outfile.write(' agcRms="%s"' % self.gds_format_float(self.agcRms, input_name='agcRms'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vdif', fromsubclass_=False):
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        for blbSingle_ in self.blbSingle:
            blbSingle_.export(outfile, level, namespace_, name_='blbSingle')
    def hasContent_(self):
        if (
            self.blbPair or
            self.blbSingle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vdif'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bThread is not None and 'bThread' not in already_processed:
            already_processed.append('bThread')
            showIndent(outfile, level)
            outfile.write('bThread = %s,\n' % (self.bThread,))
        if self.bDestIP is not None and 'bDestIP' not in already_processed:
            already_processed.append('bDestIP')
            showIndent(outfile, level)
            outfile.write('bDestIP = %s,\n' % (self.bDestIP,))
        if self.frameSize is not None and 'frameSize' not in already_processed:
            already_processed.append('frameSize')
            showIndent(outfile, level)
            outfile.write('frameSize = %s,\n' % (self.frameSize,))
        if self.aDestMAC is not None and 'aDestMAC' not in already_processed:
            already_processed.append('aDestMAC')
            showIndent(outfile, level)
            outfile.write('aDestMAC = "%s",\n' % (self.aDestMAC,))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            showIndent(outfile, level)
            outfile.write('requantGain = %s,\n' % (self.requantGain,))
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            showIndent(outfile, level)
            outfile.write('agcEnabled = %s,\n' % (self.agcEnabled,))
        if self.aDestPort is not None and 'aDestPort' not in already_processed:
            already_processed.append('aDestPort')
            showIndent(outfile, level)
            outfile.write('aDestPort = "%s",\n' % (self.aDestPort,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = %s,\n' % (self.epoch,))
        if self.aThread is not None and 'aThread' not in already_processed:
            already_processed.append('aThread')
            showIndent(outfile, level)
            outfile.write('aThread = %s,\n' % (self.aThread,))
        if self.aDestIP is not None and 'aDestIP' not in already_processed:
            already_processed.append('aDestIP')
            showIndent(outfile, level)
            outfile.write('aDestIP = %s,\n' % (self.aDestIP,))
        if self.stationId is not None and 'stationId' not in already_processed:
            already_processed.append('stationId')
            showIndent(outfile, level)
            outfile.write('stationId = %s,\n' % (self.stationId,))
        if self.bDestMAC is not None and 'bDestMAC' not in already_processed:
            already_processed.append('bDestMAC')
            showIndent(outfile, level)
            outfile.write('bDestMAC = "%s",\n' % (self.bDestMAC,))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            showIndent(outfile, level)
            outfile.write('vdifEnableA = %s,\n' % (self.vdifEnableA,))
        if self.epochOffset is not None and 'epochOffset' not in already_processed:
            already_processed.append('epochOffset')
            showIndent(outfile, level)
            outfile.write('epochOffset = %d,\n' % (self.epochOffset,))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            showIndent(outfile, level)
            outfile.write('vdifEnableB = %s,\n' % (self.vdifEnableB,))
        if self.bDestPort is not None and 'bDestPort' not in already_processed:
            already_processed.append('bDestPort')
            showIndent(outfile, level)
            outfile.write('bDestPort = "%s",\n' % (self.bDestPort,))
        if self.numBits is not None and 'numBits' not in already_processed:
            already_processed.append('numBits')
            showIndent(outfile, level)
            outfile.write('numBits = %s,\n' % (self.numBits,))
        if self.packetDelay is not None and 'packetDelay' not in already_processed:
            already_processed.append('packetDelay')
            showIndent(outfile, level)
            outfile.write('packetDelay = %s,\n' % (self.packetDelay,))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            showIndent(outfile, level)
            outfile.write('agcRms = %f,\n' % (self.agcRms,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbSingle=[\n')
        level += 1
        for blbSingle_ in self.blbSingle:
            showIndent(outfile, level)
            outfile.write('model_.blbSingle(\n')
            blbSingle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bThread', node)
        if value is not None and 'bThread' not in already_processed:
            already_processed.append('bThread')
            self.bThread = value
        value = find_attr_value_('bDestIP', node)
        if value is not None and 'bDestIP' not in already_processed:
            already_processed.append('bDestIP')
            self.bDestIP = value
        value = find_attr_value_('frameSize', node)
        if value is not None and 'frameSize' not in already_processed:
            already_processed.append('frameSize')
            self.frameSize = value
        value = find_attr_value_('aDestMAC', node)
        if value is not None and 'aDestMAC' not in already_processed:
            already_processed.append('aDestMAC')
            self.aDestMAC = value
        value = find_attr_value_('requantGain', node)
        if value is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            self.requantGain = value
        value = find_attr_value_('agcEnabled', node)
        if value is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            if value in ('true', '1'):
                self.agcEnabled = True
            elif value in ('false', '0'):
                self.agcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('aDestPort', node)
        if value is not None and 'aDestPort' not in already_processed:
            already_processed.append('aDestPort')
            self.aDestPort = value
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('aThread', node)
        if value is not None and 'aThread' not in already_processed:
            already_processed.append('aThread')
            self.aThread = value
        value = find_attr_value_('aDestIP', node)
        if value is not None and 'aDestIP' not in already_processed:
            already_processed.append('aDestIP')
            self.aDestIP = value
        value = find_attr_value_('stationId', node)
        if value is not None and 'stationId' not in already_processed:
            already_processed.append('stationId')
            self.stationId = value
        value = find_attr_value_('bDestMAC', node)
        if value is not None and 'bDestMAC' not in already_processed:
            already_processed.append('bDestMAC')
            self.bDestMAC = value
        value = find_attr_value_('vdifEnableA', node)
        if value is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            if value in ('true', '1'):
                self.vdifEnableA = True
            elif value in ('false', '0'):
                self.vdifEnableA = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('epochOffset', node)
        if value is not None and 'epochOffset' not in already_processed:
            already_processed.append('epochOffset')
            try:
                self.epochOffset = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vdifEnableB', node)
        if value is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            if value in ('true', '1'):
                self.vdifEnableB = True
            elif value in ('false', '0'):
                self.vdifEnableB = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bDestPort', node)
        if value is not None and 'bDestPort' not in already_processed:
            already_processed.append('bDestPort')
            self.bDestPort = value
        value = find_attr_value_('numBits', node)
        if value is not None and 'numBits' not in already_processed:
            already_processed.append('numBits')
            self.numBits = value
        value = find_attr_value_('packetDelay', node)
        if value is not None and 'packetDelay' not in already_processed:
            already_processed.append('packetDelay')
            self.packetDelay = value
        value = find_attr_value_('agcRms', node)
        if value is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            try:
                self.agcRms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (agcRms): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbSingle':
            obj_ = blbSingle.factory()
            obj_.build(child_)
            self.blbSingle.append(obj_)
# end class vdif


class pulsarBinning(GeneratedsSuper):
    """Minimum Hardware Integration Time (used to generate DUMPTRIG) is
    calculated as period / numBins."""
    subclass = None
    superclass = None
    def __init__(self, status=None, integFactor=None, period=None, firstDerivative=None, numBins=None, epoch=None, secondDerivative=None, blbPair=None, blbSingle=None):
        self.status = _cast(None, status)
        self.integFactor = _cast(int, integFactor)
        self.period = _cast(int, period)
        self.firstDerivative = _cast(int, firstDerivative)
        self.numBins = _cast(None, numBins)
        self.epoch = _cast(None, epoch)
        self.secondDerivative = _cast(int, secondDerivative)
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        if blbSingle is None:
            self.blbSingle = []
        else:
            self.blbSingle = blbSingle
    def factory(*args_, **kwargs_):
        if pulsarBinning.subclass:
            return pulsarBinning.subclass(*args_, **kwargs_)
        else:
            return pulsarBinning(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbSingle(self): return self.blbSingle
    def set_blbSingle(self, blbSingle): self.blbSingle = blbSingle
    def add_blbSingle(self, value): self.blbSingle.append(value)
    def insert_blbSingle(self, index, value): self.blbSingle[index] = value
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_firstDerivative(self): return self.firstDerivative
    def set_firstDerivative(self, firstDerivative): self.firstDerivative = firstDerivative
    def get_numBins(self): return self.numBins
    def set_numBins(self, numBins): self.numBins = numBins
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_secondDerivative(self): return self.secondDerivative
    def set_secondDerivative(self, secondDerivative): self.secondDerivative = secondDerivative
    def export(self, outfile, level, namespace_='widar:', name_='pulsarBinning', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pulsarBinning')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='pulsarBinning'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor="%s"' % self.gds_format_integer(self.integFactor, input_name='integFactor'))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            outfile.write(' firstDerivative="%s"' % self.gds_format_integer(self.firstDerivative, input_name='firstDerivative'))
        if self.numBins is not None and 'numBins' not in already_processed:
            already_processed.append('numBins')
            outfile.write(' numBins=%s' % (quote_attrib(self.numBins), ))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            outfile.write(' secondDerivative="%s"' % self.gds_format_integer(self.secondDerivative, input_name='secondDerivative'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='pulsarBinning', fromsubclass_=False):
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        for blbSingle_ in self.blbSingle:
            blbSingle_.export(outfile, level, namespace_, name_='blbSingle')
    def hasContent_(self):
        if (
            self.blbPair or
            self.blbSingle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pulsarBinning'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %d,\n' % (self.integFactor,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %d,\n' % (self.period,))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            showIndent(outfile, level)
            outfile.write('firstDerivative = %d,\n' % (self.firstDerivative,))
        if self.numBins is not None and 'numBins' not in already_processed:
            already_processed.append('numBins')
            showIndent(outfile, level)
            outfile.write('numBins = %s,\n' % (self.numBins,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            showIndent(outfile, level)
            outfile.write('secondDerivative = %d,\n' % (self.secondDerivative,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbSingle=[\n')
        level += 1
        for blbSingle_ in self.blbSingle:
            showIndent(outfile, level)
            outfile.write('model_.blbSingle(\n')
            blbSingle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            try:
                self.integFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('firstDerivative', node)
        if value is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            try:
                self.firstDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numBins', node)
        if value is not None and 'numBins' not in already_processed:
            already_processed.append('numBins')
            self.numBins = value
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('secondDerivative', node)
        if value is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            try:
                self.secondDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbSingle':
            obj_ = blbSingle.factory()
            obj_.build(child_)
            self.blbSingle.append(obj_)
# end class pulsarBinning


class burstMode(GeneratedsSuper):
    """Burst Mode. Duration and blanking period could be specified in
    milliseconds. Algorithm used for CMIB controlled burst mode TBD."""
    subclass = None
    superclass = None
    def __init__(self, duration=None, epoch=None, mode=None, blankPeriod=None, schedule=None):
        self.duration = _cast(int, duration)
        self.epoch = _cast(None, epoch)
        self.mode = _cast(None, mode)
        self.blankPeriod = _cast(int, blankPeriod)
        self.schedule = _cast(None, schedule)
        pass
    def factory(*args_, **kwargs_):
        if burstMode.subclass:
            return burstMode.subclass(*args_, **kwargs_)
        else:
            return burstMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_blankPeriod(self): return self.blankPeriod
    def set_blankPeriod(self, blankPeriod): self.blankPeriod = blankPeriod
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def export(self, outfile, level, namespace_='widar:', name_='burstMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='burstMode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='burstMode'):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration="%s"' % self.gds_format_integer(self.duration, input_name='duration'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
        if self.blankPeriod is not None and 'blankPeriod' not in already_processed:
            already_processed.append('blankPeriod')
            outfile.write(' blankPeriod="%s"' % self.gds_format_integer(self.blankPeriod, input_name='blankPeriod'))
        if self.schedule is not None and 'schedule' not in already_processed:
            already_processed.append('schedule')
            outfile.write(' schedule=%s' % (self.gds_format_string(quote_attrib(self.schedule).encode(ExternalEncoding), input_name='schedule'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='burstMode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='burstMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = %d,\n' % (self.duration,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            showIndent(outfile, level)
            outfile.write('mode = %s,\n' % (self.mode,))
        if self.blankPeriod is not None and 'blankPeriod' not in already_processed:
            already_processed.append('blankPeriod')
            showIndent(outfile, level)
            outfile.write('blankPeriod = %d,\n' % (self.blankPeriod,))
        if self.schedule is not None and 'schedule' not in already_processed:
            already_processed.append('schedule')
            showIndent(outfile, level)
            outfile.write('schedule = "%s",\n' % (self.schedule,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            try:
                self.duration = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            self.mode = value
        value = find_attr_value_('blankPeriod', node)
        if value is not None and 'blankPeriod' not in already_processed:
            already_processed.append('blankPeriod')
            try:
                self.blankPeriod = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('schedule', node)
        if value is not None and 'schedule' not in already_processed:
            already_processed.append('schedule')
            self.schedule = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class burstMode


class wideBandCorrelator(GeneratedsSuper):
    """Configuration for the Station Board Wideband Correlator. Normally,
    WBC products will be specified using Baseband IDs. Format that
    uses Band IDs may be used for VLBI, or other input that have
    more than one band in the input stream."""
    subclass = None
    superclass = None
    def __init__(self, wbcPolProduct=None):
        if wbcPolProduct is None:
            self.wbcPolProduct = []
        else:
            self.wbcPolProduct = wbcPolProduct
    def factory(*args_, **kwargs_):
        if wideBandCorrelator.subclass:
            return wideBandCorrelator.subclass(*args_, **kwargs_)
        else:
            return wideBandCorrelator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wbcPolProduct(self): return self.wbcPolProduct
    def set_wbcPolProduct(self, wbcPolProduct): self.wbcPolProduct = wbcPolProduct
    def add_wbcPolProduct(self, value): self.wbcPolProduct.append(value)
    def insert_wbcPolProduct(self, index, value): self.wbcPolProduct[index] = value
    def export(self, outfile, level, namespace_='widar:', name_='wideBandCorrelator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wideBandCorrelator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wideBandCorrelator'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wideBandCorrelator', fromsubclass_=False):
        for wbcPolProduct_ in self.wbcPolProduct:
            wbcPolProduct_.export(outfile, level, namespace_, name_='wbcPolProduct')
    def hasContent_(self):
        if (
            self.wbcPolProduct
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wideBandCorrelator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wbcPolProduct=[\n')
        level += 1
        for wbcPolProduct_ in self.wbcPolProduct:
            showIndent(outfile, level)
            outfile.write('model_.wbcPolProduct(\n')
            wbcPolProduct_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'wbcPolProduct':
            obj_ = wbcPolProduct.factory()
            obj_.build(child_)
            self.wbcPolProduct.append(obj_)
# end class wideBandCorrelator


class baseline(GeneratedsSuper):
    """Used to disable / enable baselines. A baseline is uniquely
    identified by a pair of station IDs. If only one Station ID is
    specified, all the baselines for that station will be
    disbled/enabled. If baseband pair (single baseband) and subband
    are not specified applies for all the products (i.e. for all the
    subbands of all the basebandes)."""
    subclass = None
    superclass = None
    def __init__(self, status=None, stationTwo=None, stationOne=None, bbB=None, bbA=None, subband=None):
        self.status = _cast(None, status)
        self.stationTwo = _cast(None, stationTwo)
        self.stationOne = _cast(None, stationOne)
        self.bbB = _cast(None, bbB)
        self.bbA = _cast(None, bbA)
        self.subband = _cast(None, subband)
        pass
    def factory(*args_, **kwargs_):
        if baseline.subclass:
            return baseline.subclass(*args_, **kwargs_)
        else:
            return baseline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_stationTwo(self): return self.stationTwo
    def set_stationTwo(self, stationTwo): self.stationTwo = stationTwo
    def get_stationOne(self): return self.stationOne
    def set_stationOne(self, stationOne): self.stationOne = stationOne
    def get_bbB(self): return self.bbB
    def set_bbB(self, bbB): self.bbB = bbB
    def get_bbA(self): return self.bbA
    def set_bbA(self, bbA): self.bbA = bbA
    def get_subband(self): return self.subband
    def set_subband(self, subband): self.subband = subband
    def export(self, outfile, level, namespace_='widar:', name_='baseline', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseline')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='baseline'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.stationTwo is not None and 'stationTwo' not in already_processed:
            already_processed.append('stationTwo')
            outfile.write(' stationTwo=%s' % (quote_attrib(self.stationTwo), ))
        if self.stationOne is not None and 'stationOne' not in already_processed:
            already_processed.append('stationOne')
            outfile.write(' stationOne=%s' % (quote_attrib(self.stationOne), ))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            outfile.write(' bbB=%s' % (quote_attrib(self.bbB), ))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            outfile.write(' bbA=%s' % (quote_attrib(self.bbA), ))
        if self.subband is not None and 'subband' not in already_processed:
            already_processed.append('subband')
            outfile.write(' subband=%s' % (quote_attrib(self.subband), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='baseline', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='baseline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.stationTwo is not None and 'stationTwo' not in already_processed:
            already_processed.append('stationTwo')
            showIndent(outfile, level)
            outfile.write('stationTwo = %s,\n' % (self.stationTwo,))
        if self.stationOne is not None and 'stationOne' not in already_processed:
            already_processed.append('stationOne')
            showIndent(outfile, level)
            outfile.write('stationOne = %s,\n' % (self.stationOne,))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            showIndent(outfile, level)
            outfile.write('bbB = %s,\n' % (self.bbB,))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            showIndent(outfile, level)
            outfile.write('bbA = %s,\n' % (self.bbA,))
        if self.subband is not None and 'subband' not in already_processed:
            already_processed.append('subband')
            showIndent(outfile, level)
            outfile.write('subband = %s,\n' % (self.subband,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('stationTwo', node)
        if value is not None and 'stationTwo' not in already_processed:
            already_processed.append('stationTwo')
            self.stationTwo = value
        value = find_attr_value_('stationOne', node)
        if value is not None and 'stationOne' not in already_processed:
            already_processed.append('stationOne')
            self.stationOne = value
        value = find_attr_value_('bbB', node)
        if value is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            self.bbB = value
        value = find_attr_value_('bbA', node)
        if value is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            self.bbA = value
        value = find_attr_value_('subband', node)
        if value is not None and 'subband' not in already_processed:
            already_processed.append('subband')
            self.subband = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class baseline


class stationPacking(GeneratedsSuper):
    """Station packing algorithm. User may specify one of the two options:
    1) use the minimum number of the Correlator Chips (i.e. columns
    and rows on the Baseline Board) or 2) distribute station input
    across as many Baseline Board columns/rows as possible."""
    subclass = None
    superclass = None
    def __init__(self, algorithm=None):
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if stationPacking.subclass:
            return stationPacking.subclass(*args_, **kwargs_)
        else:
            return stationPacking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='stationPacking', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stationPacking')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stationPacking'):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stationPacking', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stationPacking'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stationPacking


class productPacking(GeneratedsSuper):
    """Product packing algorithm. This parameter is relevant only if there
    is more than one Correlator Chip available per baseline. User
    can specify one of the two supported options: 1) MaxPack, which
    means: minimise the number of Correlator Chips that produce lag
    chain for each product (i.e. avoid use of static recirulation
    memory) 2) MinPack, which means: distribute lag chain across
    available Correlator Chips."""
    subclass = None
    superclass = None
    def __init__(self, algorithm=None):
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if productPacking.subclass:
            return productPacking.subclass(*args_, **kwargs_)
        else:
            return productPacking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='productPacking', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='productPacking')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='productPacking'):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='productPacking', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='productPacking'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class productPacking


class autoCorrSubset(GeneratedsSuper):
    """The correlator can not obtain all auto-correlation products all the
    time, select a desired subset of auto-correlation products."""
    subclass = None
    superclass = None
    def __init__(self, dwellTime='10', startFrom='lowestStId', algorithm=None):
        self.dwellTime = _cast(None, dwellTime)
        self.startFrom = _cast(None, startFrom)
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if autoCorrSubset.subclass:
            return autoCorrSubset.subclass(*args_, **kwargs_)
        else:
            return autoCorrSubset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dwellTime(self): return self.dwellTime
    def set_dwellTime(self, dwellTime): self.dwellTime = dwellTime
    def get_startFrom(self): return self.startFrom
    def set_startFrom(self, startFrom): self.startFrom = startFrom
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='autoCorrSubset', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autoCorrSubset')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='autoCorrSubset'):
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            outfile.write(' dwellTime=%s' % (quote_attrib(self.dwellTime), ))
        if self.startFrom is not None and 'startFrom' not in already_processed:
            already_processed.append('startFrom')
            outfile.write(' startFrom=%s' % (quote_attrib(self.startFrom), ))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='autoCorrSubset', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='autoCorrSubset'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            showIndent(outfile, level)
            outfile.write('dwellTime = %s,\n' % (self.dwellTime,))
        if self.startFrom is not None and 'startFrom' not in already_processed:
            already_processed.append('startFrom')
            showIndent(outfile, level)
            outfile.write('startFrom = %s,\n' % (self.startFrom,))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dwellTime', node)
        if value is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            self.dwellTime = value
        value = find_attr_value_('startFrom', node)
        if value is not None and 'startFrom' not in already_processed:
            already_processed.append('startFrom')
            self.startFrom = value
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class autoCorrSubset


class autoCorrMode(GeneratedsSuper):
    """Correlator Chip in auto-correlation mode uses all 16 CCCs to produce
    one auto-correlation product (2048 lags). A whole row/colum of
    Correlator Chips may be set in the auto-correlation mode."""
    subclass = None
    superclass = None
    def __init__(self, status=None, blbProdIntegration=None, blbPair=None, blbSingle=None):
        self.status = _cast(None, status)
        self.blbProdIntegration = blbProdIntegration
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        if blbSingle is None:
            self.blbSingle = []
        else:
            self.blbSingle = blbSingle
    def factory(*args_, **kwargs_):
        if autoCorrMode.subclass:
            return autoCorrMode.subclass(*args_, **kwargs_)
        else:
            return autoCorrMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_blbProdIntegration(self): return self.blbProdIntegration
    def set_blbProdIntegration(self, blbProdIntegration): self.blbProdIntegration = blbProdIntegration
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbSingle(self): return self.blbSingle
    def set_blbSingle(self, blbSingle): self.blbSingle = blbSingle
    def add_blbSingle(self, value): self.blbSingle.append(value)
    def insert_blbSingle(self, index, value): self.blbSingle[index] = value
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def export(self, outfile, level, namespace_='widar:', name_='autoCorrMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autoCorrMode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='autoCorrMode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='autoCorrMode', fromsubclass_=False):
        if self.blbProdIntegration:
            self.blbProdIntegration.export(outfile, level, namespace_, name_='blbProdIntegration')
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        for blbSingle_ in self.blbSingle:
            blbSingle_.export(outfile, level, namespace_, name_='blbSingle')
    def hasContent_(self):
        if (
            self.blbProdIntegration is not None or
            self.blbPair or
            self.blbSingle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='autoCorrMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.blbProdIntegration is not None:
            showIndent(outfile, level)
            outfile.write('blbProdIntegration=model_.blbProdIntegration(\n')
            self.blbProdIntegration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbSingle=[\n')
        level += 1
        for blbSingle_ in self.blbSingle:
            showIndent(outfile, level)
            outfile.write('model_.blbSingle(\n')
            blbSingle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'blbProdIntegration':
            obj_ = blbProdIntegration.factory()
            obj_.build(child_)
            self.set_blbProdIntegration(obj_)
        elif nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbSingle':
            obj_ = blbSingle.factory()
            obj_.build(child_)
            self.blbSingle.append(obj_)
# end class autoCorrMode


class antenna(GeneratedsSuper):
    """Basic antenna information as specified in the VCI messages. Antenna
    ID is needed only by the Correlator Backend. Detailed antenna
    information will be specified in the Antenna Table and made
    available to the Backend by some other means (e.g. as a file
    stored on a server)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, name=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if antenna.subclass:
            return antenna.subclass(*args_, **kwargs_)
        else:
            return antenna(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='antenna', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='antenna')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='antenna'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='antenna', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='antenna'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class antenna


class stbDataProducts(GeneratedsSuper):
    """Station Board data products."""
    subclass = None
    superclass = None
    def __init__(self, inputStateCounts=None, clipCounts=None, powerCounts=None, rfiCounts=None, outputStateCounts=None):
        self.inputStateCounts = inputStateCounts
        self.clipCounts = clipCounts
        self.powerCounts = powerCounts
        self.rfiCounts = rfiCounts
        self.outputStateCounts = outputStateCounts
    def factory(*args_, **kwargs_):
        if stbDataProducts.subclass:
            return stbDataProducts.subclass(*args_, **kwargs_)
        else:
            return stbDataProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inputStateCounts(self): return self.inputStateCounts
    def set_inputStateCounts(self, inputStateCounts): self.inputStateCounts = inputStateCounts
    def get_clipCounts(self): return self.clipCounts
    def set_clipCounts(self, clipCounts): self.clipCounts = clipCounts
    def get_powerCounts(self): return self.powerCounts
    def set_powerCounts(self, powerCounts): self.powerCounts = powerCounts
    def get_rfiCounts(self): return self.rfiCounts
    def set_rfiCounts(self, rfiCounts): self.rfiCounts = rfiCounts
    def get_outputStateCounts(self): return self.outputStateCounts
    def set_outputStateCounts(self, outputStateCounts): self.outputStateCounts = outputStateCounts
    def export(self, outfile, level, namespace_='widar:', name_='stbDataProducts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stbDataProducts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stbDataProducts'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stbDataProducts', fromsubclass_=False):
        if self.inputStateCounts:
            self.inputStateCounts.export(outfile, level, namespace_, name_='inputStateCounts')
        if self.clipCounts:
            self.clipCounts.export(outfile, level, namespace_, name_='clipCounts')
        if self.powerCounts:
            self.powerCounts.export(outfile, level, namespace_, name_='powerCounts')
        if self.rfiCounts:
            self.rfiCounts.export(outfile, level, namespace_, name_='rfiCounts')
        if self.outputStateCounts:
            self.outputStateCounts.export(outfile, level, namespace_, name_='outputStateCounts')
    def hasContent_(self):
        if (
            self.inputStateCounts is not None or
            self.clipCounts is not None or
            self.powerCounts is not None or
            self.rfiCounts is not None or
            self.outputStateCounts is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stbDataProducts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inputStateCounts is not None:
            showIndent(outfile, level)
            outfile.write('inputStateCounts=model_.inputStateCounts(\n')
            self.inputStateCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.clipCounts is not None:
            showIndent(outfile, level)
            outfile.write('clipCounts=model_.clipCounts(\n')
            self.clipCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.powerCounts is not None:
            showIndent(outfile, level)
            outfile.write('powerCounts=model_.powerCounts(\n')
            self.powerCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rfiCounts is not None:
            showIndent(outfile, level)
            outfile.write('rfiCounts=model_.rfiCounts(\n')
            self.rfiCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.outputStateCounts is not None:
            showIndent(outfile, level)
            outfile.write('outputStateCounts=model_.outputStateCounts(\n')
            self.outputStateCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inputStateCounts':
            obj_ = inputStateCounts.factory()
            obj_.build(child_)
            self.set_inputStateCounts(obj_)
        elif nodeName_ == 'clipCounts':
            obj_ = clipCounts.factory()
            obj_.build(child_)
            self.set_clipCounts(obj_)
        elif nodeName_ == 'powerCounts':
            obj_ = powerCounts.factory()
            obj_.build(child_)
            self.set_powerCounts(obj_)
        elif nodeName_ == 'rfiCounts':
            obj_ = rfiCounts.factory()
            obj_.build(child_)
            self.set_rfiCounts(obj_)
        elif nodeName_ == 'outputStateCounts':
            obj_ = outputStateCounts.factory()
            obj_.build(child_)
            self.set_outputStateCounts(obj_)
# end class stbDataProducts


class monitorData(GeneratedsSuper):
    """Station Board monitor data."""
    subclass = None
    superclass = None
    def __init__(self, tickIntervalCounts=None, errorCounts=None, crcTable=None):
        self.tickIntervalCounts = tickIntervalCounts
        self.errorCounts = errorCounts
        self.crcTable = crcTable
    def factory(*args_, **kwargs_):
        if monitorData.subclass:
            return monitorData.subclass(*args_, **kwargs_)
        else:
            return monitorData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tickIntervalCounts(self): return self.tickIntervalCounts
    def set_tickIntervalCounts(self, tickIntervalCounts): self.tickIntervalCounts = tickIntervalCounts
    def get_errorCounts(self): return self.errorCounts
    def set_errorCounts(self, errorCounts): self.errorCounts = errorCounts
    def get_crcTable(self): return self.crcTable
    def set_crcTable(self, crcTable): self.crcTable = crcTable
    def export(self, outfile, level, namespace_='widar:', name_='monitorData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='monitorData'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='monitorData', fromsubclass_=False):
        if self.tickIntervalCounts:
            self.tickIntervalCounts.export(outfile, level, namespace_, name_='tickIntervalCounts')
        if self.errorCounts:
            self.errorCounts.export(outfile, level, namespace_, name_='errorCounts')
        if self.crcTable:
            self.crcTable.export(outfile, level, namespace_, name_='crcTable')
    def hasContent_(self):
        if (
            self.tickIntervalCounts is not None or
            self.errorCounts is not None or
            self.crcTable is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='monitorData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.tickIntervalCounts is not None:
            showIndent(outfile, level)
            outfile.write('tickIntervalCounts=model_.tickIntervalCounts(\n')
            self.tickIntervalCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errorCounts is not None:
            showIndent(outfile, level)
            outfile.write('errorCounts=model_.errorCounts(\n')
            self.errorCounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.crcTable is not None:
            showIndent(outfile, level)
            outfile.write('crcTable=model_.crcTable(\n')
            self.crcTable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tickIntervalCounts':
            obj_ = tickIntervalCounts.factory()
            obj_.build(child_)
            self.set_tickIntervalCounts(obj_)
        elif nodeName_ == 'errorCounts':
            obj_ = errorCounts.factory()
            obj_.build(child_)
            self.set_errorCounts(obj_)
        elif nodeName_ == 'crcTable':
            obj_ = crcTable.factory()
            obj_.build(child_)
            self.set_crcTable(obj_)
# end class monitorData


class host(GeneratedsSuper):
    """Set of parameters that unequely define a WIDAR host computer. This
    element may be used in logs/Alarms and other messages, where it
    may be used to identify the machine where log or report was
    originated."""
    subclass = None
    superclass = None
    def __init__(self, instance=None, type_=None, destIP4address=None):
        self.instance = _cast(None, instance)
        self.type_ = _cast(None, type_)
        self.destIP4address = _cast(None, destIP4address)
        pass
    def factory(*args_, **kwargs_):
        if host.subclass:
            return host.subclass(*args_, **kwargs_)
        else:
            return host(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_destIP4address(self): return self.destIP4address
    def set_destIP4address(self, destIP4address): self.destIP4address = destIP4address
    def export(self, outfile, level, namespace_='widar:', name_='host', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='host')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='host'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            outfile.write(' destIP4address=%s' % (quote_attrib(self.destIP4address), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='host', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='host'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            showIndent(outfile, level)
            outfile.write('destIP4address = %s,\n' % (self.destIP4address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('destIP4address', node)
        if value is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            self.destIP4address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class host


class wbcPolProduct(GeneratedsSuper):
    """Wideband Correlator Product. Specifies the product ID and input data
    streams that should be correlated. Baseband IDs are used to
    identify data streams to be correlated."""
    subclass = None
    superclass = None
    def __init__(self, laggedBBID=None, spectChannels=None, ppid=None, integFactor=1, promptBBID=None):
        self.laggedBBID = _cast(None, laggedBBID)
        self.spectChannels = _cast(None, spectChannels)
        self.ppid = _cast(None, ppid)
        self.integFactor = _cast(int, integFactor)
        self.promptBBID = _cast(None, promptBBID)
        pass
    def factory(*args_, **kwargs_):
        if wbcPolProduct.subclass:
            return wbcPolProduct.subclass(*args_, **kwargs_)
        else:
            return wbcPolProduct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_laggedBBID(self): return self.laggedBBID
    def set_laggedBBID(self, laggedBBID): self.laggedBBID = laggedBBID
    def get_spectChannels(self): return self.spectChannels
    def set_spectChannels(self, spectChannels): self.spectChannels = spectChannels
    def get_ppid(self): return self.ppid
    def set_ppid(self, ppid): self.ppid = ppid
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_promptBBID(self): return self.promptBBID
    def set_promptBBID(self, promptBBID): self.promptBBID = promptBBID
    def export(self, outfile, level, namespace_='widar:', name_='wbcPolProduct', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wbcPolProduct')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wbcPolProduct'):
        if self.laggedBBID is not None and 'laggedBBID' not in already_processed:
            already_processed.append('laggedBBID')
            outfile.write(' laggedBBID=%s' % (quote_attrib(self.laggedBBID), ))
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            outfile.write(' spectChannels=%s' % (quote_attrib(self.spectChannels), ))
        if self.ppid is not None and 'ppid' not in already_processed:
            already_processed.append('ppid')
            outfile.write(' ppid=%s' % (quote_attrib(self.ppid), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor="%s"' % self.gds_format_integer(self.integFactor, input_name='integFactor'))
        if self.promptBBID is not None and 'promptBBID' not in already_processed:
            already_processed.append('promptBBID')
            outfile.write(' promptBBID=%s' % (quote_attrib(self.promptBBID), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wbcPolProduct', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wbcPolProduct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laggedBBID is not None and 'laggedBBID' not in already_processed:
            already_processed.append('laggedBBID')
            showIndent(outfile, level)
            outfile.write('laggedBBID = %s,\n' % (self.laggedBBID,))
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            showIndent(outfile, level)
            outfile.write('spectChannels = %s,\n' % (self.spectChannels,))
        if self.ppid is not None and 'ppid' not in already_processed:
            already_processed.append('ppid')
            showIndent(outfile, level)
            outfile.write('ppid = %s,\n' % (self.ppid,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %d,\n' % (self.integFactor,))
        if self.promptBBID is not None and 'promptBBID' not in already_processed:
            already_processed.append('promptBBID')
            showIndent(outfile, level)
            outfile.write('promptBBID = %s,\n' % (self.promptBBID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laggedBBID', node)
        if value is not None and 'laggedBBID' not in already_processed:
            already_processed.append('laggedBBID')
            self.laggedBBID = value
        value = find_attr_value_('spectChannels', node)
        if value is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            self.spectChannels = value
        value = find_attr_value_('ppid', node)
        if value is not None and 'ppid' not in already_processed:
            already_processed.append('ppid')
            self.ppid = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            try:
                self.integFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('promptBBID', node)
        if value is not None and 'promptBBID' not in already_processed:
            already_processed.append('promptBBID')
            self.promptBBID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wbcPolProduct


class radarMode(GeneratedsSuper):
    """Raw data saving, also known as, radar mode. Narrow band output of a
    single filter per Station Board Data Path (i.e. per filter bank)
    can be saved in the memory and sent to the specified location.
    Number of bits to be saved is equal to the number of bits in the
    filter output, with exception of 7-bit output which is saved as
    8 bits of data. Duration can be specified in the number of 10
    millisecond interrupts. Duration=0 means perform data saving
    until "off" command is received or until the configuration is
    overwritten by another configuration."""
    subclass = None
    superclass = None
    def __init__(self, status=None, duration=0, destination=None):
        self.status = _cast(None, status)
        self.duration = _cast(int, duration)
        self.destination = _cast(None, destination)
        pass
    def factory(*args_, **kwargs_):
        if radarMode.subclass:
            return radarMode.subclass(*args_, **kwargs_)
        else:
            return radarMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def export(self, outfile, level, namespace_='widar:', name_='radarMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='radarMode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='radarMode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration="%s"' % self.gds_format_integer(self.duration, input_name='duration'))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='radarMode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='radarMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = %d,\n' % (self.duration,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            try:
                self.duration = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class radarMode


class cmMonitorControl(GeneratedsSuper):
    """Global parameters of VCI Configuration Mapper."""
    subclass = None
    superclass = None
    def __init__(self, vciSchemaValidation=None, sendConfigToCRM=None, sendConfigToBLBs=None, sendConfigToCBE=None, sendConfigToXBBs=None, query=None, flushCmibQueues=None, sendConfigToSTBs=None, queryCfgStatus=None, cfgQueue=None, actQueue=None, ctrlQueue=None, cmLogging=None, vciReporting=None, cmAlerts=None, cmDeleteSubarray=None):
        self.vciSchemaValidation = _cast(None, vciSchemaValidation)
        self.sendConfigToCRM = _cast(None, sendConfigToCRM)
        self.sendConfigToBLBs = _cast(None, sendConfigToBLBs)
        self.sendConfigToCBE = _cast(None, sendConfigToCBE)
        self.sendConfigToXBBs = _cast(None, sendConfigToXBBs)
        self.query = _cast(None, query)
        self.flushCmibQueues = _cast(None, flushCmibQueues)
        self.sendConfigToSTBs = _cast(None, sendConfigToSTBs)
        self.queryCfgStatus = queryCfgStatus
        self.cfgQueue = cfgQueue
        self.actQueue = actQueue
        self.ctrlQueue = ctrlQueue
        self.cmLogging = cmLogging
        self.vciReporting = vciReporting
        self.cmAlerts = cmAlerts
        self.cmDeleteSubarray = cmDeleteSubarray
    def factory(*args_, **kwargs_):
        if cmMonitorControl.subclass:
            return cmMonitorControl.subclass(*args_, **kwargs_)
        else:
            return cmMonitorControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryCfgStatus(self): return self.queryCfgStatus
    def set_queryCfgStatus(self, queryCfgStatus): self.queryCfgStatus = queryCfgStatus
    def get_cfgQueue(self): return self.cfgQueue
    def set_cfgQueue(self, cfgQueue): self.cfgQueue = cfgQueue
    def get_actQueue(self): return self.actQueue
    def set_actQueue(self, actQueue): self.actQueue = actQueue
    def get_ctrlQueue(self): return self.ctrlQueue
    def set_ctrlQueue(self, ctrlQueue): self.ctrlQueue = ctrlQueue
    def get_cmLogging(self): return self.cmLogging
    def set_cmLogging(self, cmLogging): self.cmLogging = cmLogging
    def get_vciReporting(self): return self.vciReporting
    def set_vciReporting(self, vciReporting): self.vciReporting = vciReporting
    def get_cmAlerts(self): return self.cmAlerts
    def set_cmAlerts(self, cmAlerts): self.cmAlerts = cmAlerts
    def get_cmDeleteSubarray(self): return self.cmDeleteSubarray
    def set_cmDeleteSubarray(self, cmDeleteSubarray): self.cmDeleteSubarray = cmDeleteSubarray
    def get_vciSchemaValidation(self): return self.vciSchemaValidation
    def set_vciSchemaValidation(self, vciSchemaValidation): self.vciSchemaValidation = vciSchemaValidation
    def get_sendConfigToCRM(self): return self.sendConfigToCRM
    def set_sendConfigToCRM(self, sendConfigToCRM): self.sendConfigToCRM = sendConfigToCRM
    def get_sendConfigToBLBs(self): return self.sendConfigToBLBs
    def set_sendConfigToBLBs(self, sendConfigToBLBs): self.sendConfigToBLBs = sendConfigToBLBs
    def get_sendConfigToCBE(self): return self.sendConfigToCBE
    def set_sendConfigToCBE(self, sendConfigToCBE): self.sendConfigToCBE = sendConfigToCBE
    def get_sendConfigToXBBs(self): return self.sendConfigToXBBs
    def set_sendConfigToXBBs(self, sendConfigToXBBs): self.sendConfigToXBBs = sendConfigToXBBs
    def get_query(self): return self.query
    def set_query(self, query): self.query = query
    def get_flushCmibQueues(self): return self.flushCmibQueues
    def set_flushCmibQueues(self, flushCmibQueues): self.flushCmibQueues = flushCmibQueues
    def get_sendConfigToSTBs(self): return self.sendConfigToSTBs
    def set_sendConfigToSTBs(self, sendConfigToSTBs): self.sendConfigToSTBs = sendConfigToSTBs
    def export(self, outfile, level, namespace_='widar:', name_='cmMonitorControl', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmMonitorControl')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmMonitorControl'):
        if self.vciSchemaValidation is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            outfile.write(' vciSchemaValidation=%s' % (quote_attrib(self.vciSchemaValidation), ))
        if self.sendConfigToCRM is not None and 'sendConfigToCRM' not in already_processed:
            already_processed.append('sendConfigToCRM')
            outfile.write(' sendConfigToCRM=%s' % (quote_attrib(self.sendConfigToCRM), ))
        if self.sendConfigToBLBs is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            outfile.write(' sendConfigToBLBs=%s' % (quote_attrib(self.sendConfigToBLBs), ))
        if self.sendConfigToCBE is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            outfile.write(' sendConfigToCBE=%s' % (quote_attrib(self.sendConfigToCBE), ))
        if self.sendConfigToXBBs is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            outfile.write(' sendConfigToXBBs=%s' % (quote_attrib(self.sendConfigToXBBs), ))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            outfile.write(' query=%s' % (quote_attrib(self.query), ))
        if self.flushCmibQueues is not None and 'flushCmibQueues' not in already_processed:
            already_processed.append('flushCmibQueues')
            outfile.write(' flushCmibQueues=%s' % (quote_attrib(self.flushCmibQueues), ))
        if self.sendConfigToSTBs is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            outfile.write(' sendConfigToSTBs=%s' % (quote_attrib(self.sendConfigToSTBs), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmMonitorControl', fromsubclass_=False):
        if self.queryCfgStatus:
            self.queryCfgStatus.export(outfile, level, namespace_, name_='queryCfgStatus')
        if self.cfgQueue:
            self.cfgQueue.export(outfile, level, namespace_, name_='cfgQueue')
        if self.actQueue:
            self.actQueue.export(outfile, level, namespace_, name_='actQueue')
        if self.ctrlQueue:
            self.ctrlQueue.export(outfile, level, namespace_, name_='ctrlQueue')
        if self.cmLogging:
            self.cmLogging.export(outfile, level, namespace_, name_='cmLogging')
        if self.vciReporting:
            self.vciReporting.export(outfile, level, namespace_, name_='vciReporting')
        if self.cmAlerts:
            self.cmAlerts.export(outfile, level, namespace_, name_='cmAlerts')
        if self.cmDeleteSubarray:
            self.cmDeleteSubarray.export(outfile, level, namespace_, name_='cmDeleteSubarray')
    def hasContent_(self):
        if (
            self.queryCfgStatus is not None or
            self.cfgQueue is not None or
            self.actQueue is not None or
            self.ctrlQueue is not None or
            self.cmLogging is not None or
            self.vciReporting is not None or
            self.cmAlerts is not None or
            self.cmDeleteSubarray is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmMonitorControl'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vciSchemaValidation is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            showIndent(outfile, level)
            outfile.write('vciSchemaValidation = %s,\n' % (self.vciSchemaValidation,))
        if self.sendConfigToCRM is not None and 'sendConfigToCRM' not in already_processed:
            already_processed.append('sendConfigToCRM')
            showIndent(outfile, level)
            outfile.write('sendConfigToCRM = %s,\n' % (self.sendConfigToCRM,))
        if self.sendConfigToBLBs is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToBLBs = %s,\n' % (self.sendConfigToBLBs,))
        if self.sendConfigToCBE is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            showIndent(outfile, level)
            outfile.write('sendConfigToCBE = %s,\n' % (self.sendConfigToCBE,))
        if self.sendConfigToXBBs is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToXBBs = %s,\n' % (self.sendConfigToXBBs,))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            showIndent(outfile, level)
            outfile.write('query = %s,\n' % (self.query,))
        if self.flushCmibQueues is not None and 'flushCmibQueues' not in already_processed:
            already_processed.append('flushCmibQueues')
            showIndent(outfile, level)
            outfile.write('flushCmibQueues = %s,\n' % (self.flushCmibQueues,))
        if self.sendConfigToSTBs is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToSTBs = %s,\n' % (self.sendConfigToSTBs,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.queryCfgStatus is not None:
            showIndent(outfile, level)
            outfile.write('queryCfgStatus=model_.queryCfgStatus(\n')
            self.queryCfgStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cfgQueue is not None:
            showIndent(outfile, level)
            outfile.write('cfgQueue=model_.cfgQueue(\n')
            self.cfgQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.actQueue is not None:
            showIndent(outfile, level)
            outfile.write('actQueue=model_.actQueue(\n')
            self.actQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ctrlQueue is not None:
            showIndent(outfile, level)
            outfile.write('ctrlQueue=model_.ctrlQueue(\n')
            self.ctrlQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmLogging is not None:
            showIndent(outfile, level)
            outfile.write('cmLogging=model_.cmLogging(\n')
            self.cmLogging.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vciReporting is not None:
            showIndent(outfile, level)
            outfile.write('vciReporting=model_.vciReporting(\n')
            self.vciReporting.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmAlerts is not None:
            showIndent(outfile, level)
            outfile.write('cmAlerts=model_.cmAlerts(\n')
            self.cmAlerts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmDeleteSubarray is not None:
            showIndent(outfile, level)
            outfile.write('cmDeleteSubarray=model_.cmDeleteSubarray(\n')
            self.cmDeleteSubarray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vciSchemaValidation', node)
        if value is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            self.vciSchemaValidation = value
        value = find_attr_value_('sendConfigToCRM', node)
        if value is not None and 'sendConfigToCRM' not in already_processed:
            already_processed.append('sendConfigToCRM')
            self.sendConfigToCRM = value
        value = find_attr_value_('sendConfigToBLBs', node)
        if value is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            self.sendConfigToBLBs = value
        value = find_attr_value_('sendConfigToCBE', node)
        if value is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            self.sendConfigToCBE = value
        value = find_attr_value_('sendConfigToXBBs', node)
        if value is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            self.sendConfigToXBBs = value
        value = find_attr_value_('query', node)
        if value is not None and 'query' not in already_processed:
            already_processed.append('query')
            self.query = value
        value = find_attr_value_('flushCmibQueues', node)
        if value is not None and 'flushCmibQueues' not in already_processed:
            already_processed.append('flushCmibQueues')
            self.flushCmibQueues = value
        value = find_attr_value_('sendConfigToSTBs', node)
        if value is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            self.sendConfigToSTBs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'queryCfgStatus':
            obj_ = queryCfgStatus.factory()
            obj_.build(child_)
            self.set_queryCfgStatus(obj_)
        elif nodeName_ == 'cfgQueue':
            obj_ = cfgQueue.factory()
            obj_.build(child_)
            self.set_cfgQueue(obj_)
        elif nodeName_ == 'actQueue':
            obj_ = actQueue.factory()
            obj_.build(child_)
            self.set_actQueue(obj_)
        elif nodeName_ == 'ctrlQueue':
            obj_ = ctrlQueue.factory()
            obj_.build(child_)
            self.set_ctrlQueue(obj_)
        elif nodeName_ == 'cmLogging':
            obj_ = cmLogging.factory()
            obj_.build(child_)
            self.set_cmLogging(obj_)
        elif nodeName_ == 'vciReporting':
            obj_ = vciReporting.factory()
            obj_.build(child_)
            self.set_vciReporting(obj_)
        elif nodeName_ == 'cmAlerts':
            obj_ = cmAlerts.factory()
            obj_.build(child_)
            self.set_cmAlerts(obj_)
        elif nodeName_ == 'cmDeleteSubarray':
            obj_ = cmDeleteSubarray.factory()
            obj_.build(child_)
            self.set_cmDeleteSubarray(obj_)
# end class cmMonitorControl


class vciReporting(GeneratedsSuper):
    """Specify destination address and port for VCI Responses/Reports.
    Enable/disable transmission of VCI Responses/Reports."""
    subclass = None
    superclass = None
    def __init__(self, transmit=None, destIpAddress=None, destPort=None):
        self.transmit = _cast(None, transmit)
        self.destIpAddress = _cast(None, destIpAddress)
        self.destPort = _cast(int, destPort)
        pass
    def factory(*args_, **kwargs_):
        if vciReporting.subclass:
            return vciReporting.subclass(*args_, **kwargs_)
        else:
            return vciReporting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transmit(self): return self.transmit
    def set_transmit(self, transmit): self.transmit = transmit
    def get_destIpAddress(self): return self.destIpAddress
    def set_destIpAddress(self, destIpAddress): self.destIpAddress = destIpAddress
    def get_destPort(self): return self.destPort
    def set_destPort(self, destPort): self.destPort = destPort
    def export(self, outfile, level, namespace_='widar:', name_='vciReporting', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vciReporting')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vciReporting'):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            outfile.write(' transmit=%s' % (quote_attrib(self.transmit), ))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            outfile.write(' destIpAddress=%s' % (self.gds_format_string(quote_attrib(self.destIpAddress).encode(ExternalEncoding), input_name='destIpAddress'), ))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            outfile.write(' destPort="%s"' % self.gds_format_integer(self.destPort, input_name='destPort'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vciReporting', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vciReporting'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            showIndent(outfile, level)
            outfile.write('transmit = %s,\n' % (self.transmit,))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            showIndent(outfile, level)
            outfile.write('destIpAddress = "%s",\n' % (self.destIpAddress,))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            showIndent(outfile, level)
            outfile.write('destPort = %d,\n' % (self.destPort,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transmit', node)
        if value is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            self.transmit = value
        value = find_attr_value_('destIpAddress', node)
        if value is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            self.destIpAddress = value
        value = find_attr_value_('destPort', node)
        if value is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            try:
                self.destPort = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vciReporting


class cmAlerts(GeneratedsSuper):
    """Specify destination address and port for xAlerts. Enable/disable
    transmission of xAlerts."""
    subclass = None
    superclass = None
    def __init__(self, transmit=None, destIpAddress=None, destPort=None):
        self.transmit = _cast(None, transmit)
        self.destIpAddress = _cast(None, destIpAddress)
        self.destPort = _cast(int, destPort)
        pass
    def factory(*args_, **kwargs_):
        if cmAlerts.subclass:
            return cmAlerts.subclass(*args_, **kwargs_)
        else:
            return cmAlerts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transmit(self): return self.transmit
    def set_transmit(self, transmit): self.transmit = transmit
    def get_destIpAddress(self): return self.destIpAddress
    def set_destIpAddress(self, destIpAddress): self.destIpAddress = destIpAddress
    def get_destPort(self): return self.destPort
    def set_destPort(self, destPort): self.destPort = destPort
    def export(self, outfile, level, namespace_='widar:', name_='cmAlerts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmAlerts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmAlerts'):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            outfile.write(' transmit=%s' % (quote_attrib(self.transmit), ))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            outfile.write(' destIpAddress=%s' % (self.gds_format_string(quote_attrib(self.destIpAddress).encode(ExternalEncoding), input_name='destIpAddress'), ))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            outfile.write(' destPort="%s"' % self.gds_format_integer(self.destPort, input_name='destPort'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmAlerts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmAlerts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            showIndent(outfile, level)
            outfile.write('transmit = %s,\n' % (self.transmit,))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            showIndent(outfile, level)
            outfile.write('destIpAddress = "%s",\n' % (self.destIpAddress,))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            showIndent(outfile, level)
            outfile.write('destPort = %d,\n' % (self.destPort,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transmit', node)
        if value is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            self.transmit = value
        value = find_attr_value_('destIpAddress', node)
        if value is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            self.destIpAddress = value
        value = find_attr_value_('destPort', node)
        if value is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            try:
                self.destPort = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmAlerts


class queryCfgStatus(GeneratedsSuper):
    """Request for configuration status report. One can specify: cfg=active
    or cfg=next or activation time or CorrModel ID. If more than one
    identification is specified, CM uses the first valid identifier,
    in following order: 1. cfg 2. actTime 3. CorrModel ID"""
    subclass = None
    superclass = None
    def __init__(self, actTime=None, cfg=None, corrModelId=None):
        self.actTime = _cast(None, actTime)
        self.cfg = _cast(None, cfg)
        self.corrModelId = _cast(float, corrModelId)
        pass
    def factory(*args_, **kwargs_):
        if queryCfgStatus.subclass:
            return queryCfgStatus.subclass(*args_, **kwargs_)
        else:
            return queryCfgStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actTime(self): return self.actTime
    def set_actTime(self, actTime): self.actTime = actTime
    def get_cfg(self): return self.cfg
    def set_cfg(self, cfg): self.cfg = cfg
    def get_corrModelId(self): return self.corrModelId
    def set_corrModelId(self, corrModelId): self.corrModelId = corrModelId
    def export(self, outfile, level, namespace_='widar:', name_='queryCfgStatus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='queryCfgStatus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='queryCfgStatus'):
        if self.actTime is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            outfile.write(' actTime=%s' % (self.gds_format_string(quote_attrib(self.actTime).encode(ExternalEncoding), input_name='actTime'), ))
        if self.cfg is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            outfile.write(' cfg=%s' % (quote_attrib(self.cfg), ))
        if self.corrModelId is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            outfile.write(' corrModelId="%s"' % self.gds_format_double(self.corrModelId, input_name='corrModelId'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='queryCfgStatus', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='queryCfgStatus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.actTime is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            showIndent(outfile, level)
            outfile.write('actTime = "%s",\n' % (self.actTime,))
        if self.cfg is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            showIndent(outfile, level)
            outfile.write('cfg = %s,\n' % (self.cfg,))
        if self.corrModelId is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            showIndent(outfile, level)
            outfile.write('corrModelId = %e,\n' % (self.corrModelId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actTime', node)
        if value is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            self.actTime = value
        value = find_attr_value_('cfg', node)
        if value is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            self.cfg = value
        value = find_attr_value_('corrModelId', node)
        if value is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            try:
                self.corrModelId = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (corrModelId): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class queryCfgStatus


class cfgQueue(GeneratedsSuper):
    """Monitor and control for the configuration queue."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cfgQueue.subclass:
            return cfgQueue.subclass(*args_, **kwargs_)
        else:
            return cfgQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cfgQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cfgQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cfgQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cfgQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cfgQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cfgQueue


class actQueue(GeneratedsSuper):
    """Monitor and control for the activation queue."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if actQueue.subclass:
            return actQueue.subclass(*args_, **kwargs_)
        else:
            return actQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='actQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='actQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='actQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='actQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class actQueue


class ctrlQueue(GeneratedsSuper):
    """Monitor and control for the queue that contains Control messages."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ctrlQueue.subclass:
            return ctrlQueue.subclass(*args_, **kwargs_)
        else:
            return ctrlQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='ctrlQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ctrlQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='ctrlQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='ctrlQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ctrlQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ctrlQueue


class cmDeleteSubarray(GeneratedsSuper):
    """Delete subarray with the specified Config ID. If configId==all
    delete all subarrays. This command is used when usr does not
    want to (or cannot) specify activation time. When this command
    is received, CM searches both the active configuration and all
    the scheduled configurations (in the Activation Queue) and
    deletes all the instances of a subarray with the specified
    Config ID."""
    subclass = None
    superclass = None
    def __init__(self, configId=None, valueOf_=None):
        self.configId = _cast(None, configId)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cmDeleteSubarray.subclass:
            return cmDeleteSubarray.subclass(*args_, **kwargs_)
        else:
            return cmDeleteSubarray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configId(self): return self.configId
    def set_configId(self, configId): self.configId = configId
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cmDeleteSubarray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmDeleteSubarray')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmDeleteSubarray'):
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            outfile.write(' configId=%s' % (self.gds_format_string(quote_attrib(self.configId).encode(ExternalEncoding), input_name='configId'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmDeleteSubarray', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmDeleteSubarray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            showIndent(outfile, level)
            outfile.write('configId = "%s",\n' % (self.configId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('configId', node)
        if value is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            self.configId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmDeleteSubarray


class cmLogging(GeneratedsSuper):
    "
    subclass = None
    superclass = None
    def __init__(self, level=None, logCrmMessages=None, logToFile=None, logCbeMessages=None, logBlbMessages=None, logXAlerts=None, logVciMessages=None, logStbMessages=None, logXbbMessages=None):
        self.level = _cast(None, level)
        self.logCrmMessages = _cast(None, logCrmMessages)
        self.logToFile = _cast(None, logToFile)
        self.logCbeMessages = _cast(None, logCbeMessages)
        self.logBlbMessages = _cast(None, logBlbMessages)
        self.logXAlerts = _cast(None, logXAlerts)
        self.logVciMessages = _cast(None, logVciMessages)
        self.logStbMessages = _cast(None, logStbMessages)
        self.logXbbMessages = _cast(None, logXbbMessages)
        pass
    def factory(*args_, **kwargs_):
        if cmLogging.subclass:
            return cmLogging.subclass(*args_, **kwargs_)
        else:
            return cmLogging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_logCrmMessages(self): return self.logCrmMessages
    def set_logCrmMessages(self, logCrmMessages): self.logCrmMessages = logCrmMessages
    def get_logToFile(self): return self.logToFile
    def set_logToFile(self, logToFile): self.logToFile = logToFile
    def get_logCbeMessages(self): return self.logCbeMessages
    def set_logCbeMessages(self, logCbeMessages): self.logCbeMessages = logCbeMessages
    def get_logBlbMessages(self): return self.logBlbMessages
    def set_logBlbMessages(self, logBlbMessages): self.logBlbMessages = logBlbMessages
    def get_logXAlerts(self): return self.logXAlerts
    def set_logXAlerts(self, logXAlerts): self.logXAlerts = logXAlerts
    def get_logVciMessages(self): return self.logVciMessages
    def set_logVciMessages(self, logVciMessages): self.logVciMessages = logVciMessages
    def get_logStbMessages(self): return self.logStbMessages
    def set_logStbMessages(self, logStbMessages): self.logStbMessages = logStbMessages
    def get_logXbbMessages(self): return self.logXbbMessages
    def set_logXbbMessages(self, logXbbMessages): self.logXbbMessages = logXbbMessages
    def export(self, outfile, level, namespace_='widar:', name_='cmLogging', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmLogging')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmLogging'):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.logCrmMessages is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            outfile.write(' logCrmMessages=%s' % (quote_attrib(self.logCrmMessages), ))
        if self.logToFile is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            outfile.write(' logToFile=%s' % (quote_attrib(self.logToFile), ))
        if self.logCbeMessages is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            outfile.write(' logCbeMessages=%s' % (quote_attrib(self.logCbeMessages), ))
        if self.logBlbMessages is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            outfile.write(' logBlbMessages=%s' % (quote_attrib(self.logBlbMessages), ))
        if self.logXAlerts is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            outfile.write(' logXAlerts=%s' % (quote_attrib(self.logXAlerts), ))
        if self.logVciMessages is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            outfile.write(' logVciMessages=%s' % (quote_attrib(self.logVciMessages), ))
        if self.logStbMessages is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            outfile.write(' logStbMessages=%s' % (quote_attrib(self.logStbMessages), ))
        if self.logXbbMessages is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            outfile.write(' logXbbMessages=%s' % (quote_attrib(self.logXbbMessages), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmLogging', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmLogging'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
        if self.logCrmMessages is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            showIndent(outfile, level)
            outfile.write('logCrmMessages = %s,\n' % (self.logCrmMessages,))
        if self.logToFile is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            showIndent(outfile, level)
            outfile.write('logToFile = %s,\n' % (self.logToFile,))
        if self.logCbeMessages is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            showIndent(outfile, level)
            outfile.write('logCbeMessages = %s,\n' % (self.logCbeMessages,))
        if self.logBlbMessages is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            showIndent(outfile, level)
            outfile.write('logBlbMessages = %s,\n' % (self.logBlbMessages,))
        if self.logXAlerts is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            showIndent(outfile, level)
            outfile.write('logXAlerts = %s,\n' % (self.logXAlerts,))
        if self.logVciMessages is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            showIndent(outfile, level)
            outfile.write('logVciMessages = %s,\n' % (self.logVciMessages,))
        if self.logStbMessages is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            showIndent(outfile, level)
            outfile.write('logStbMessages = %s,\n' % (self.logStbMessages,))
        if self.logXbbMessages is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            showIndent(outfile, level)
            outfile.write('logXbbMessages = %s,\n' % (self.logXbbMessages,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
        value = find_attr_value_('logCrmMessages', node)
        if value is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            self.logCrmMessages = value
        value = find_attr_value_('logToFile', node)
        if value is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            self.logToFile = value
        value = find_attr_value_('logCbeMessages', node)
        if value is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            self.logCbeMessages = value
        value = find_attr_value_('logBlbMessages', node)
        if value is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            self.logBlbMessages = value
        value = find_attr_value_('logXAlerts', node)
        if value is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            self.logXAlerts = value
        value = find_attr_value_('logVciMessages', node)
        if value is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            self.logVciMessages = value
        value = find_attr_value_('logStbMessages', node)
        if value is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            self.logStbMessages = value
        value = find_attr_value_('logXbbMessages', node)
        if value is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            self.logXbbMessages = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmLogging


class component(GeneratedsSuper):
    """This is an attempt to define an XML element that could be used to
    query or report status of any h/w or s/w component. Element
    component can be generated both by the VCI client and by the
    correlator. ID and type are enough to unquely identify any WIDAR
    component. Optionally, a name can be assigned, but VCI clinet
    can not use the name to identify component. Attributes xmlTag
    and status are specified only by the correlator. If an XML
    element is specified for the component, the message generated by
    the correlator"""
    subclass = None
    superclass = None
    def __init__(self, status=None, xmlTag=None, type_=None, id=None, name=None):
        self.status = _cast(None, status)
        self.xmlTag = _cast(None, xmlTag)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if component.subclass:
            return component.subclass(*args_, **kwargs_)
        else:
            return component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_xmlTag(self): return self.xmlTag
    def set_xmlTag(self, xmlTag): self.xmlTag = xmlTag
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='component', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='component')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='component'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.xmlTag is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            outfile.write(' xmlTag=%s' % (self.gds_format_string(quote_attrib(self.xmlTag).encode(ExternalEncoding), input_name='xmlTag'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='component', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='component'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = "%s",\n' % (self.status,))
        if self.xmlTag is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            showIndent(outfile, level)
            outfile.write('xmlTag = "%s",\n' % (self.xmlTag,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('xmlTag', node)
        if value is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            self.xmlTag = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class component


class originator(GeneratedsSuper):
    """Originator of the vciLog. Depending on the type of event, name of
    the class, method and/or thread may be provided."""
    subclass = None
    superclass = None
    def __init__(self, thread=None, classxx=None, componentID=None, componentType=None, logger=None, method=None):
        self.thread = _cast(None, thread)
        self.classxx = _cast(None, classxx)
        self.componentID = _cast(None, componentID)
        self.componentType = _cast(None, componentType)
        self.logger = _cast(None, logger)
        self.method = _cast(None, method)
        pass
    def factory(*args_, **kwargs_):
        if originator.subclass:
            return originator.subclass(*args_, **kwargs_)
        else:
            return originator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thread(self): return self.thread
    def set_thread(self, thread): self.thread = thread
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def get_componentID(self): return self.componentID
    def set_componentID(self, componentID): self.componentID = componentID
    def get_componentType(self): return self.componentType
    def set_componentType(self, componentType): self.componentType = componentType
    def get_logger(self): return self.logger
    def set_logger(self, logger): self.logger = logger
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def export(self, outfile, level, namespace_='widar:', name_='originator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='originator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='originator'):
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            outfile.write(' thread=%s' % (self.gds_format_string(quote_attrib(self.thread).encode(ExternalEncoding), input_name='thread'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            outfile.write(' componentID=%s' % (self.gds_format_string(quote_attrib(self.componentID).encode(ExternalEncoding), input_name='componentID'), ))
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            outfile.write(' componentType=%s' % (self.gds_format_string(quote_attrib(self.componentType).encode(ExternalEncoding), input_name='componentType'), ))
        if self.logger is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            outfile.write(' logger=%s' % (self.gds_format_string(quote_attrib(self.logger).encode(ExternalEncoding), input_name='logger'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='originator', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='originator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            showIndent(outfile, level)
            outfile.write('thread = "%s",\n' % (self.thread,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            showIndent(outfile, level)
            outfile.write('componentID = "%s",\n' % (self.componentID,))
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            showIndent(outfile, level)
            outfile.write('componentType = "%s",\n' % (self.componentType,))
        if self.logger is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            showIndent(outfile, level)
            outfile.write('logger = "%s",\n' % (self.logger,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = "%s",\n' % (self.method,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            self.thread = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
        value = find_attr_value_('componentID', node)
        if value is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            self.componentID = value
        value = find_attr_value_('componentType', node)
        if value is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            self.componentType = value
        value = find_attr_value_('logger', node)
        if value is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            self.logger = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class originator


class affectedComponent(GeneratedsSuper):
    """The component which is the source of the event or which is affected
    by the event. For example, if a crash is being reported : the
    component that crashed."""
    subclass = None
    superclass = None
    def __init__(self, componentType=None, method=None, componentID=None, thread=None, classxx=None):
        self.componentType = _cast(None, componentType)
        self.method = _cast(None, method)
        self.componentID = _cast(None, componentID)
        self.thread = _cast(None, thread)
        self.classxx = _cast(None, classxx)
        pass
    def factory(*args_, **kwargs_):
        if affectedComponent.subclass:
            return affectedComponent.subclass(*args_, **kwargs_)
        else:
            return affectedComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentType(self): return self.componentType
    def set_componentType(self, componentType): self.componentType = componentType
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_componentID(self): return self.componentID
    def set_componentID(self, componentID): self.componentID = componentID
    def get_thread(self): return self.thread
    def set_thread(self, thread): self.thread = thread
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='widar:', name_='affectedComponent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='affectedComponent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='affectedComponent'):
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            outfile.write(' componentType=%s' % (self.gds_format_string(quote_attrib(self.componentType).encode(ExternalEncoding), input_name='componentType'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            outfile.write(' componentID=%s' % (self.gds_format_string(quote_attrib(self.componentID).encode(ExternalEncoding), input_name='componentID'), ))
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            outfile.write(' thread=%s' % (self.gds_format_string(quote_attrib(self.thread).encode(ExternalEncoding), input_name='thread'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='affectedComponent', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='affectedComponent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            showIndent(outfile, level)
            outfile.write('componentType = "%s",\n' % (self.componentType,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = "%s",\n' % (self.method,))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            showIndent(outfile, level)
            outfile.write('componentID = "%s",\n' % (self.componentID,))
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            showIndent(outfile, level)
            outfile.write('thread = "%s",\n' % (self.thread,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentType', node)
        if value is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            self.componentType = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
        value = find_attr_value_('componentID', node)
        if value is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            self.componentID = value
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            self.thread = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class affectedComponent


class trowable(GeneratedsSuper):
    """Used to log Java exceptions (object trowable)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, message=None, stackTrace=None, trowable=None):
        self.type_ = type_
        self.message = message
        if stackTrace is None:
            self.stackTrace = []
        else:
            self.stackTrace = stackTrace
        if trowable is None:
            self.trowable = []
        else:
            self.trowable = trowable
    def factory(*args_, **kwargs_):
        if trowable.subclass:
            return trowable.subclass(*args_, **kwargs_)
        else:
            return trowable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_stackTrace(self): return self.stackTrace
    def set_stackTrace(self, stackTrace): self.stackTrace = stackTrace
    def add_stackTrace(self, value): self.stackTrace.append(value)
    def insert_stackTrace(self, index, value): self.stackTrace[index] = value
    def get_trowable(self): return self.trowable
    def set_trowable(self, trowable): self.trowable = trowable
    def add_trowable(self, value): self.trowable.append(value)
    def insert_trowable(self, index, value): self.trowable[index] = value
    def export(self, outfile, level, namespace_='widar:', name_='trowable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trowable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='trowable'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='trowable', fromsubclass_=False):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        for stackTrace_ in self.stackTrace:
            showIndent(outfile, level)
            outfile.write('<%sstackTrace>%s</%sstackTrace>\n' % (namespace_, self.gds_format_string(quote_xml(stackTrace_).encode(ExternalEncoding), input_name='stackTrace'), namespace_))
        for trowable_ in self.trowable:
            trowable_.export(outfile, level, namespace_, name_='trowable')
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.message is not None or
            self.stackTrace or
            self.trowable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='trowable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('stackTrace=[\n')
        level += 1
        for stackTrace_ in self.stackTrace:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stackTrace_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('trowable=[\n')
        level += 1
        for trowable_ in self.trowable:
            showIndent(outfile, level)
            outfile.write('model_.trowable(\n')
            trowable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'stackTrace':
            stackTrace_ = child_.text
            stackTrace_ = self.gds_validate_string(stackTrace_, node, 'stackTrace')
            self.stackTrace.append(stackTrace_)
        elif nodeName_ == 'trowable':
            obj_ = trowable.factory()
            obj_.build(child_)
            self.trowable.append(obj_)
# end class trowable


class widarHost(GeneratedsSuper):
    """Set of parameters that unequely define a WIDAR host computer
    (physical device). Obviously, IP address can be used to uniqely
    define a computer system, while type and instance are more
    sutiable as information to be stored for future reference."""
    subclass = None
    superclass = None
    def __init__(self, instance=None, type_=None, destIP4address=None):
        self.instance = _cast(None, instance)
        self.type_ = _cast(None, type_)
        self.destIP4address = _cast(None, destIP4address)
        pass
    def factory(*args_, **kwargs_):
        if widarHost.subclass:
            return widarHost.subclass(*args_, **kwargs_)
        else:
            return widarHost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_destIP4address(self): return self.destIP4address
    def set_destIP4address(self, destIP4address): self.destIP4address = destIP4address
    def export(self, outfile, level, namespace_='widar:', name_='widarHost', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='widarHost')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='widarHost'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            outfile.write(' destIP4address=%s' % (quote_attrib(self.destIP4address), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='widarHost', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='widarHost'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            showIndent(outfile, level)
            outfile.write('destIP4address = %s,\n' % (self.destIP4address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('destIP4address', node)
        if value is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            self.destIP4address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class widarHost


class MsgCommentType(GeneratedsSuper):
    """Decription used in log / alarm messages."""
    subclass = None
    superclass = None
    def __init__(self, code=None, level=None, description=None, property=None):
        self.code = _cast(None, code)
        self.level = _cast(None, level)
        if description is None:
            self.description = []
        else:
            self.description = description
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if MsgCommentType.subclass:
            return MsgCommentType.subclass(*args_, **kwargs_)
        else:
            return MsgCommentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property(self, index, value): self.property[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def export(self, outfile, level, namespace_='widar:', name_='MsgCommentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MsgCommentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='MsgCommentType'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='MsgCommentType', fromsubclass_=False):
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(description_).encode(ExternalEncoding), input_name='description'), namespace_))
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.description or
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MsgCommentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            showIndent(outfile, level)
            outfile.write('code = "%s",\n' % (self.code,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.property(\n')
            property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.append('code')
            self.code = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'property':
            obj_ = property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class MsgCommentType


class property(GeneratedsSuper):
    """Used to report status of the parameters which are not defined in the
    WIDAR XML Schema."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if property.subclass:
            return property.subclass(*args_, **kwargs_)
        else:
            return property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='widar:', name_='property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='property'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='property', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class property


class moduleLocation(GeneratedsSuper):
    """Module Location Id as specified in the System Numbering Plan.
    Defines the physical location of the module."""
    subclass = None
    superclass = None
    def __init__(self, slot=None, crate=None, rack=None):
        self.slot = _cast(None, slot)
        self.crate = _cast(None, crate)
        self.rack = _cast(None, rack)
        pass
    def factory(*args_, **kwargs_):
        if moduleLocation.subclass:
            return moduleLocation.subclass(*args_, **kwargs_)
        else:
            return moduleLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_slot(self): return self.slot
    def set_slot(self, slot): self.slot = slot
    def get_crate(self): return self.crate
    def set_crate(self, crate): self.crate = crate
    def get_rack(self): return self.rack
    def set_rack(self, rack): self.rack = rack
    def export(self, outfile, level, namespace_='widar:', name_='moduleLocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moduleLocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='moduleLocation'):
        if self.slot is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            outfile.write(' slot=%s' % (quote_attrib(self.slot), ))
        if self.crate is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            outfile.write(' crate=%s' % (quote_attrib(self.crate), ))
        if self.rack is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            outfile.write(' rack=%s' % (quote_attrib(self.rack), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='moduleLocation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='moduleLocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.slot is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            showIndent(outfile, level)
            outfile.write('slot = %s,\n' % (self.slot,))
        if self.crate is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            showIndent(outfile, level)
            outfile.write('crate = %s,\n' % (self.crate,))
        if self.rack is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            showIndent(outfile, level)
            outfile.write('rack = %s,\n' % (self.rack,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('slot', node)
        if value is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            self.slot = value
        value = find_attr_value_('crate', node)
        if value is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            self.crate = value
        value = find_attr_value_('rack', node)
        if value is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            self.rack = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class moduleLocation


class inputStateCounts(GeneratedsSuper):
    """control input state count monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if inputStateCounts.subclass:
            return inputStateCounts.subclass(*args_, **kwargs_)
        else:
            return inputStateCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='inputStateCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='inputStateCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='inputStateCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='inputStateCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='inputStateCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class inputStateCounts


class tickIntervalCounts(GeneratedsSuper):
    """control tick interval monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if tickIntervalCounts.subclass:
            return tickIntervalCounts.subclass(*args_, **kwargs_)
        else:
            return tickIntervalCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='tickIntervalCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tickIntervalCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='tickIntervalCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='tickIntervalCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tickIntervalCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tickIntervalCounts


class clipCounts(GeneratedsSuper):
    """control sampler clip monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if clipCounts.subclass:
            return clipCounts.subclass(*args_, **kwargs_)
        else:
            return clipCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='clipCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clipCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='clipCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='clipCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='clipCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clipCounts


class powerCounts(GeneratedsSuper):
    """control power monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if powerCounts.subclass:
            return powerCounts.subclass(*args_, **kwargs_)
        else:
            return powerCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='powerCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='powerCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='powerCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='powerCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='powerCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class powerCounts


class errorCounts(GeneratedsSuper):
    """error counts"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if errorCounts.subclass:
            return errorCounts.subclass(*args_, **kwargs_)
        else:
            return errorCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='errorCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='errorCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='errorCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='errorCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='errorCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class errorCounts


class rfiCounts(GeneratedsSuper):
    """control radio frequency interference monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if rfiCounts.subclass:
            return rfiCounts.subclass(*args_, **kwargs_)
        else:
            return rfiCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='rfiCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rfiCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='rfiCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='rfiCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rfiCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rfiCounts


class outputStateCounts(GeneratedsSuper):
    """control output state count monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if outputStateCounts.subclass:
            return outputStateCounts.subclass(*args_, **kwargs_)
        else:
            return outputStateCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='outputStateCounts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='outputStateCounts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='outputStateCounts'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='outputStateCounts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='outputStateCounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class outputStateCounts


class crcTable(GeneratedsSuper):
    """control CRC status monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, resetAction=None, integFactor='10'):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.resetAction = _cast(None, resetAction)
        self.integFactor = _cast(None, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if crcTable.subclass:
            return crcTable.subclass(*args_, **kwargs_)
        else:
            return crcTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_resetAction(self): return self.resetAction
    def set_resetAction(self, resetAction): self.resetAction = resetAction
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='crcTable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='crcTable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='crcTable'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.resetAction is not None and 'resetAction' not in already_processed:
            already_processed.append('resetAction')
            outfile.write(' resetAction=%s' % (self.gds_format_string(quote_attrib(self.resetAction).encode(ExternalEncoding), input_name='resetAction'), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='crcTable', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='crcTable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.resetAction is not None and 'resetAction' not in already_processed:
            already_processed.append('resetAction')
            showIndent(outfile, level)
            outfile.write('resetAction = "%s",\n' % (self.resetAction,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('resetAction', node)
        if value is not None and 'resetAction' not in already_processed:
            already_processed.append('resetAction')
            self.resetAction = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class crcTable


class toneExtraction(GeneratedsSuper):
    """control CRC status monitoring"""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, numTones=None, integFactor='10', dwellTime=None):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.numTones = _cast(int, numTones)
        self.integFactor = _cast(None, integFactor)
        self.dwellTime = _cast(int, dwellTime)
        pass
    def factory(*args_, **kwargs_):
        if toneExtraction.subclass:
            return toneExtraction.subclass(*args_, **kwargs_)
        else:
            return toneExtraction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_numTones(self): return self.numTones
    def set_numTones(self, numTones): self.numTones = numTones
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_dwellTime(self): return self.dwellTime
    def set_dwellTime(self, dwellTime): self.dwellTime = dwellTime
    def export(self, outfile, level, namespace_='widar:', name_='toneExtraction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='toneExtraction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='toneExtraction'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.numTones is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            outfile.write(' numTones="%s"' % self.gds_format_integer(self.numTones, input_name='numTones'))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            outfile.write(' dwellTime="%s"' % self.gds_format_integer(self.dwellTime, input_name='dwellTime'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='toneExtraction', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='toneExtraction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.numTones is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            showIndent(outfile, level)
            outfile.write('numTones = %d,\n' % (self.numTones,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            showIndent(outfile, level)
            outfile.write('dwellTime = %d,\n' % (self.dwellTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('numTones', node)
        if value is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            try:
                self.numTones = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
        value = find_attr_value_('dwellTime', node)
        if value is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            try:
                self.dwellTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class toneExtraction


class noiseDiode(GeneratedsSuper):
    """Noise Diode configuration."""
    subclass = None
    superclass = None
    def __init__(self, status='enable', phase=0.0, dutyCycle='50.0', periodMilliSec='9.6'):
        self.status = _cast(None, status)
        self.phase = _cast(float, phase)
        self.dutyCycle = _cast(None, dutyCycle)
        self.periodMilliSec = _cast(None, periodMilliSec)
        pass
    def factory(*args_, **kwargs_):
        if noiseDiode.subclass:
            return noiseDiode.subclass(*args_, **kwargs_)
        else:
            return noiseDiode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_dutyCycle(self): return self.dutyCycle
    def set_dutyCycle(self, dutyCycle): self.dutyCycle = dutyCycle
    def get_periodMilliSec(self): return self.periodMilliSec
    def set_periodMilliSec(self, periodMilliSec): self.periodMilliSec = periodMilliSec
    def export(self, outfile, level, namespace_='widar:', name_='noiseDiode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noiseDiode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='noiseDiode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            outfile.write(' phase="%s"' % self.gds_format_double(self.phase, input_name='phase'))
        if self.dutyCycle is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            outfile.write(' dutyCycle=%s' % (quote_attrib(self.dutyCycle), ))
        if self.periodMilliSec is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            outfile.write(' periodMilliSec=%s' % (quote_attrib(self.periodMilliSec), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='noiseDiode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='noiseDiode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            showIndent(outfile, level)
            outfile.write('phase = %e,\n' % (self.phase,))
        if self.dutyCycle is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            showIndent(outfile, level)
            outfile.write('dutyCycle = %s,\n' % (self.dutyCycle,))
        if self.periodMilliSec is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            showIndent(outfile, level)
            outfile.write('periodMilliSec = %s,\n' % (self.periodMilliSec,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            try:
                self.phase = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (phase): %s' % exp)
        value = find_attr_value_('dutyCycle', node)
        if value is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            self.dutyCycle = value
        value = find_attr_value_('periodMilliSec', node)
        if value is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            self.periodMilliSec = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class noiseDiode


class pulsarGating(GeneratedsSuper):
    """Pulsar Gating. Period in milliseconds (or frequency in Hz). Gate
    width is specified as percent of the period (when the gate is
    on). Epoch is specified as UT (or should it be the same as
    activation time)."""
    subclass = None
    superclass = None
    def __init__(self, status='disable', period=None, firstDerivative=None, epoch=None, secondDerivative=None, gateWidth='0.5'):
        self.status = _cast(None, status)
        self.period = _cast(float, period)
        self.firstDerivative = _cast(int, firstDerivative)
        self.epoch = _cast(None, epoch)
        self.secondDerivative = _cast(int, secondDerivative)
        self.gateWidth = _cast(None, gateWidth)
        pass
    def factory(*args_, **kwargs_):
        if pulsarGating.subclass:
            return pulsarGating.subclass(*args_, **kwargs_)
        else:
            return pulsarGating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_firstDerivative(self): return self.firstDerivative
    def set_firstDerivative(self, firstDerivative): self.firstDerivative = firstDerivative
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_secondDerivative(self): return self.secondDerivative
    def set_secondDerivative(self, secondDerivative): self.secondDerivative = secondDerivative
    def get_gateWidth(self): return self.gateWidth
    def set_gateWidth(self, gateWidth): self.gateWidth = gateWidth
    def export(self, outfile, level, namespace_='widar:', name_='pulsarGating', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pulsarGating')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='pulsarGating'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_double(self.period, input_name='period'))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            outfile.write(' firstDerivative="%s"' % self.gds_format_integer(self.firstDerivative, input_name='firstDerivative'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            outfile.write(' secondDerivative="%s"' % self.gds_format_integer(self.secondDerivative, input_name='secondDerivative'))
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            outfile.write(' gateWidth=%s' % (quote_attrib(self.gateWidth), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='pulsarGating', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pulsarGating'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %e,\n' % (self.period,))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            showIndent(outfile, level)
            outfile.write('firstDerivative = %d,\n' % (self.firstDerivative,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            showIndent(outfile, level)
            outfile.write('secondDerivative = %d,\n' % (self.secondDerivative,))
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            showIndent(outfile, level)
            outfile.write('gateWidth = %s,\n' % (self.gateWidth,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (period): %s' % exp)
        value = find_attr_value_('firstDerivative', node)
        if value is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            try:
                self.firstDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('secondDerivative', node)
        if value is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            try:
                self.secondDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gateWidth', node)
        if value is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            self.gateWidth = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pulsarGating


class gateModel(GeneratedsSuper):
    """Model for pulsar gating. Period in milliseconds. Gate width is
    specified as percent of the period (when the gate is on). Epoch
    is specified as UT (or should it be the same as activation
    time)."""
    subclass = None
    superclass = None
    def __init__(self, gateWidth='0.5', period=None, epoch=None):
        self.gateWidth = _cast(None, gateWidth)
        self.period = _cast(float, period)
        self.epoch = _cast(None, epoch)
        pass
    def factory(*args_, **kwargs_):
        if gateModel.subclass:
            return gateModel.subclass(*args_, **kwargs_)
        else:
            return gateModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gateWidth(self): return self.gateWidth
    def set_gateWidth(self, gateWidth): self.gateWidth = gateWidth
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def export(self, outfile, level, namespace_='widar:', name_='gateModel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gateModel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='gateModel'):
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            outfile.write(' gateWidth=%s' % (quote_attrib(self.gateWidth), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_double(self.period, input_name='period'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='gateModel', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gateModel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            showIndent(outfile, level)
            outfile.write('gateWidth = %s,\n' % (self.gateWidth,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %e,\n' % (self.period,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gateWidth', node)
        if value is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            self.gateWidth = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (period): %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gateModel


class modelCoeff(GeneratedsSuper):
    """Coefficent for the gate models is the same as for delay models. This
    format will be used during the testing. When the full system is
    installed ASCII representation may be replaced by hexBinary."""
    subclass = None
    superclass = None
    def __init__(self, cff=None, index=None):
        self.cff = _cast(float, cff)
        self.index = _cast(int, index)
        pass
    def factory(*args_, **kwargs_):
        if modelCoeff.subclass:
            return modelCoeff.subclass(*args_, **kwargs_)
        else:
            return modelCoeff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cff(self): return self.cff
    def set_cff(self, cff): self.cff = cff
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def export(self, outfile, level, namespace_='widar:', name_='modelCoeff', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modelCoeff')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='modelCoeff'):
        if self.cff is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            outfile.write(' cff="%s"' % self.gds_format_double(self.cff, input_name='cff'))
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='modelCoeff', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modelCoeff'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cff is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            showIndent(outfile, level)
            outfile.write('cff = %e,\n' % (self.cff,))
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            showIndent(outfile, level)
            outfile.write('index = %d,\n' % (self.index,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cff', node)
        if value is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            try:
                self.cff = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (cff): %s' % exp)
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.append('index')
            try:
                self.index = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modelCoeff


class wbcProductByBandId(GeneratedsSuper):
    """Wideband Correlator Product. Specifies the product ID and input data
    streams that should be correlated. This format is used when
    there are multiple basebands in a Station Board input data
    stream. Data path and input band identifiers are used to specify
    the product."""
    subclass = None
    superclass = None
    def __init__(self, spectChannels=None, laggedDpId=None, promptDpId=None, promptBandId=None, laggedBandId=None, prodId=None, integFactor=1):
        self.spectChannels = _cast(None, spectChannels)
        self.laggedDpId = _cast(None, laggedDpId)
        self.promptDpId = _cast(None, promptDpId)
        self.promptBandId = _cast(None, promptBandId)
        self.laggedBandId = _cast(None, laggedBandId)
        self.prodId = _cast(None, prodId)
        self.integFactor = _cast(int, integFactor)
        pass
    def factory(*args_, **kwargs_):
        if wbcProductByBandId.subclass:
            return wbcProductByBandId.subclass(*args_, **kwargs_)
        else:
            return wbcProductByBandId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectChannels(self): return self.spectChannels
    def set_spectChannels(self, spectChannels): self.spectChannels = spectChannels
    def get_laggedDpId(self): return self.laggedDpId
    def set_laggedDpId(self, laggedDpId): self.laggedDpId = laggedDpId
    def get_promptDpId(self): return self.promptDpId
    def set_promptDpId(self, promptDpId): self.promptDpId = promptDpId
    def get_promptBandId(self): return self.promptBandId
    def set_promptBandId(self, promptBandId): self.promptBandId = promptBandId
    def get_laggedBandId(self): return self.laggedBandId
    def set_laggedBandId(self, laggedBandId): self.laggedBandId = laggedBandId
    def get_prodId(self): return self.prodId
    def set_prodId(self, prodId): self.prodId = prodId
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def export(self, outfile, level, namespace_='widar:', name_='wbcProductByBandId', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wbcProductByBandId')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wbcProductByBandId'):
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            outfile.write(' spectChannels=%s' % (quote_attrib(self.spectChannels), ))
        if self.laggedDpId is not None and 'laggedDpId' not in already_processed:
            already_processed.append('laggedDpId')
            outfile.write(' laggedDpId=%s' % (quote_attrib(self.laggedDpId), ))
        if self.promptDpId is not None and 'promptDpId' not in already_processed:
            already_processed.append('promptDpId')
            outfile.write(' promptDpId=%s' % (quote_attrib(self.promptDpId), ))
        if self.promptBandId is not None and 'promptBandId' not in already_processed:
            already_processed.append('promptBandId')
            outfile.write(' promptBandId=%s' % (quote_attrib(self.promptBandId), ))
        if self.laggedBandId is not None and 'laggedBandId' not in already_processed:
            already_processed.append('laggedBandId')
            outfile.write(' laggedBandId=%s' % (quote_attrib(self.laggedBandId), ))
        if self.prodId is not None and 'prodId' not in already_processed:
            already_processed.append('prodId')
            outfile.write(' prodId=%s' % (quote_attrib(self.prodId), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor="%s"' % self.gds_format_integer(self.integFactor, input_name='integFactor'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wbcProductByBandId', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wbcProductByBandId'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectChannels is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            showIndent(outfile, level)
            outfile.write('spectChannels = %s,\n' % (self.spectChannels,))
        if self.laggedDpId is not None and 'laggedDpId' not in already_processed:
            already_processed.append('laggedDpId')
            showIndent(outfile, level)
            outfile.write('laggedDpId = %s,\n' % (self.laggedDpId,))
        if self.promptDpId is not None and 'promptDpId' not in already_processed:
            already_processed.append('promptDpId')
            showIndent(outfile, level)
            outfile.write('promptDpId = %s,\n' % (self.promptDpId,))
        if self.promptBandId is not None and 'promptBandId' not in already_processed:
            already_processed.append('promptBandId')
            showIndent(outfile, level)
            outfile.write('promptBandId = %s,\n' % (self.promptBandId,))
        if self.laggedBandId is not None and 'laggedBandId' not in already_processed:
            already_processed.append('laggedBandId')
            showIndent(outfile, level)
            outfile.write('laggedBandId = %s,\n' % (self.laggedBandId,))
        if self.prodId is not None and 'prodId' not in already_processed:
            already_processed.append('prodId')
            showIndent(outfile, level)
            outfile.write('prodId = %s,\n' % (self.prodId,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %d,\n' % (self.integFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectChannels', node)
        if value is not None and 'spectChannels' not in already_processed:
            already_processed.append('spectChannels')
            self.spectChannels = value
        value = find_attr_value_('laggedDpId', node)
        if value is not None and 'laggedDpId' not in already_processed:
            already_processed.append('laggedDpId')
            self.laggedDpId = value
        value = find_attr_value_('promptDpId', node)
        if value is not None and 'promptDpId' not in already_processed:
            already_processed.append('promptDpId')
            self.promptDpId = value
        value = find_attr_value_('promptBandId', node)
        if value is not None and 'promptBandId' not in already_processed:
            already_processed.append('promptBandId')
            self.promptBandId = value
        value = find_attr_value_('laggedBandId', node)
        if value is not None and 'laggedBandId' not in already_processed:
            already_processed.append('laggedBandId')
            self.laggedBandId = value
        value = find_attr_value_('prodId', node)
        if value is not None and 'prodId' not in already_processed:
            already_processed.append('prodId')
            self.prodId = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            try:
                self.integFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wbcProductByBandId


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'vciRequest'
        rootClass = vciRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'vciRequest'
        rootClass = vciRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="vciRequest",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'vciRequest'
        rootClass = vciRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from vcirequest_mcast import *\n\n')
##     sys.stdout.write('import vcirequest_mcast as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "MsgCommentType",
    "actQueue",
    "activationTrigger",
    "affectedComponent",
    "antenna",
    "autoCorrMode",
    "autoCorrSubset",
    "baseBand",
    "baseBandHw",
    "baseline",
    "bb",
    "bbParams",
    "blbPair",
    "blbProdIntegration",
    "blbSingle",
    "burstMode",
    "cc",
    "cfgQueue",
    "clipCounts",
    "cmAlerts",
    "cmDeleteSubarray",
    "cmLogging",
    "cmMonitorControl",
    "component",
    "crcTable",
    "ctrlQueue",
    "errorCounts",
    "gateModel",
    "host",
    "inputStateCounts",
    "listOfStations",
    "modelCoeff",
    "modifySummedArray",
    "moduleLocation",
    "monitorData",
    "noiseDiode",
    "originator",
    "outputStateCounts",
    "polProducts",
    "powerCounts",
    "pp",
    "productPacking",
    "property",
    "pulsarBinning",
    "pulsarGating",
    "queryCfgStatus",
    "radarMode",
    "rfiCounts",
    "sbParams",
    "station",
    "stationHw",
    "stationInputOutput",
    "stationPacking",
    "stbDataProducts",
    "subArray",
    "subBand",
    "summedArray",
    "tickIntervalCounts",
    "toneExtraction",
    "trowable",
    "vciReporting",
    "vciRequest",
    "vdif",
    "wbcPolProduct",
    "wbcProductByBandId",
    "widarHost",
    "wideBandCorrelator"
    ]
