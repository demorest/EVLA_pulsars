#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Jul  9 16:30:59 2015 by generateDS.py version 2.6a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class vciRequest(GeneratedsSuper):
    """VCI Request is a "wrapper" element. A single vciRequest may contain
    configuration for several components and/or stations. vciRequest
    can contain several activationTriggers. Element vciRequest can
    not contain configuration for more than one subarray."""
    subclass = None
    superclass = None
    def __init__(self, msgId=None, desc=None, version='3.18.1', timeStamp=None, stationHw=None, subArray=None, activationTrigger=None, cmMonitorControl=None):
        self.msgId = _cast(int, msgId)
        self.desc = _cast(None, desc)
        self.version = _cast(None, version)
        self.timeStamp = _cast(None, timeStamp)
        if stationHw is None:
            self.stationHw = []
        else:
            self.stationHw = stationHw
        self.subArray = subArray
        if activationTrigger is None:
            self.activationTrigger = []
        else:
            self.activationTrigger = activationTrigger
        self.cmMonitorControl = cmMonitorControl
    def factory(*args_, **kwargs_):
        if vciRequest.subclass:
            return vciRequest.subclass(*args_, **kwargs_)
        else:
            return vciRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stationHw(self): return self.stationHw
    def set_stationHw(self, stationHw): self.stationHw = stationHw
    def add_stationHw(self, value): self.stationHw.append(value)
    def insert_stationHw(self, index, value): self.stationHw[index] = value
    def get_subArray(self): return self.subArray
    def set_subArray(self, subArray): self.subArray = subArray
    def get_activationTrigger(self): return self.activationTrigger
    def set_activationTrigger(self, activationTrigger): self.activationTrigger = activationTrigger
    def add_activationTrigger(self, value): self.activationTrigger.append(value)
    def insert_activationTrigger(self, index, value): self.activationTrigger[index] = value
    def get_cmMonitorControl(self): return self.cmMonitorControl
    def set_cmMonitorControl(self, cmMonitorControl): self.cmMonitorControl = cmMonitorControl
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def export(self, outfile, level, namespace_='widar:', name_='vciRequest', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vciRequest')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vciRequest'):
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.append('desc')
            outfile.write(' desc=%s' % (self.gds_format_string(quote_attrib(self.desc).encode(ExternalEncoding), input_name='desc'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vciRequest', fromsubclass_=False):
        for stationHw_ in self.stationHw:
            stationHw_.export(outfile, level, namespace_, name_='stationHw')
        if self.subArray:
            self.subArray.export(outfile, level, namespace_, name_='subArray')
        for activationTrigger_ in self.activationTrigger:
            activationTrigger_.export(outfile, level, namespace_, name_='activationTrigger')
        if self.cmMonitorControl:
            self.cmMonitorControl.export(outfile, level, namespace_, name_='cmMonitorControl')
    def hasContent_(self):
        if (
            self.stationHw or
            self.subArray is not None or
            self.activationTrigger or
            self.cmMonitorControl is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vciRequest'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.append('desc')
            showIndent(outfile, level)
            outfile.write('desc = "%s",\n' % (self.desc,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = %s,\n' % (self.version,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('stationHw=[\n')
        level += 1
        for stationHw_ in self.stationHw:
            showIndent(outfile, level)
            outfile.write('model_.stationHw(\n')
            stationHw_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.subArray is not None:
            showIndent(outfile, level)
            outfile.write('subArray=model_.subArray(\n')
            self.subArray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('activationTrigger=[\n')
        level += 1
        for activationTrigger_ in self.activationTrigger:
            showIndent(outfile, level)
            outfile.write('model_.activationTrigger(\n')
            activationTrigger_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cmMonitorControl is not None:
            showIndent(outfile, level)
            outfile.write('cmMonitorControl=model_.cmMonitorControl(\n')
            self.cmMonitorControl.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.append('desc')
            self.desc = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stationHw':
            obj_ = stationHw.factory()
            obj_.build(child_)
            self.stationHw.append(obj_)
        elif nodeName_ == 'subArray':
            obj_ = subArray.factory()
            obj_.build(child_)
            self.set_subArray(obj_)
        elif nodeName_ == 'activationTrigger':
            obj_ = activationTrigger.factory()
            obj_.build(child_)
            self.activationTrigger.append(obj_)
        elif nodeName_ == 'cmMonitorControl':
            obj_ = cmMonitorControl.factory()
            obj_.build(child_)
            self.set_cmMonitorControl(obj_)
# end class vciRequest


class activationTrigger(GeneratedsSuper):
    """VCI Configuration Activation Trigger. Activation time for the
    configuration request messages with the same activation
    identifier."""
    subclass = None
    superclass = None
    def __init__(self, rollback='0', msgId=None, timeStamp=None, activationId=None, mappingTime=None, fastSwitching='0', query='no', activationTime=None):
        self.rollback = _cast(None, rollback)
        self.msgId = _cast(int, msgId)
        self.timeStamp = _cast(None, timeStamp)
        self.activationId = _cast(None, activationId)
        self.mappingTime = _cast(None, mappingTime)
        self.fastSwitching = _cast(None, fastSwitching)
        self.query = _cast(None, query)
        self.activationTime = _cast(None, activationTime)
        pass
    def factory(*args_, **kwargs_):
        if activationTrigger.subclass:
            return activationTrigger.subclass(*args_, **kwargs_)
        else:
            return activationTrigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rollback(self): return self.rollback
    def set_rollback(self, rollback): self.rollback = rollback
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_activationId(self): return self.activationId
    def set_activationId(self, activationId): self.activationId = activationId
    def get_mappingTime(self): return self.mappingTime
    def set_mappingTime(self, mappingTime): self.mappingTime = mappingTime
    def get_fastSwitching(self): return self.fastSwitching
    def set_fastSwitching(self, fastSwitching): self.fastSwitching = fastSwitching
    def get_query(self): return self.query
    def set_query(self, query): self.query = query
    def get_activationTime(self): return self.activationTime
    def set_activationTime(self, activationTime): self.activationTime = activationTime
    def export(self, outfile, level, namespace_='widar:', name_='activationTrigger', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activationTrigger')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='activationTrigger'):
        if self.rollback is not None and 'rollback' not in already_processed:
            already_processed.append('rollback')
            outfile.write(' rollback=%s' % (quote_attrib(self.rollback), ))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            outfile.write(' activationId=%s' % (self.gds_format_string(quote_attrib(self.activationId).encode(ExternalEncoding), input_name='activationId'), ))
        if self.mappingTime is not None and 'mappingTime' not in already_processed:
            already_processed.append('mappingTime')
            outfile.write(' mappingTime=%s' % (self.gds_format_string(quote_attrib(self.mappingTime).encode(ExternalEncoding), input_name='mappingTime'), ))
        if self.fastSwitching is not None and 'fastSwitching' not in already_processed:
            already_processed.append('fastSwitching')
            outfile.write(' fastSwitching=%s' % (quote_attrib(self.fastSwitching), ))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            outfile.write(' query=%s' % (quote_attrib(self.query), ))
        if self.activationTime is not None and 'activationTime' not in already_processed:
            already_processed.append('activationTime')
            outfile.write(' activationTime=%s' % (self.gds_format_string(quote_attrib(self.activationTime).encode(ExternalEncoding), input_name='activationTime'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='activationTrigger', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activationTrigger'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rollback is not None and 'rollback' not in already_processed:
            already_processed.append('rollback')
            showIndent(outfile, level)
            outfile.write('rollback = %s,\n' % (self.rollback,))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            showIndent(outfile, level)
            outfile.write('activationId = "%s",\n' % (self.activationId,))
        if self.mappingTime is not None and 'mappingTime' not in already_processed:
            already_processed.append('mappingTime')
            showIndent(outfile, level)
            outfile.write('mappingTime = "%s",\n' % (self.mappingTime,))
        if self.fastSwitching is not None and 'fastSwitching' not in already_processed:
            already_processed.append('fastSwitching')
            showIndent(outfile, level)
            outfile.write('fastSwitching = %s,\n' % (self.fastSwitching,))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            showIndent(outfile, level)
            outfile.write('query = %s,\n' % (self.query,))
        if self.activationTime is not None and 'activationTime' not in already_processed:
            already_processed.append('activationTime')
            showIndent(outfile, level)
            outfile.write('activationTime = "%s",\n' % (self.activationTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rollback', node)
        if value is not None and 'rollback' not in already_processed:
            already_processed.append('rollback')
            self.rollback = value
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
        value = find_attr_value_('activationId', node)
        if value is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            self.activationId = value
        value = find_attr_value_('mappingTime', node)
        if value is not None and 'mappingTime' not in already_processed:
            already_processed.append('mappingTime')
            self.mappingTime = value
        value = find_attr_value_('fastSwitching', node)
        if value is not None and 'fastSwitching' not in already_processed:
            already_processed.append('fastSwitching')
            self.fastSwitching = value
        value = find_attr_value_('query', node)
        if value is not None and 'query' not in already_processed:
            already_processed.append('query')
            self.query = value
        value = find_attr_value_('activationTime', node)
        if value is not None and 'activationTime' not in already_processed:
            already_processed.append('activationTime')
            self.activationTime = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class activationTrigger


class stationHw(GeneratedsSuper):
    """Assigns Station ID to a group of Station Boards that receive input
    from the same antenna. This element assigns Baseband ID to a
    Station Board Data Path. Primary purpose of this element is
    resource allocation. Additional elements and atributes have been
    added, that allow user to specify station specific attributes
    that are not likely to change for every scan: - Antenna ID and
    other antenna parameters, - Noise Diode parameters, - Parameters
    related to generation of monitor data. If, at the Activation
    Time, a station with the same Station ID already exists, it is
    replaced by the new configuration. A (previously configured)
    station that belongs to a subarray cannot be re-configured.
    Station ID and Baseband IDs assigned here are used when
    specifying subarray configuration. July 2012
    Sonja.Vrcic@nrc.gc.ca removed element noiseDiode: --- element
    ref="widar:noiseDiode" minOccurs="0 --- Noise Diode is not set
    via VCI."""
    subclass = None
    superclass = None
    def __init__(self, name=None, timeStamp=None, msgId=None, mappingOrder=None, activationId=None, sid=None, action=None, baseBandHw=None, antenna=None):
        self.name = _cast(None, name)
        self.timeStamp = _cast(None, timeStamp)
        self.msgId = _cast(int, msgId)
        self.mappingOrder = _cast(int, mappingOrder)
        self.activationId = _cast(None, activationId)
        self.sid = _cast(None, sid)
        self.action = _cast(None, action)
        if baseBandHw is None:
            self.baseBandHw = []
        else:
            self.baseBandHw = baseBandHw
        self.antenna = antenna
    def factory(*args_, **kwargs_):
        if stationHw.subclass:
            return stationHw.subclass(*args_, **kwargs_)
        else:
            return stationHw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseBandHw(self): return self.baseBandHw
    def set_baseBandHw(self, baseBandHw): self.baseBandHw = baseBandHw
    def add_baseBandHw(self, value): self.baseBandHw.append(value)
    def insert_baseBandHw(self, index, value): self.baseBandHw[index] = value
    def get_antenna(self): return self.antenna
    def set_antenna(self, antenna): self.antenna = antenna
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_mappingOrder(self): return self.mappingOrder
    def set_mappingOrder(self, mappingOrder): self.mappingOrder = mappingOrder
    def get_activationId(self): return self.activationId
    def set_activationId(self, activationId): self.activationId = activationId
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def export(self, outfile, level, namespace_='widar:', name_='stationHw', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stationHw')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stationHw'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            outfile.write(' mappingOrder="%s"' % self.gds_format_integer(self.mappingOrder, input_name='mappingOrder'))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            outfile.write(' activationId=%s' % (self.gds_format_string(quote_attrib(self.activationId).encode(ExternalEncoding), input_name='activationId'), ))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stationHw', fromsubclass_=False):
        for baseBandHw_ in self.baseBandHw:
            baseBandHw_.export(outfile, level, namespace_, name_='baseBandHw')
        if self.antenna:
            self.antenna.export(outfile, level, namespace_, name_='antenna')
    def hasContent_(self):
        if (
            self.baseBandHw or
            self.antenna is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stationHw'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            showIndent(outfile, level)
            outfile.write('mappingOrder = %d,\n' % (self.mappingOrder,))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            showIndent(outfile, level)
            outfile.write('activationId = "%s",\n' % (self.activationId,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('baseBandHw=[\n')
        level += 1
        for baseBandHw_ in self.baseBandHw:
            showIndent(outfile, level)
            outfile.write('model_.baseBandHw(\n')
            baseBandHw_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.antenna is not None:
            showIndent(outfile, level)
            outfile.write('antenna=model_.antenna(\n')
            self.antenna.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('mappingOrder', node)
        if value is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            try:
                self.mappingOrder = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('activationId', node)
        if value is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            self.activationId = value
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseBandHw':
            obj_ = baseBandHw.factory()
            obj_.build(child_)
            self.baseBandHw.append(obj_)
        elif nodeName_ == 'antenna':
            obj_ = antenna.factory()
            obj_.build(child_)
            self.set_antenna(obj_)
# end class stationHw


class baseBandHw(GeneratedsSuper):
    """Used to: assign Baseband ID to a Station Board Data Path."""
    subclass = None
    superclass = None
    def __init__(self, stationBoardMlid=None, dataPath=None, name=None, bbid=None):
        self.stationBoardMlid = _cast(None, stationBoardMlid)
        self.dataPath = _cast(None, dataPath)
        self.name = _cast(None, name)
        self.bbid = _cast(None, bbid)
        pass
    def factory(*args_, **kwargs_):
        if baseBandHw.subclass:
            return baseBandHw.subclass(*args_, **kwargs_)
        else:
            return baseBandHw(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stationBoardMlid(self): return self.stationBoardMlid
    def set_stationBoardMlid(self, stationBoardMlid): self.stationBoardMlid = stationBoardMlid
    def get_dataPath(self): return self.dataPath
    def set_dataPath(self, dataPath): self.dataPath = dataPath
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_bbid(self): return self.bbid
    def set_bbid(self, bbid): self.bbid = bbid
    def export(self, outfile, level, namespace_='widar:', name_='baseBandHw', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseBandHw')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='baseBandHw'):
        if self.stationBoardMlid is not None and 'stationBoardMlid' not in already_processed:
            already_processed.append('stationBoardMlid')
            outfile.write(' stationBoardMlid=%s' % (self.gds_format_string(quote_attrib(self.stationBoardMlid).encode(ExternalEncoding), input_name='stationBoardMlid'), ))
        if self.dataPath is not None and 'dataPath' not in already_processed:
            already_processed.append('dataPath')
            outfile.write(' dataPath=%s' % (quote_attrib(self.dataPath), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            outfile.write(' bbid=%s' % (quote_attrib(self.bbid), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='baseBandHw', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='baseBandHw'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.stationBoardMlid is not None and 'stationBoardMlid' not in already_processed:
            already_processed.append('stationBoardMlid')
            showIndent(outfile, level)
            outfile.write('stationBoardMlid = "%s",\n' % (self.stationBoardMlid,))
        if self.dataPath is not None and 'dataPath' not in already_processed:
            already_processed.append('dataPath')
            showIndent(outfile, level)
            outfile.write('dataPath = %s,\n' % (self.dataPath,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            showIndent(outfile, level)
            outfile.write('bbid = %s,\n' % (self.bbid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('stationBoardMlid', node)
        if value is not None and 'stationBoardMlid' not in already_processed:
            already_processed.append('stationBoardMlid')
            self.stationBoardMlid = value
        value = find_attr_value_('dataPath', node)
        if value is not None and 'dataPath' not in already_processed:
            already_processed.append('dataPath')
            self.dataPath = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('bbid', node)
        if value is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            self.bbid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class baseBandHw


class subArray(GeneratedsSuper):
    """Subarray Configuration Contains: - list of stations that belong to
    the subarray, - description of input data (basebands), and -
    specification for desired output products. Station IDs and
    BaseBandIDs used here must be defined using element stationHw. A
    station can have up to four baseband pairs or up to 8 single
    basebands. A combination of baseband pairs and singletons is
    also allowed. dtEpoch is epoch for DumpTrig signal. Applies for
    all basebands/subbands. Element modifySummedArray should be
    specified only if action is "modify". Deleted: xs:attribute
    name="targetRqRms" type="xs:string" use="optional"/"""
    subclass = None
    superclass = None
    def __init__(self, subarrayId=None, scanId=None, name=None, msgId=None, reConfigureCompleteBaselineBoards=False, mappingOrder=None, modelErrorReportingThreshold=None, dtEpoch=None, activationId=None, observationTime=None, timeStamp=None, action='create', configId=None, listOfStations=None, stationInputOutput=None, baseline=None, modifySummedArray=None):
        self.subarrayId = _cast(None, subarrayId)
        self.scanId = _cast(None, scanId)
        self.name = _cast(None, name)
        self.msgId = _cast(int, msgId)
        self.reConfigureCompleteBaselineBoards = _cast(bool, reConfigureCompleteBaselineBoards)
        self.mappingOrder = _cast(int, mappingOrder)
        self.modelErrorReportingThreshold = _cast(int, modelErrorReportingThreshold)
        self.dtEpoch = _cast(None, dtEpoch)
        self.activationId = _cast(None, activationId)
        self.observationTime = _cast(None, observationTime)
        self.timeStamp = _cast(None, timeStamp)
        self.action = _cast(None, action)
        self.configId = _cast(None, configId)
        self.listOfStations = listOfStations
        if stationInputOutput is None:
            self.stationInputOutput = []
        else:
            self.stationInputOutput = stationInputOutput
        if baseline is None:
            self.baseline = []
        else:
            self.baseline = baseline
        self.modifySummedArray = modifySummedArray
    def factory(*args_, **kwargs_):
        if subArray.subclass:
            return subArray.subclass(*args_, **kwargs_)
        else:
            return subArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_listOfStations(self): return self.listOfStations
    def set_listOfStations(self, listOfStations): self.listOfStations = listOfStations
    def get_stationInputOutput(self): return self.stationInputOutput
    def set_stationInputOutput(self, stationInputOutput): self.stationInputOutput = stationInputOutput
    def add_stationInputOutput(self, value): self.stationInputOutput.append(value)
    def insert_stationInputOutput(self, index, value): self.stationInputOutput[index] = value
    def get_baseline(self): return self.baseline
    def set_baseline(self, baseline): self.baseline = baseline
    def add_baseline(self, value): self.baseline.append(value)
    def insert_baseline(self, index, value): self.baseline[index] = value
    def get_modifySummedArray(self): return self.modifySummedArray
    def set_modifySummedArray(self, modifySummedArray): self.modifySummedArray = modifySummedArray
    def get_subarrayId(self): return self.subarrayId
    def set_subarrayId(self, subarrayId): self.subarrayId = subarrayId
    def get_scanId(self): return self.scanId
    def set_scanId(self, scanId): self.scanId = scanId
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_msgId(self): return self.msgId
    def set_msgId(self, msgId): self.msgId = msgId
    def get_reConfigureCompleteBaselineBoards(self): return self.reConfigureCompleteBaselineBoards
    def set_reConfigureCompleteBaselineBoards(self, reConfigureCompleteBaselineBoards): self.reConfigureCompleteBaselineBoards = reConfigureCompleteBaselineBoards
    def get_mappingOrder(self): return self.mappingOrder
    def set_mappingOrder(self, mappingOrder): self.mappingOrder = mappingOrder
    def get_modelErrorReportingThreshold(self): return self.modelErrorReportingThreshold
    def set_modelErrorReportingThreshold(self, modelErrorReportingThreshold): self.modelErrorReportingThreshold = modelErrorReportingThreshold
    def get_dtEpoch(self): return self.dtEpoch
    def set_dtEpoch(self, dtEpoch): self.dtEpoch = dtEpoch
    def get_activationId(self): return self.activationId
    def set_activationId(self, activationId): self.activationId = activationId
    def get_observationTime(self): return self.observationTime
    def set_observationTime(self, observationTime): self.observationTime = observationTime
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_configId(self): return self.configId
    def set_configId(self, configId): self.configId = configId
    def export(self, outfile, level, namespace_='widar:', name_='subArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='subArray'):
        if self.subarrayId is not None and 'subarrayId' not in already_processed:
            already_processed.append('subarrayId')
            outfile.write(' subarrayId=%s' % (self.gds_format_string(quote_attrib(self.subarrayId).encode(ExternalEncoding), input_name='subarrayId'), ))
        if self.scanId is not None and 'scanId' not in already_processed:
            already_processed.append('scanId')
            outfile.write(' scanId=%s' % (self.gds_format_string(quote_attrib(self.scanId).encode(ExternalEncoding), input_name='scanId'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            outfile.write(' msgId="%s"' % self.gds_format_integer(self.msgId, input_name='msgId'))
        if self.reConfigureCompleteBaselineBoards is not None and 'reConfigureCompleteBaselineBoards' not in already_processed:
            already_processed.append('reConfigureCompleteBaselineBoards')
            outfile.write(' reConfigureCompleteBaselineBoards="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.reConfigureCompleteBaselineBoards)), input_name='reConfigureCompleteBaselineBoards'))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            outfile.write(' mappingOrder="%s"' % self.gds_format_integer(self.mappingOrder, input_name='mappingOrder'))
        if self.modelErrorReportingThreshold is not None and 'modelErrorReportingThreshold' not in already_processed:
            already_processed.append('modelErrorReportingThreshold')
            outfile.write(' modelErrorReportingThreshold="%s"' % self.gds_format_integer(self.modelErrorReportingThreshold, input_name='modelErrorReportingThreshold'))
        if self.dtEpoch is not None and 'dtEpoch' not in already_processed:
            already_processed.append('dtEpoch')
            outfile.write(' dtEpoch=%s' % (self.gds_format_string(quote_attrib(self.dtEpoch).encode(ExternalEncoding), input_name='dtEpoch'), ))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            outfile.write(' activationId=%s' % (self.gds_format_string(quote_attrib(self.activationId).encode(ExternalEncoding), input_name='activationId'), ))
        if self.observationTime is not None and 'observationTime' not in already_processed:
            already_processed.append('observationTime')
            outfile.write(' observationTime=%s' % (self.gds_format_string(quote_attrib(self.observationTime).encode(ExternalEncoding), input_name='observationTime'), ))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            outfile.write(' timeStamp=%s' % (self.gds_format_string(quote_attrib(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            outfile.write(' configId=%s' % (self.gds_format_string(quote_attrib(self.configId).encode(ExternalEncoding), input_name='configId'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='subArray', fromsubclass_=False):
        if self.listOfStations:
            self.listOfStations.export(outfile, level, namespace_, name_='listOfStations')
        for stationInputOutput_ in self.stationInputOutput:
            stationInputOutput_.export(outfile, level, namespace_, name_='stationInputOutput')
        for baseline_ in self.baseline:
            baseline_.export(outfile, level, namespace_, name_='baseline')
        if self.modifySummedArray:
            self.modifySummedArray.export(outfile, level, namespace_, name_='modifySummedArray')
    def hasContent_(self):
        if (
            self.listOfStations is not None or
            self.stationInputOutput or
            self.baseline or
            self.modifySummedArray is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subarrayId is not None and 'subarrayId' not in already_processed:
            already_processed.append('subarrayId')
            showIndent(outfile, level)
            outfile.write('subarrayId = "%s",\n' % (self.subarrayId,))
        if self.scanId is not None and 'scanId' not in already_processed:
            already_processed.append('scanId')
            showIndent(outfile, level)
            outfile.write('scanId = "%s",\n' % (self.scanId,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.msgId is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            showIndent(outfile, level)
            outfile.write('msgId = %d,\n' % (self.msgId,))
        if self.reConfigureCompleteBaselineBoards is not None and 'reConfigureCompleteBaselineBoards' not in already_processed:
            already_processed.append('reConfigureCompleteBaselineBoards')
            showIndent(outfile, level)
            outfile.write('reConfigureCompleteBaselineBoards = %s,\n' % (self.reConfigureCompleteBaselineBoards,))
        if self.mappingOrder is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            showIndent(outfile, level)
            outfile.write('mappingOrder = %d,\n' % (self.mappingOrder,))
        if self.modelErrorReportingThreshold is not None and 'modelErrorReportingThreshold' not in already_processed:
            already_processed.append('modelErrorReportingThreshold')
            showIndent(outfile, level)
            outfile.write('modelErrorReportingThreshold = %d,\n' % (self.modelErrorReportingThreshold,))
        if self.dtEpoch is not None and 'dtEpoch' not in already_processed:
            already_processed.append('dtEpoch')
            showIndent(outfile, level)
            outfile.write('dtEpoch = "%s",\n' % (self.dtEpoch,))
        if self.activationId is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            showIndent(outfile, level)
            outfile.write('activationId = "%s",\n' % (self.activationId,))
        if self.observationTime is not None and 'observationTime' not in already_processed:
            already_processed.append('observationTime')
            showIndent(outfile, level)
            outfile.write('observationTime = "%s",\n' % (self.observationTime,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp = "%s",\n' % (self.timeStamp,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            showIndent(outfile, level)
            outfile.write('configId = "%s",\n' % (self.configId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.listOfStations is not None:
            showIndent(outfile, level)
            outfile.write('listOfStations=model_.listOfStations(\n')
            self.listOfStations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stationInputOutput=[\n')
        level += 1
        for stationInputOutput_ in self.stationInputOutput:
            showIndent(outfile, level)
            outfile.write('model_.stationInputOutput(\n')
            stationInputOutput_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('baseline=[\n')
        level += 1
        for baseline_ in self.baseline:
            showIndent(outfile, level)
            outfile.write('model_.baseline(\n')
            baseline_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.modifySummedArray is not None:
            showIndent(outfile, level)
            outfile.write('modifySummedArray=model_.modifySummedArray(\n')
            self.modifySummedArray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subarrayId', node)
        if value is not None and 'subarrayId' not in already_processed:
            already_processed.append('subarrayId')
            self.subarrayId = value
        value = find_attr_value_('scanId', node)
        if value is not None and 'scanId' not in already_processed:
            already_processed.append('scanId')
            self.scanId = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('msgId', node)
        if value is not None and 'msgId' not in already_processed:
            already_processed.append('msgId')
            try:
                self.msgId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('reConfigureCompleteBaselineBoards', node)
        if value is not None and 'reConfigureCompleteBaselineBoards' not in already_processed:
            already_processed.append('reConfigureCompleteBaselineBoards')
            if value in ('true', '1'):
                self.reConfigureCompleteBaselineBoards = True
            elif value in ('false', '0'):
                self.reConfigureCompleteBaselineBoards = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('mappingOrder', node)
        if value is not None and 'mappingOrder' not in already_processed:
            already_processed.append('mappingOrder')
            try:
                self.mappingOrder = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('modelErrorReportingThreshold', node)
        if value is not None and 'modelErrorReportingThreshold' not in already_processed:
            already_processed.append('modelErrorReportingThreshold')
            try:
                self.modelErrorReportingThreshold = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dtEpoch', node)
        if value is not None and 'dtEpoch' not in already_processed:
            already_processed.append('dtEpoch')
            self.dtEpoch = value
        value = find_attr_value_('activationId', node)
        if value is not None and 'activationId' not in already_processed:
            already_processed.append('activationId')
            self.activationId = value
        value = find_attr_value_('observationTime', node)
        if value is not None and 'observationTime' not in already_processed:
            already_processed.append('observationTime')
            self.observationTime = value
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.append('timeStamp')
            self.timeStamp = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('configId', node)
        if value is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            self.configId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'listOfStations':
            obj_ = listOfStations.factory()
            obj_.build(child_)
            self.set_listOfStations(obj_)
        elif nodeName_ == 'stationInputOutput':
            obj_ = stationInputOutput.factory()
            obj_.build(child_)
            self.stationInputOutput.append(obj_)
        elif nodeName_ == 'baseline':
            obj_ = baseline.factory()
            obj_.build(child_)
            self.baseline.append(obj_)
        elif nodeName_ == 'modifySummedArray':
            obj_ = modifySummedArray.factory()
            obj_.build(child_)
            self.set_modifySummedArray(obj_)
# end class subArray


class listOfStations(GeneratedsSuper):
    """List of stations that belong to the subarray. Only known stations
    (i.e. stations that were previously defined using stationHw) can
    be listed here."""
    subclass = None
    superclass = None
    def __init__(self, action='add', station=None):
        self.action = _cast(None, action)
        if station is None:
            self.station = []
        else:
            self.station = station
    def factory(*args_, **kwargs_):
        if listOfStations.subclass:
            return listOfStations.subclass(*args_, **kwargs_)
        else:
            return listOfStations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def add_station(self, value): self.station.append(value)
    def insert_station(self, index, value): self.station[index] = value
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def export(self, outfile, level, namespace_='widar:', name_='listOfStations', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='listOfStations')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='listOfStations'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='listOfStations', fromsubclass_=False):
        for station_ in self.station:
            station_.export(outfile, level, namespace_, name_='station')
    def hasContent_(self):
        if (
            self.station
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='listOfStations'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('station=[\n')
        level += 1
        for station_ in self.station:
            showIndent(outfile, level)
            outfile.write('model_.station(\n')
            station_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'station':
            obj_ = station.factory()
            obj_.build(child_)
            self.station.append(obj_)
# end class listOfStations


class station(GeneratedsSuper):
    """Element station is used to specify the list of stations (antennas)
    that belong to a subarray. The list of stations can be specified
    either in subarray/listOfStations or in
    subarray/stationInputOutput. Preffered use: subarrayInputOutput.
    (Subarray/listOfStations is the older version preserved for
    backwards compatibility.) The only attributes (other than name)
    that can be specified in this element are Local Oscillator and
    Frequency Shift. These parameters are different for each
    antenna. Normally, Local Oscillator and Frequency Shift are
    specified in the delay models, but, for testing purposes they
    can be specified here. LO and Frequency Shift can be specified
    in: - VCI screate subarray, - VCI modify subarray, or - STB
    Delay Models."""
    subclass = None
    superclass = None
    def __init__(self, action=None, name=None, sid=None, bb=None):
        self.action = _cast(None, action)
        self.name = _cast(None, name)
        self.sid = _cast(None, sid)
        if bb is None:
            self.bb = []
        else:
            self.bb = bb
    def factory(*args_, **kwargs_):
        if station.subclass:
            return station.subclass(*args_, **kwargs_)
        else:
            return station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bb(self): return self.bb
    def set_bb(self, bb): self.bb = bb
    def add_bb(self, value): self.bb.append(value)
    def insert_bb(self, index, value): self.bb[index] = value
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def export(self, outfile, level, namespace_='widar:', name_='station', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='station')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='station'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='station', fromsubclass_=False):
        for bb_ in self.bb:
            bb_.export(outfile, level, namespace_, name_='bb')
    def hasContent_(self):
        if (
            self.bb
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='station'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bb=[\n')
        level += 1
        for bb_ in self.bb:
            showIndent(outfile, level)
            outfile.write('model_.bb(\n')
            bb_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bb':
            obj_ = bb.factory()
            obj_.build(child_)
            self.bb.append(obj_)
# end class station


class bb(GeneratedsSuper):
    """Baseband parameters that are different for each antenna (station)."""
    subclass = None
    superclass = None
    def __init__(self, freqShift=None, localOsc=None, bbid=None):
        self.freqShift = _cast(float, freqShift)
        self.localOsc = _cast(float, localOsc)
        self.bbid = _cast(None, bbid)
        pass
    def factory(*args_, **kwargs_):
        if bb.subclass:
            return bb.subclass(*args_, **kwargs_)
        else:
            return bb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_freqShift(self): return self.freqShift
    def set_freqShift(self, freqShift): self.freqShift = freqShift
    def get_localOsc(self): return self.localOsc
    def set_localOsc(self, localOsc): self.localOsc = localOsc
    def get_bbid(self): return self.bbid
    def set_bbid(self, bbid): self.bbid = bbid
    def export(self, outfile, level, namespace_='widar:', name_='bb', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bb')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='bb'):
        if self.freqShift is not None and 'freqShift' not in already_processed:
            already_processed.append('freqShift')
            outfile.write(' freqShift="%s"' % self.gds_format_double(self.freqShift, input_name='freqShift'))
        if self.localOsc is not None and 'localOsc' not in already_processed:
            already_processed.append('localOsc')
            outfile.write(' localOsc="%s"' % self.gds_format_double(self.localOsc, input_name='localOsc'))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            outfile.write(' bbid=%s' % (quote_attrib(self.bbid), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='bb', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bb'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.freqShift is not None and 'freqShift' not in already_processed:
            already_processed.append('freqShift')
            showIndent(outfile, level)
            outfile.write('freqShift = %e,\n' % (self.freqShift,))
        if self.localOsc is not None and 'localOsc' not in already_processed:
            already_processed.append('localOsc')
            showIndent(outfile, level)
            outfile.write('localOsc = %e,\n' % (self.localOsc,))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            showIndent(outfile, level)
            outfile.write('bbid = %s,\n' % (self.bbid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('freqShift', node)
        if value is not None and 'freqShift' not in already_processed:
            already_processed.append('freqShift')
            try:
                self.freqShift = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (freqShift): %s' % exp)
        value = find_attr_value_('localOsc', node)
        if value is not None and 'localOsc' not in already_processed:
            already_processed.append('localOsc')
            try:
                self.localOsc = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (localOsc): %s' % exp)
        value = find_attr_value_('bbid', node)
        if value is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            self.bbid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bb


class bbParams(GeneratedsSuper):
    """This element can be used to specify parameters for individual
    Basebands. The parameters (attributes) specified here can be
    different for Basebands that belong to the same pair. Typically,
    these parameters are same for all the stations in a subarray,
    but they can be specified for each station individually. Removed
    attributes: xs:attribute name="fshift_kHz" type="xs:double"
    use="optional" xs:attribute name="lo_o_MHz" type="xs:double"
    use="optional" """
    subclass = None
    superclass = None
    def __init__(self, sourceType=None, sourceId=None, sideband=None, bbid=None, polarization=None, phaseModelInsertion=None, sbParams=None):
        self.sourceType = _cast(None, sourceType)
        self.sourceId = _cast(None, sourceId)
        self.sideband = _cast(None, sideband)
        self.bbid = _cast(None, bbid)
        self.polarization = _cast(None, polarization)
        self.phaseModelInsertion = _cast(None, phaseModelInsertion)
        if sbParams is None:
            self.sbParams = []
        else:
            self.sbParams = sbParams
    def factory(*args_, **kwargs_):
        if bbParams.subclass:
            return bbParams.subclass(*args_, **kwargs_)
        else:
            return bbParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sbParams(self): return self.sbParams
    def set_sbParams(self, sbParams): self.sbParams = sbParams
    def add_sbParams(self, value): self.sbParams.append(value)
    def insert_sbParams(self, index, value): self.sbParams[index] = value
    def get_sourceType(self): return self.sourceType
    def set_sourceType(self, sourceType): self.sourceType = sourceType
    def get_sourceId(self): return self.sourceId
    def set_sourceId(self, sourceId): self.sourceId = sourceId
    def get_sideband(self): return self.sideband
    def set_sideband(self, sideband): self.sideband = sideband
    def get_bbid(self): return self.bbid
    def set_bbid(self, bbid): self.bbid = bbid
    def get_polarization(self): return self.polarization
    def set_polarization(self, polarization): self.polarization = polarization
    def get_phaseModelInsertion(self): return self.phaseModelInsertion
    def set_phaseModelInsertion(self, phaseModelInsertion): self.phaseModelInsertion = phaseModelInsertion
    def export(self, outfile, level, namespace_='widar:', name_='bbParams', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bbParams')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='bbParams'):
        if self.sourceType is not None and 'sourceType' not in already_processed:
            already_processed.append('sourceType')
            outfile.write(' sourceType=%s' % (quote_attrib(self.sourceType), ))
        if self.sourceId is not None and 'sourceId' not in already_processed:
            already_processed.append('sourceId')
            outfile.write(' sourceId=%s' % (quote_attrib(self.sourceId), ))
        if self.sideband is not None and 'sideband' not in already_processed:
            already_processed.append('sideband')
            outfile.write(' sideband=%s' % (quote_attrib(self.sideband), ))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            outfile.write(' bbid=%s' % (quote_attrib(self.bbid), ))
        if self.polarization is not None and 'polarization' not in already_processed:
            already_processed.append('polarization')
            outfile.write(' polarization=%s' % (quote_attrib(self.polarization), ))
        if self.phaseModelInsertion is not None and 'phaseModelInsertion' not in already_processed:
            already_processed.append('phaseModelInsertion')
            outfile.write(' phaseModelInsertion=%s' % (quote_attrib(self.phaseModelInsertion), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='bbParams', fromsubclass_=False):
        for sbParams_ in self.sbParams:
            sbParams_.export(outfile, level, namespace_, name_='sbParams')
    def hasContent_(self):
        if (
            self.sbParams
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bbParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceType is not None and 'sourceType' not in already_processed:
            already_processed.append('sourceType')
            showIndent(outfile, level)
            outfile.write('sourceType = %s,\n' % (self.sourceType,))
        if self.sourceId is not None and 'sourceId' not in already_processed:
            already_processed.append('sourceId')
            showIndent(outfile, level)
            outfile.write('sourceId = %s,\n' % (self.sourceId,))
        if self.sideband is not None and 'sideband' not in already_processed:
            already_processed.append('sideband')
            showIndent(outfile, level)
            outfile.write('sideband = %s,\n' % (self.sideband,))
        if self.bbid is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            showIndent(outfile, level)
            outfile.write('bbid = %s,\n' % (self.bbid,))
        if self.polarization is not None and 'polarization' not in already_processed:
            already_processed.append('polarization')
            showIndent(outfile, level)
            outfile.write('polarization = %s,\n' % (self.polarization,))
        if self.phaseModelInsertion is not None and 'phaseModelInsertion' not in already_processed:
            already_processed.append('phaseModelInsertion')
            showIndent(outfile, level)
            outfile.write('phaseModelInsertion = %s,\n' % (self.phaseModelInsertion,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('sbParams=[\n')
        level += 1
        for sbParams_ in self.sbParams:
            showIndent(outfile, level)
            outfile.write('model_.sbParams(\n')
            sbParams_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceType', node)
        if value is not None and 'sourceType' not in already_processed:
            already_processed.append('sourceType')
            self.sourceType = value
        value = find_attr_value_('sourceId', node)
        if value is not None and 'sourceId' not in already_processed:
            already_processed.append('sourceId')
            self.sourceId = value
        value = find_attr_value_('sideband', node)
        if value is not None and 'sideband' not in already_processed:
            already_processed.append('sideband')
            self.sideband = value
        value = find_attr_value_('bbid', node)
        if value is not None and 'bbid' not in already_processed:
            already_processed.append('bbid')
            self.bbid = value
        value = find_attr_value_('polarization', node)
        if value is not None and 'polarization' not in already_processed:
            already_processed.append('polarization')
            self.polarization = value
        value = find_attr_value_('phaseModelInsertion', node)
        if value is not None and 'phaseModelInsertion' not in already_processed:
            already_processed.append('phaseModelInsertion')
            self.phaseModelInsertion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sbParams':
            obj_ = sbParams.factory()
            obj_.build(child_)
            self.sbParams.append(obj_)
# end class bbParams


class sbParams(GeneratedsSuper):
    """This element is a child of the element bbParams and will be
    specified for each Baseband individually (not for a Baseband
    pair). Tone extraction and radar mode will typically be set the
    same way for all the stations in a subarray, but can be
    specified for individual stations, if needed. Normally, Station
    Board filter will be selected by the correlator software. User
    may want to explicitely specify the Filter ID during the testing
    or to awoid use of the damaged hardware."""
    subclass = None
    superclass = None
    def __init__(self, sbid=None, filter=None, name=None, radarMode=None, toneExtraction=None):
        self.sbid = _cast(None, sbid)
        self.filter = _cast(None, filter)
        self.name = _cast(None, name)
        self.radarMode = radarMode
        self.toneExtraction = toneExtraction
    def factory(*args_, **kwargs_):
        if sbParams.subclass:
            return sbParams.subclass(*args_, **kwargs_)
        else:
            return sbParams(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_radarMode(self): return self.radarMode
    def set_radarMode(self, radarMode): self.radarMode = radarMode
    def get_toneExtraction(self): return self.toneExtraction
    def set_toneExtraction(self, toneExtraction): self.toneExtraction = toneExtraction
    def get_sbid(self): return self.sbid
    def set_sbid(self, sbid): self.sbid = sbid
    def get_filter(self): return self.filter
    def set_filter(self, filter): self.filter = filter
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='sbParams', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sbParams')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='sbParams'):
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            outfile.write(' sbid=%s' % (quote_attrib(self.sbid), ))
        if self.filter is not None and 'filter' not in already_processed:
            already_processed.append('filter')
            outfile.write(' filter=%s' % (quote_attrib(self.filter), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='sbParams', fromsubclass_=False):
        if self.radarMode:
            self.radarMode.export(outfile, level, namespace_, name_='radarMode')
        if self.toneExtraction:
            self.toneExtraction.export(outfile, level, namespace_, name_='toneExtraction')
    def hasContent_(self):
        if (
            self.radarMode is not None or
            self.toneExtraction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sbParams'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            showIndent(outfile, level)
            outfile.write('sbid = %s,\n' % (self.sbid,))
        if self.filter is not None and 'filter' not in already_processed:
            already_processed.append('filter')
            showIndent(outfile, level)
            outfile.write('filter = %s,\n' % (self.filter,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.radarMode is not None:
            showIndent(outfile, level)
            outfile.write('radarMode=model_.radarMode(\n')
            self.radarMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.toneExtraction is not None:
            showIndent(outfile, level)
            outfile.write('toneExtraction=model_.toneExtraction(\n')
            self.toneExtraction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sbid', node)
        if value is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            self.sbid = value
        value = find_attr_value_('filter', node)
        if value is not None and 'filter' not in already_processed:
            already_processed.append('filter')
            self.filter = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'radarMode':
            obj_ = radarMode.factory()
            obj_.build(child_)
            self.set_radarMode(obj_)
        elif nodeName_ == 'toneExtraction':
            obj_ = toneExtraction.factory()
            obj_.build(child_)
            self.set_toneExtraction(obj_)
# end class sbParams


class stationInputOutput(GeneratedsSuper):
    """Specification of input and output data: baseband parameters, for
    each baseband (pair) the list of subbands, for each subband the
    list of desired products. VCI Client may specify
    stationInputOutput for each station individually, or use id=ALL
    to apply the same configuration to all the stations in the
    subarray. Element subarray may have one element
    stationInputOutput that defines configuration for all the
    stations, and one or more elements stationInputOutput that
    define configuration for stations that are not exactly the same
    as others. Station ID and Baseband IDs used here must be already
    defined using stationHw."""
    subclass = None
    superclass = None
    def __init__(self, name=None, sid='all', station=None, bbParams=None, baseBand=None):
        self.name = _cast(None, name)
        self.sid = _cast(None, sid)
        if station is None:
            self.station = []
        else:
            self.station = station
        if bbParams is None:
            self.bbParams = []
        else:
            self.bbParams = bbParams
        if baseBand is None:
            self.baseBand = []
        else:
            self.baseBand = baseBand
    def factory(*args_, **kwargs_):
        if stationInputOutput.subclass:
            return stationInputOutput.subclass(*args_, **kwargs_)
        else:
            return stationInputOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_station(self): return self.station
    def set_station(self, station): self.station = station
    def add_station(self, value): self.station.append(value)
    def insert_station(self, index, value): self.station[index] = value
    def get_bbParams(self): return self.bbParams
    def set_bbParams(self, bbParams): self.bbParams = bbParams
    def add_bbParams(self, value): self.bbParams.append(value)
    def insert_bbParams(self, index, value): self.bbParams[index] = value
    def get_baseBand(self): return self.baseBand
    def set_baseBand(self, baseBand): self.baseBand = baseBand
    def add_baseBand(self, value): self.baseBand.append(value)
    def insert_baseBand(self, index, value): self.baseBand[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def export(self, outfile, level, namespace_='widar:', name_='stationInputOutput', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stationInputOutput')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stationInputOutput'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (self.gds_format_string(quote_attrib(self.sid).encode(ExternalEncoding), input_name='sid'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stationInputOutput', fromsubclass_=False):
        for station_ in self.station:
            station_.export(outfile, level, namespace_, name_='station')
        for bbParams_ in self.bbParams:
            bbParams_.export(outfile, level, namespace_, name_='bbParams')
        for baseBand_ in self.baseBand:
            baseBand_.export(outfile, level, namespace_, name_='baseBand')
    def hasContent_(self):
        if (
            self.station or
            self.bbParams or
            self.baseBand
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stationInputOutput'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = "%s",\n' % (self.sid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('station=[\n')
        level += 1
        for station_ in self.station:
            showIndent(outfile, level)
            outfile.write('model_.station(\n')
            station_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('bbParams=[\n')
        level += 1
        for bbParams_ in self.bbParams:
            showIndent(outfile, level)
            outfile.write('model_.bbParams(\n')
            bbParams_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('baseBand=[\n')
        level += 1
        for baseBand_ in self.baseBand:
            showIndent(outfile, level)
            outfile.write('model_.baseBand(\n')
            baseBand_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'station':
            obj_ = station.factory()
            obj_.build(child_)
            self.station.append(obj_)
        elif nodeName_ == 'bbParams':
            obj_ = bbParams.factory()
            obj_.build(child_)
            self.bbParams.append(obj_)
        elif nodeName_ == 'baseBand':
            obj_ = baseBand.factory()
            obj_.build(child_)
            self.baseBand.append(obj_)
# end class stationInputOutput


class baseBand(GeneratedsSuper):
    """swbbName is BaseBand name for Spectral Window (BDF), swbbName is
    forwarded to CBE (BDF) and to Station Boards, so that it can be
    inserted into output related to switched power (power counts).
    swPwrEpoch - epoch for data related to switched power data
    generated by Station Board, if not specified as as DumpTrig
    epoch. swPwrInteg - integration time for switched power data
    generated by Station Board, if not specified, same as LTA dump
    time. Specified in milliseconds, value must be in hundreds of
    milliseconds. defaultFilterGain - If present, set default values
    for active filter stages Default values for filter gain are
    determined by CMIB software based on filter setup. "Target RMS",
    if specified, will override filter gains set as result of this
    attribute. In other words, either this attribute or "target RMS"
    should be specified. Howver, it is possible to set
    "defaultFilterGain" for all the stages and re-quantizer, and
    then adjust gain only for a subset of stages. requantRms -
    Target RMS for re-qunatizer. If specified, invoke filter gain
    adjustment to get output RMS as specified. stage1Rms - Target
    RMS for filter stage 1. If specified, invoke filter gain
    adjustment to get output RMS as specified by this attribute.
    stage2Rms - Target RMS for filter stage 2. If specified, invoke
    filter gain adjustment to get output RMS as specified by this
    attribute. stage3Rms - Target RMS for filter stage 3. If
    specified, invoke filter gain adjustment to get output RMS as
    specified by this attribute. stage4Rms - Target RMS for filter
    stage 4. If specified, invoke filter gain adjustment to get
    output RMS as specified by this attribute. bininningPeriod - in
    microseconds, to be specified only if phase binning is used for
    at last one subband. binMaxHwIntegTime - relevant only when
    phase bining is used. If not specified CMIB uses the default
    value of 500 nano seconds. Station ID, if specified here
    overrides the Station ID specified in the parent element. This
    may be used in configurations other than EVLA and perhaps for
    testing."""
    subclass = None
    superclass = None
    def __init__(self, binMaxHwIntegTime=None, swPwrEpoch=None, delayModelsValid=1, name=None, swbbName=None, defaultFilterGain=None, stage2Rms=None, bbB=None, bbA=None, binningPeriod=None, noWbcProducts=None, requantRms=None, bw=None, swPwrInteg=None, sid=None, singlePhaseCenter='yes', stage1Rms=None, stage3Rms=None, inQuant=None, stage4Rms=None, phaseBinning=None, subBand=None, wpp=None, gating=None):
        self.binMaxHwIntegTime = _cast(float, binMaxHwIntegTime)
        self.swPwrEpoch = _cast(None, swPwrEpoch)
        self.delayModelsValid = _cast(int, delayModelsValid)
        self.name = _cast(None, name)
        self.swbbName = _cast(None, swbbName)
        self.defaultFilterGain = _cast(None, defaultFilterGain)
        self.stage2Rms = _cast(float, stage2Rms)
        self.bbB = _cast(None, bbB)
        self.bbA = _cast(None, bbA)
        self.binningPeriod = _cast(float, binningPeriod)
        self.noWbcProducts = _cast(None, noWbcProducts)
        self.requantRms = _cast(float, requantRms)
        self.bw = _cast(None, bw)
        self.swPwrInteg = _cast(int, swPwrInteg)
        self.sid = _cast(None, sid)
        self.singlePhaseCenter = _cast(None, singlePhaseCenter)
        self.stage1Rms = _cast(float, stage1Rms)
        self.stage3Rms = _cast(float, stage3Rms)
        self.inQuant = _cast(None, inQuant)
        self.stage4Rms = _cast(float, stage4Rms)
        if phaseBinning is None:
            self.phaseBinning = []
        else:
            self.phaseBinning = phaseBinning
        if subBand is None:
            self.subBand = []
        else:
            self.subBand = subBand
        if wpp is None:
            self.wpp = []
        else:
            self.wpp = wpp
        self.gating = gating
    def factory(*args_, **kwargs_):
        if baseBand.subclass:
            return baseBand.subclass(*args_, **kwargs_)
        else:
            return baseBand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phaseBinning(self): return self.phaseBinning
    def set_phaseBinning(self, phaseBinning): self.phaseBinning = phaseBinning
    def add_phaseBinning(self, value): self.phaseBinning.append(value)
    def insert_phaseBinning(self, index, value): self.phaseBinning[index] = value
    def get_subBand(self): return self.subBand
    def set_subBand(self, subBand): self.subBand = subBand
    def add_subBand(self, value): self.subBand.append(value)
    def insert_subBand(self, index, value): self.subBand[index] = value
    def get_wpp(self): return self.wpp
    def set_wpp(self, wpp): self.wpp = wpp
    def add_wpp(self, value): self.wpp.append(value)
    def insert_wpp(self, index, value): self.wpp[index] = value
    def get_gating(self): return self.gating
    def set_gating(self, gating): self.gating = gating
    def get_binMaxHwIntegTime(self): return self.binMaxHwIntegTime
    def set_binMaxHwIntegTime(self, binMaxHwIntegTime): self.binMaxHwIntegTime = binMaxHwIntegTime
    def get_swPwrEpoch(self): return self.swPwrEpoch
    def set_swPwrEpoch(self, swPwrEpoch): self.swPwrEpoch = swPwrEpoch
    def get_delayModelsValid(self): return self.delayModelsValid
    def set_delayModelsValid(self, delayModelsValid): self.delayModelsValid = delayModelsValid
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_swbbName(self): return self.swbbName
    def set_swbbName(self, swbbName): self.swbbName = swbbName
    def get_defaultFilterGain(self): return self.defaultFilterGain
    def set_defaultFilterGain(self, defaultFilterGain): self.defaultFilterGain = defaultFilterGain
    def get_stage2Rms(self): return self.stage2Rms
    def set_stage2Rms(self, stage2Rms): self.stage2Rms = stage2Rms
    def get_bbB(self): return self.bbB
    def set_bbB(self, bbB): self.bbB = bbB
    def get_bbA(self): return self.bbA
    def set_bbA(self, bbA): self.bbA = bbA
    def get_binningPeriod(self): return self.binningPeriod
    def set_binningPeriod(self, binningPeriod): self.binningPeriod = binningPeriod
    def get_noWbcProducts(self): return self.noWbcProducts
    def set_noWbcProducts(self, noWbcProducts): self.noWbcProducts = noWbcProducts
    def get_requantRms(self): return self.requantRms
    def set_requantRms(self, requantRms): self.requantRms = requantRms
    def get_bw(self): return self.bw
    def set_bw(self, bw): self.bw = bw
    def get_swPwrInteg(self): return self.swPwrInteg
    def set_swPwrInteg(self, swPwrInteg): self.swPwrInteg = swPwrInteg
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_singlePhaseCenter(self): return self.singlePhaseCenter
    def set_singlePhaseCenter(self, singlePhaseCenter): self.singlePhaseCenter = singlePhaseCenter
    def get_stage1Rms(self): return self.stage1Rms
    def set_stage1Rms(self, stage1Rms): self.stage1Rms = stage1Rms
    def get_stage3Rms(self): return self.stage3Rms
    def set_stage3Rms(self, stage3Rms): self.stage3Rms = stage3Rms
    def get_inQuant(self): return self.inQuant
    def set_inQuant(self, inQuant): self.inQuant = inQuant
    def get_stage4Rms(self): return self.stage4Rms
    def set_stage4Rms(self, stage4Rms): self.stage4Rms = stage4Rms
    def export(self, outfile, level, namespace_='widar:', name_='baseBand', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseBand')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='baseBand'):
        if self.binMaxHwIntegTime is not None and 'binMaxHwIntegTime' not in already_processed:
            already_processed.append('binMaxHwIntegTime')
            outfile.write(' binMaxHwIntegTime="%s"' % self.gds_format_float(self.binMaxHwIntegTime, input_name='binMaxHwIntegTime'))
        if self.swPwrEpoch is not None and 'swPwrEpoch' not in already_processed:
            already_processed.append('swPwrEpoch')
            outfile.write(' swPwrEpoch=%s' % (self.gds_format_string(quote_attrib(self.swPwrEpoch).encode(ExternalEncoding), input_name='swPwrEpoch'), ))
        if self.delayModelsValid is not None and 'delayModelsValid' not in already_processed:
            already_processed.append('delayModelsValid')
            outfile.write(' delayModelsValid="%s"' % self.gds_format_integer(self.delayModelsValid, input_name='delayModelsValid'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.swbbName is not None and 'swbbName' not in already_processed:
            already_processed.append('swbbName')
            outfile.write(' swbbName=%s' % (quote_attrib(self.swbbName), ))
        if self.defaultFilterGain is not None and 'defaultFilterGain' not in already_processed:
            already_processed.append('defaultFilterGain')
            outfile.write(' defaultFilterGain=%s' % (self.gds_format_string(quote_attrib(self.defaultFilterGain).encode(ExternalEncoding), input_name='defaultFilterGain'), ))
        if self.stage2Rms is not None and 'stage2Rms' not in already_processed:
            already_processed.append('stage2Rms')
            outfile.write(' stage2Rms="%s"' % self.gds_format_double(self.stage2Rms, input_name='stage2Rms'))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            outfile.write(' bbB=%s' % (quote_attrib(self.bbB), ))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            outfile.write(' bbA=%s' % (quote_attrib(self.bbA), ))
        if self.binningPeriod is not None and 'binningPeriod' not in already_processed:
            already_processed.append('binningPeriod')
            outfile.write(' binningPeriod="%s"' % self.gds_format_float(self.binningPeriod, input_name='binningPeriod'))
        if self.noWbcProducts is not None and 'noWbcProducts' not in already_processed:
            already_processed.append('noWbcProducts')
            outfile.write(' noWbcProducts=%s' % (self.gds_format_string(quote_attrib(self.noWbcProducts).encode(ExternalEncoding), input_name='noWbcProducts'), ))
        if self.requantRms is not None and 'requantRms' not in already_processed:
            already_processed.append('requantRms')
            outfile.write(' requantRms="%s"' % self.gds_format_double(self.requantRms, input_name='requantRms'))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            outfile.write(' bw=%s' % (quote_attrib(self.bw), ))
        if self.swPwrInteg is not None and 'swPwrInteg' not in already_processed:
            already_processed.append('swPwrInteg')
            outfile.write(' swPwrInteg="%s"' % self.gds_format_integer(self.swPwrInteg, input_name='swPwrInteg'))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
        if self.singlePhaseCenter is not None and 'singlePhaseCenter' not in already_processed:
            already_processed.append('singlePhaseCenter')
            outfile.write(' singlePhaseCenter=%s' % (quote_attrib(self.singlePhaseCenter), ))
        if self.stage1Rms is not None and 'stage1Rms' not in already_processed:
            already_processed.append('stage1Rms')
            outfile.write(' stage1Rms="%s"' % self.gds_format_double(self.stage1Rms, input_name='stage1Rms'))
        if self.stage3Rms is not None and 'stage3Rms' not in already_processed:
            already_processed.append('stage3Rms')
            outfile.write(' stage3Rms="%s"' % self.gds_format_double(self.stage3Rms, input_name='stage3Rms'))
        if self.inQuant is not None and 'inQuant' not in already_processed:
            already_processed.append('inQuant')
            outfile.write(' inQuant=%s' % (quote_attrib(self.inQuant), ))
        if self.stage4Rms is not None and 'stage4Rms' not in already_processed:
            already_processed.append('stage4Rms')
            outfile.write(' stage4Rms="%s"' % self.gds_format_double(self.stage4Rms, input_name='stage4Rms'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='baseBand', fromsubclass_=False):
        for phaseBinning_ in self.phaseBinning:
            phaseBinning_.export(outfile, level, namespace_, name_='phaseBinning')
        for subBand_ in self.subBand:
            subBand_.export(outfile, level, namespace_, name_='subBand')
        for wpp_ in self.wpp:
            wpp_.export(outfile, level, namespace_, name_='wpp')
        if self.gating:
            self.gating.export(outfile, level, namespace_, name_='gating')
    def hasContent_(self):
        if (
            self.phaseBinning or
            self.subBand or
            self.wpp or
            self.gating is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='baseBand'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.binMaxHwIntegTime is not None and 'binMaxHwIntegTime' not in already_processed:
            already_processed.append('binMaxHwIntegTime')
            showIndent(outfile, level)
            outfile.write('binMaxHwIntegTime = %f,\n' % (self.binMaxHwIntegTime,))
        if self.swPwrEpoch is not None and 'swPwrEpoch' not in already_processed:
            already_processed.append('swPwrEpoch')
            showIndent(outfile, level)
            outfile.write('swPwrEpoch = "%s",\n' % (self.swPwrEpoch,))
        if self.delayModelsValid is not None and 'delayModelsValid' not in already_processed:
            already_processed.append('delayModelsValid')
            showIndent(outfile, level)
            outfile.write('delayModelsValid = %d,\n' % (self.delayModelsValid,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.swbbName is not None and 'swbbName' not in already_processed:
            already_processed.append('swbbName')
            showIndent(outfile, level)
            outfile.write('swbbName = %s,\n' % (self.swbbName,))
        if self.defaultFilterGain is not None and 'defaultFilterGain' not in already_processed:
            already_processed.append('defaultFilterGain')
            showIndent(outfile, level)
            outfile.write('defaultFilterGain = "%s",\n' % (self.defaultFilterGain,))
        if self.stage2Rms is not None and 'stage2Rms' not in already_processed:
            already_processed.append('stage2Rms')
            showIndent(outfile, level)
            outfile.write('stage2Rms = %e,\n' % (self.stage2Rms,))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            showIndent(outfile, level)
            outfile.write('bbB = %s,\n' % (self.bbB,))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            showIndent(outfile, level)
            outfile.write('bbA = %s,\n' % (self.bbA,))
        if self.binningPeriod is not None and 'binningPeriod' not in already_processed:
            already_processed.append('binningPeriod')
            showIndent(outfile, level)
            outfile.write('binningPeriod = %f,\n' % (self.binningPeriod,))
        if self.noWbcProducts is not None and 'noWbcProducts' not in already_processed:
            already_processed.append('noWbcProducts')
            showIndent(outfile, level)
            outfile.write('noWbcProducts = "%s",\n' % (self.noWbcProducts,))
        if self.requantRms is not None and 'requantRms' not in already_processed:
            already_processed.append('requantRms')
            showIndent(outfile, level)
            outfile.write('requantRms = %e,\n' % (self.requantRms,))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            showIndent(outfile, level)
            outfile.write('bw = %s,\n' % (self.bw,))
        if self.swPwrInteg is not None and 'swPwrInteg' not in already_processed:
            already_processed.append('swPwrInteg')
            showIndent(outfile, level)
            outfile.write('swPwrInteg = %d,\n' % (self.swPwrInteg,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
        if self.singlePhaseCenter is not None and 'singlePhaseCenter' not in already_processed:
            already_processed.append('singlePhaseCenter')
            showIndent(outfile, level)
            outfile.write('singlePhaseCenter = %s,\n' % (self.singlePhaseCenter,))
        if self.stage1Rms is not None and 'stage1Rms' not in already_processed:
            already_processed.append('stage1Rms')
            showIndent(outfile, level)
            outfile.write('stage1Rms = %e,\n' % (self.stage1Rms,))
        if self.stage3Rms is not None and 'stage3Rms' not in already_processed:
            already_processed.append('stage3Rms')
            showIndent(outfile, level)
            outfile.write('stage3Rms = %e,\n' % (self.stage3Rms,))
        if self.inQuant is not None and 'inQuant' not in already_processed:
            already_processed.append('inQuant')
            showIndent(outfile, level)
            outfile.write('inQuant = %s,\n' % (self.inQuant,))
        if self.stage4Rms is not None and 'stage4Rms' not in already_processed:
            already_processed.append('stage4Rms')
            showIndent(outfile, level)
            outfile.write('stage4Rms = %e,\n' % (self.stage4Rms,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('phaseBinning=[\n')
        level += 1
        for phaseBinning_ in self.phaseBinning:
            showIndent(outfile, level)
            outfile.write('model_.phaseBinning(\n')
            phaseBinning_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subBand=[\n')
        level += 1
        for subBand_ in self.subBand:
            showIndent(outfile, level)
            outfile.write('model_.subBand(\n')
            subBand_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wpp=[\n')
        level += 1
        for wpp_ in self.wpp:
            showIndent(outfile, level)
            outfile.write('model_.wpp(\n')
            wpp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.gating is not None:
            showIndent(outfile, level)
            outfile.write('gating=model_.gating(\n')
            self.gating.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('binMaxHwIntegTime', node)
        if value is not None and 'binMaxHwIntegTime' not in already_processed:
            already_processed.append('binMaxHwIntegTime')
            try:
                self.binMaxHwIntegTime = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (binMaxHwIntegTime): %s' % exp)
        value = find_attr_value_('swPwrEpoch', node)
        if value is not None and 'swPwrEpoch' not in already_processed:
            already_processed.append('swPwrEpoch')
            self.swPwrEpoch = value
        value = find_attr_value_('delayModelsValid', node)
        if value is not None and 'delayModelsValid' not in already_processed:
            already_processed.append('delayModelsValid')
            try:
                self.delayModelsValid = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('swbbName', node)
        if value is not None and 'swbbName' not in already_processed:
            already_processed.append('swbbName')
            self.swbbName = value
        value = find_attr_value_('defaultFilterGain', node)
        if value is not None and 'defaultFilterGain' not in already_processed:
            already_processed.append('defaultFilterGain')
            self.defaultFilterGain = value
        value = find_attr_value_('stage2Rms', node)
        if value is not None and 'stage2Rms' not in already_processed:
            already_processed.append('stage2Rms')
            try:
                self.stage2Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage2Rms): %s' % exp)
        value = find_attr_value_('bbB', node)
        if value is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            self.bbB = value
        value = find_attr_value_('bbA', node)
        if value is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            self.bbA = value
        value = find_attr_value_('binningPeriod', node)
        if value is not None and 'binningPeriod' not in already_processed:
            already_processed.append('binningPeriod')
            try:
                self.binningPeriod = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (binningPeriod): %s' % exp)
        value = find_attr_value_('noWbcProducts', node)
        if value is not None and 'noWbcProducts' not in already_processed:
            already_processed.append('noWbcProducts')
            self.noWbcProducts = value
        value = find_attr_value_('requantRms', node)
        if value is not None and 'requantRms' not in already_processed:
            already_processed.append('requantRms')
            try:
                self.requantRms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (requantRms): %s' % exp)
        value = find_attr_value_('bw', node)
        if value is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            self.bw = value
        value = find_attr_value_('swPwrInteg', node)
        if value is not None and 'swPwrInteg' not in already_processed:
            already_processed.append('swPwrInteg')
            try:
                self.swPwrInteg = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
        value = find_attr_value_('singlePhaseCenter', node)
        if value is not None and 'singlePhaseCenter' not in already_processed:
            already_processed.append('singlePhaseCenter')
            self.singlePhaseCenter = value
        value = find_attr_value_('stage1Rms', node)
        if value is not None and 'stage1Rms' not in already_processed:
            already_processed.append('stage1Rms')
            try:
                self.stage1Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage1Rms): %s' % exp)
        value = find_attr_value_('stage3Rms', node)
        if value is not None and 'stage3Rms' not in already_processed:
            already_processed.append('stage3Rms')
            try:
                self.stage3Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage3Rms): %s' % exp)
        value = find_attr_value_('inQuant', node)
        if value is not None and 'inQuant' not in already_processed:
            already_processed.append('inQuant')
            self.inQuant = value
        value = find_attr_value_('stage4Rms', node)
        if value is not None and 'stage4Rms' not in already_processed:
            already_processed.append('stage4Rms')
            try:
                self.stage4Rms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (stage4Rms): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'phaseBinning':
            obj_ = phaseBinning.factory()
            obj_.build(child_)
            self.phaseBinning.append(obj_)
        elif nodeName_ == 'subBand':
            obj_ = subBand.factory()
            obj_.build(child_)
            self.subBand.append(obj_)
        elif nodeName_ == 'wpp':
            obj_ = wpp.factory()
            obj_.build(child_)
            self.wpp.append(obj_)
        elif nodeName_ == 'gating':
            obj_ = gating.factory()
            obj_.build(child_)
            self.set_gating(obj_)
# end class baseBand


class subBand(GeneratedsSuper):
    """Subband configuration specifies filter configuration and output
    products. swIndex is index of the Spectral Window (BDF). WIDAR
    correlator does not use swIndex; swIndex is forwarded to CBE
    (BDF). Radar mode and tone extraction have not been implemented
    in CM. Gating and signal-to-noise-ratio have not been
    implemented in CM. interFrameDelay is nominal time in
    microseconds between transmitted frames on SFP1 (or XPAK if we
    have 10 GigE). interFrameDelay is used only if
    frameSchedulingAlgotihm=setDelay, otherwise it is ignored.
    Default=896. If randomDelay is Off: 0-255, if randomDelay is On
    : 0, 4, ..., 1020 Attributes phaseBinning and binningOffset are
    relevant only when phaseBinning is defined for baseBand.
    binningOffset is phase relative to (in addition to) phase
    specified in baseBand."""
    subclass = None
    superclass = None
    def __init__(self, interFrameDelay=None, mixerPhaseErrorCorr='no', rqNumBits=None, name=None, gatingPhase=None, pulsarGatingPhase=None, sbid=None, phaseBinning=None, rfiBlankingDuration=None, centralFreq=None, bw=None, randomizeDelay=None, useMixer='no', rfiDetectionLevel=None, frameSchedulingAlgorithm=None, swIndex=None, signalToNoise=None, binningOffset=None, polProducts=None, summedArray=None, radarMode=None, toneExtraction=None):
        self.interFrameDelay = _cast(None, interFrameDelay)
        self.mixerPhaseErrorCorr = _cast(None, mixerPhaseErrorCorr)
        self.rqNumBits = _cast(None, rqNumBits)
        self.name = _cast(None, name)
        self.gatingPhase = _cast(int, gatingPhase)
        self.pulsarGatingPhase = _cast(float, pulsarGatingPhase)
        self.sbid = _cast(None, sbid)
        self.phaseBinning = _cast(None, phaseBinning)
        self.rfiBlankingDuration = _cast(float, rfiBlankingDuration)
        self.centralFreq = _cast(float, centralFreq)
        self.bw = _cast(None, bw)
        self.randomizeDelay = _cast(None, randomizeDelay)
        self.useMixer = _cast(None, useMixer)
        self.rfiDetectionLevel = _cast(float, rfiDetectionLevel)
        self.frameSchedulingAlgorithm = _cast(None, frameSchedulingAlgorithm)
        self.swIndex = _cast(int, swIndex)
        self.signalToNoise = _cast(None, signalToNoise)
        self.binningOffset = _cast(None, binningOffset)
        self.polProducts = polProducts
        if summedArray is None:
            self.summedArray = []
        else:
            self.summedArray = summedArray
        self.radarMode = radarMode
        self.toneExtraction = toneExtraction
    def factory(*args_, **kwargs_):
        if subBand.subclass:
            return subBand.subclass(*args_, **kwargs_)
        else:
            return subBand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polProducts(self): return self.polProducts
    def set_polProducts(self, polProducts): self.polProducts = polProducts
    def get_summedArray(self): return self.summedArray
    def set_summedArray(self, summedArray): self.summedArray = summedArray
    def add_summedArray(self, value): self.summedArray.append(value)
    def insert_summedArray(self, index, value): self.summedArray[index] = value
    def get_radarMode(self): return self.radarMode
    def set_radarMode(self, radarMode): self.radarMode = radarMode
    def get_toneExtraction(self): return self.toneExtraction
    def set_toneExtraction(self, toneExtraction): self.toneExtraction = toneExtraction
    def get_interFrameDelay(self): return self.interFrameDelay
    def set_interFrameDelay(self, interFrameDelay): self.interFrameDelay = interFrameDelay
    def get_mixerPhaseErrorCorr(self): return self.mixerPhaseErrorCorr
    def set_mixerPhaseErrorCorr(self, mixerPhaseErrorCorr): self.mixerPhaseErrorCorr = mixerPhaseErrorCorr
    def get_rqNumBits(self): return self.rqNumBits
    def set_rqNumBits(self, rqNumBits): self.rqNumBits = rqNumBits
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_gatingPhase(self): return self.gatingPhase
    def set_gatingPhase(self, gatingPhase): self.gatingPhase = gatingPhase
    def get_pulsarGatingPhase(self): return self.pulsarGatingPhase
    def set_pulsarGatingPhase(self, pulsarGatingPhase): self.pulsarGatingPhase = pulsarGatingPhase
    def get_sbid(self): return self.sbid
    def set_sbid(self, sbid): self.sbid = sbid
    def get_phaseBinning(self): return self.phaseBinning
    def set_phaseBinning(self, phaseBinning): self.phaseBinning = phaseBinning
    def get_rfiBlankingDuration(self): return self.rfiBlankingDuration
    def set_rfiBlankingDuration(self, rfiBlankingDuration): self.rfiBlankingDuration = rfiBlankingDuration
    def get_centralFreq(self): return self.centralFreq
    def set_centralFreq(self, centralFreq): self.centralFreq = centralFreq
    def get_bw(self): return self.bw
    def set_bw(self, bw): self.bw = bw
    def get_randomizeDelay(self): return self.randomizeDelay
    def set_randomizeDelay(self, randomizeDelay): self.randomizeDelay = randomizeDelay
    def get_useMixer(self): return self.useMixer
    def set_useMixer(self, useMixer): self.useMixer = useMixer
    def get_rfiDetectionLevel(self): return self.rfiDetectionLevel
    def set_rfiDetectionLevel(self, rfiDetectionLevel): self.rfiDetectionLevel = rfiDetectionLevel
    def get_frameSchedulingAlgorithm(self): return self.frameSchedulingAlgorithm
    def set_frameSchedulingAlgorithm(self, frameSchedulingAlgorithm): self.frameSchedulingAlgorithm = frameSchedulingAlgorithm
    def get_swIndex(self): return self.swIndex
    def set_swIndex(self, swIndex): self.swIndex = swIndex
    def get_signalToNoise(self): return self.signalToNoise
    def set_signalToNoise(self, signalToNoise): self.signalToNoise = signalToNoise
    def get_binningOffset(self): return self.binningOffset
    def set_binningOffset(self, binningOffset): self.binningOffset = binningOffset
    def export(self, outfile, level, namespace_='widar:', name_='subBand', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subBand')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='subBand'):
        if self.interFrameDelay is not None and 'interFrameDelay' not in already_processed:
            already_processed.append('interFrameDelay')
            outfile.write(' interFrameDelay=%s' % (quote_attrib(self.interFrameDelay), ))
        if self.mixerPhaseErrorCorr is not None and 'mixerPhaseErrorCorr' not in already_processed:
            already_processed.append('mixerPhaseErrorCorr')
            outfile.write(' mixerPhaseErrorCorr=%s' % (quote_attrib(self.mixerPhaseErrorCorr), ))
        if self.rqNumBits is not None and 'rqNumBits' not in already_processed:
            already_processed.append('rqNumBits')
            outfile.write(' rqNumBits=%s' % (quote_attrib(self.rqNumBits), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.gatingPhase is not None and 'gatingPhase' not in already_processed:
            already_processed.append('gatingPhase')
            outfile.write(' gatingPhase="%s"' % self.gds_format_integer(self.gatingPhase, input_name='gatingPhase'))
        if self.pulsarGatingPhase is not None and 'pulsarGatingPhase' not in already_processed:
            already_processed.append('pulsarGatingPhase')
            outfile.write(' pulsarGatingPhase="%s"' % self.gds_format_float(self.pulsarGatingPhase, input_name='pulsarGatingPhase'))
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            outfile.write(' sbid=%s' % (quote_attrib(self.sbid), ))
        if self.phaseBinning is not None and 'phaseBinning' not in already_processed:
            already_processed.append('phaseBinning')
            outfile.write(' phaseBinning=%s' % (quote_attrib(self.phaseBinning), ))
        if self.rfiBlankingDuration is not None and 'rfiBlankingDuration' not in already_processed:
            already_processed.append('rfiBlankingDuration')
            outfile.write(' rfiBlankingDuration="%s"' % self.gds_format_float(self.rfiBlankingDuration, input_name='rfiBlankingDuration'))
        if self.centralFreq is not None and 'centralFreq' not in already_processed:
            already_processed.append('centralFreq')
            outfile.write(' centralFreq="%s"' % self.gds_format_float(self.centralFreq, input_name='centralFreq'))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            outfile.write(' bw=%s' % (quote_attrib(self.bw), ))
        if self.randomizeDelay is not None and 'randomizeDelay' not in already_processed:
            already_processed.append('randomizeDelay')
            outfile.write(' randomizeDelay=%s' % (quote_attrib(self.randomizeDelay), ))
        if self.useMixer is not None and 'useMixer' not in already_processed:
            already_processed.append('useMixer')
            outfile.write(' useMixer=%s' % (quote_attrib(self.useMixer), ))
        if self.rfiDetectionLevel is not None and 'rfiDetectionLevel' not in already_processed:
            already_processed.append('rfiDetectionLevel')
            outfile.write(' rfiDetectionLevel="%s"' % self.gds_format_float(self.rfiDetectionLevel, input_name='rfiDetectionLevel'))
        if self.frameSchedulingAlgorithm is not None and 'frameSchedulingAlgorithm' not in already_processed:
            already_processed.append('frameSchedulingAlgorithm')
            outfile.write(' frameSchedulingAlgorithm=%s' % (quote_attrib(self.frameSchedulingAlgorithm), ))
        if self.swIndex is not None and 'swIndex' not in already_processed:
            already_processed.append('swIndex')
            outfile.write(' swIndex="%s"' % self.gds_format_integer(self.swIndex, input_name='swIndex'))
        if self.signalToNoise is not None and 'signalToNoise' not in already_processed:
            already_processed.append('signalToNoise')
            outfile.write(' signalToNoise=%s' % (quote_attrib(self.signalToNoise), ))
        if self.binningOffset is not None and 'binningOffset' not in already_processed:
            already_processed.append('binningOffset')
            outfile.write(' binningOffset=%s' % (quote_attrib(self.binningOffset), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='subBand', fromsubclass_=False):
        if self.polProducts:
            self.polProducts.export(outfile, level, namespace_, name_='polProducts')
        for summedArray_ in self.summedArray:
            summedArray_.export(outfile, level, namespace_, name_='summedArray')
        if self.radarMode:
            self.radarMode.export(outfile, level, namespace_, name_='radarMode')
        if self.toneExtraction:
            self.toneExtraction.export(outfile, level, namespace_, name_='toneExtraction')
    def hasContent_(self):
        if (
            self.polProducts is not None or
            self.summedArray or
            self.radarMode is not None or
            self.toneExtraction is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subBand'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interFrameDelay is not None and 'interFrameDelay' not in already_processed:
            already_processed.append('interFrameDelay')
            showIndent(outfile, level)
            outfile.write('interFrameDelay = %s,\n' % (self.interFrameDelay,))
        if self.mixerPhaseErrorCorr is not None and 'mixerPhaseErrorCorr' not in already_processed:
            already_processed.append('mixerPhaseErrorCorr')
            showIndent(outfile, level)
            outfile.write('mixerPhaseErrorCorr = %s,\n' % (self.mixerPhaseErrorCorr,))
        if self.rqNumBits is not None and 'rqNumBits' not in already_processed:
            already_processed.append('rqNumBits')
            showIndent(outfile, level)
            outfile.write('rqNumBits = %s,\n' % (self.rqNumBits,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.gatingPhase is not None and 'gatingPhase' not in already_processed:
            already_processed.append('gatingPhase')
            showIndent(outfile, level)
            outfile.write('gatingPhase = %d,\n' % (self.gatingPhase,))
        if self.pulsarGatingPhase is not None and 'pulsarGatingPhase' not in already_processed:
            already_processed.append('pulsarGatingPhase')
            showIndent(outfile, level)
            outfile.write('pulsarGatingPhase = %f,\n' % (self.pulsarGatingPhase,))
        if self.sbid is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            showIndent(outfile, level)
            outfile.write('sbid = %s,\n' % (self.sbid,))
        if self.phaseBinning is not None and 'phaseBinning' not in already_processed:
            already_processed.append('phaseBinning')
            showIndent(outfile, level)
            outfile.write('phaseBinning = %s,\n' % (self.phaseBinning,))
        if self.rfiBlankingDuration is not None and 'rfiBlankingDuration' not in already_processed:
            already_processed.append('rfiBlankingDuration')
            showIndent(outfile, level)
            outfile.write('rfiBlankingDuration = %f,\n' % (self.rfiBlankingDuration,))
        if self.centralFreq is not None and 'centralFreq' not in already_processed:
            already_processed.append('centralFreq')
            showIndent(outfile, level)
            outfile.write('centralFreq = %f,\n' % (self.centralFreq,))
        if self.bw is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            showIndent(outfile, level)
            outfile.write('bw = %s,\n' % (self.bw,))
        if self.randomizeDelay is not None and 'randomizeDelay' not in already_processed:
            already_processed.append('randomizeDelay')
            showIndent(outfile, level)
            outfile.write('randomizeDelay = %s,\n' % (self.randomizeDelay,))
        if self.useMixer is not None and 'useMixer' not in already_processed:
            already_processed.append('useMixer')
            showIndent(outfile, level)
            outfile.write('useMixer = %s,\n' % (self.useMixer,))
        if self.rfiDetectionLevel is not None and 'rfiDetectionLevel' not in already_processed:
            already_processed.append('rfiDetectionLevel')
            showIndent(outfile, level)
            outfile.write('rfiDetectionLevel = %f,\n' % (self.rfiDetectionLevel,))
        if self.frameSchedulingAlgorithm is not None and 'frameSchedulingAlgorithm' not in already_processed:
            already_processed.append('frameSchedulingAlgorithm')
            showIndent(outfile, level)
            outfile.write('frameSchedulingAlgorithm = %s,\n' % (self.frameSchedulingAlgorithm,))
        if self.swIndex is not None and 'swIndex' not in already_processed:
            already_processed.append('swIndex')
            showIndent(outfile, level)
            outfile.write('swIndex = %d,\n' % (self.swIndex,))
        if self.signalToNoise is not None and 'signalToNoise' not in already_processed:
            already_processed.append('signalToNoise')
            showIndent(outfile, level)
            outfile.write('signalToNoise = %s,\n' % (self.signalToNoise,))
        if self.binningOffset is not None and 'binningOffset' not in already_processed:
            already_processed.append('binningOffset')
            showIndent(outfile, level)
            outfile.write('binningOffset = %s,\n' % (self.binningOffset,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.polProducts is not None:
            showIndent(outfile, level)
            outfile.write('polProducts=model_.polProducts(\n')
            self.polProducts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('summedArray=[\n')
        level += 1
        for summedArray_ in self.summedArray:
            showIndent(outfile, level)
            outfile.write('model_.summedArray(\n')
            summedArray_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.radarMode is not None:
            showIndent(outfile, level)
            outfile.write('radarMode=model_.radarMode(\n')
            self.radarMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.toneExtraction is not None:
            showIndent(outfile, level)
            outfile.write('toneExtraction=model_.toneExtraction(\n')
            self.toneExtraction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interFrameDelay', node)
        if value is not None and 'interFrameDelay' not in already_processed:
            already_processed.append('interFrameDelay')
            self.interFrameDelay = value
        value = find_attr_value_('mixerPhaseErrorCorr', node)
        if value is not None and 'mixerPhaseErrorCorr' not in already_processed:
            already_processed.append('mixerPhaseErrorCorr')
            self.mixerPhaseErrorCorr = value
        value = find_attr_value_('rqNumBits', node)
        if value is not None and 'rqNumBits' not in already_processed:
            already_processed.append('rqNumBits')
            self.rqNumBits = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('gatingPhase', node)
        if value is not None and 'gatingPhase' not in already_processed:
            already_processed.append('gatingPhase')
            try:
                self.gatingPhase = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('pulsarGatingPhase', node)
        if value is not None and 'pulsarGatingPhase' not in already_processed:
            already_processed.append('pulsarGatingPhase')
            try:
                self.pulsarGatingPhase = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (pulsarGatingPhase): %s' % exp)
        value = find_attr_value_('sbid', node)
        if value is not None and 'sbid' not in already_processed:
            already_processed.append('sbid')
            self.sbid = value
        value = find_attr_value_('phaseBinning', node)
        if value is not None and 'phaseBinning' not in already_processed:
            already_processed.append('phaseBinning')
            self.phaseBinning = value
        value = find_attr_value_('rfiBlankingDuration', node)
        if value is not None and 'rfiBlankingDuration' not in already_processed:
            already_processed.append('rfiBlankingDuration')
            try:
                self.rfiBlankingDuration = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (rfiBlankingDuration): %s' % exp)
        value = find_attr_value_('centralFreq', node)
        if value is not None and 'centralFreq' not in already_processed:
            already_processed.append('centralFreq')
            try:
                self.centralFreq = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (centralFreq): %s' % exp)
        value = find_attr_value_('bw', node)
        if value is not None and 'bw' not in already_processed:
            already_processed.append('bw')
            self.bw = value
        value = find_attr_value_('randomizeDelay', node)
        if value is not None and 'randomizeDelay' not in already_processed:
            already_processed.append('randomizeDelay')
            self.randomizeDelay = value
        value = find_attr_value_('useMixer', node)
        if value is not None and 'useMixer' not in already_processed:
            already_processed.append('useMixer')
            self.useMixer = value
        value = find_attr_value_('rfiDetectionLevel', node)
        if value is not None and 'rfiDetectionLevel' not in already_processed:
            already_processed.append('rfiDetectionLevel')
            try:
                self.rfiDetectionLevel = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (rfiDetectionLevel): %s' % exp)
        value = find_attr_value_('frameSchedulingAlgorithm', node)
        if value is not None and 'frameSchedulingAlgorithm' not in already_processed:
            already_processed.append('frameSchedulingAlgorithm')
            self.frameSchedulingAlgorithm = value
        value = find_attr_value_('swIndex', node)
        if value is not None and 'swIndex' not in already_processed:
            already_processed.append('swIndex')
            try:
                self.swIndex = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('signalToNoise', node)
        if value is not None and 'signalToNoise' not in already_processed:
            already_processed.append('signalToNoise')
            self.signalToNoise = value
        value = find_attr_value_('binningOffset', node)
        if value is not None and 'binningOffset' not in already_processed:
            already_processed.append('binningOffset')
            self.binningOffset = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polProducts':
            obj_ = polProducts.factory()
            obj_.build(child_)
            self.set_polProducts(obj_)
        elif nodeName_ == 'summedArray':
            obj_ = summedArray.factory()
            obj_.build(child_)
            self.summedArray.append(obj_)
        elif nodeName_ == 'radarMode':
            obj_ = radarMode.factory()
            obj_.build(child_)
            self.set_radarMode(obj_)
        elif nodeName_ == 'toneExtraction':
            obj_ = toneExtraction.factory()
            obj_.build(child_)
            self.set_toneExtraction(obj_)
# end class subBand


class polProducts(GeneratedsSuper):
    """Polarization products that use the same integration factors
    (DUMPTRIG) and share same boards. For now, user can specify only
    one instance of this element, which means that user can not
    specify two groups of polarization products, where each group
    uses different DUMPTRIG."""
    subclass = None
    superclass = None
    def __init__(self, autoCorrMode='off', pp=None, blbProdIntegration=None, blbPair=None, stationPacking=None, productPacking=None, autoCorrSubset=None, cbeProcessing=None):
        self.autoCorrMode = _cast(None, autoCorrMode)
        if pp is None:
            self.pp = []
        else:
            self.pp = pp
        self.blbProdIntegration = blbProdIntegration
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        self.stationPacking = stationPacking
        self.productPacking = productPacking
        self.autoCorrSubset = autoCorrSubset
        self.cbeProcessing = cbeProcessing
    def factory(*args_, **kwargs_):
        if polProducts.subclass:
            return polProducts.subclass(*args_, **kwargs_)
        else:
            return polProducts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pp(self): return self.pp
    def set_pp(self, pp): self.pp = pp
    def add_pp(self, value): self.pp.append(value)
    def insert_pp(self, index, value): self.pp[index] = value
    def get_blbProdIntegration(self): return self.blbProdIntegration
    def set_blbProdIntegration(self, blbProdIntegration): self.blbProdIntegration = blbProdIntegration
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_stationPacking(self): return self.stationPacking
    def set_stationPacking(self, stationPacking): self.stationPacking = stationPacking
    def get_productPacking(self): return self.productPacking
    def set_productPacking(self, productPacking): self.productPacking = productPacking
    def get_autoCorrSubset(self): return self.autoCorrSubset
    def set_autoCorrSubset(self, autoCorrSubset): self.autoCorrSubset = autoCorrSubset
    def get_cbeProcessing(self): return self.cbeProcessing
    def set_cbeProcessing(self, cbeProcessing): self.cbeProcessing = cbeProcessing
    def get_autoCorrMode(self): return self.autoCorrMode
    def set_autoCorrMode(self, autoCorrMode): self.autoCorrMode = autoCorrMode
    def export(self, outfile, level, namespace_='widar:', name_='polProducts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polProducts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='polProducts'):
        if self.autoCorrMode is not None and 'autoCorrMode' not in already_processed:
            already_processed.append('autoCorrMode')
            outfile.write(' autoCorrMode=%s' % (quote_attrib(self.autoCorrMode), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='polProducts', fromsubclass_=False):
        for pp_ in self.pp:
            pp_.export(outfile, level, namespace_, name_='pp')
        if self.blbProdIntegration:
            self.blbProdIntegration.export(outfile, level, namespace_, name_='blbProdIntegration')
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        if self.stationPacking:
            self.stationPacking.export(outfile, level, namespace_, name_='stationPacking')
        if self.productPacking:
            self.productPacking.export(outfile, level, namespace_, name_='productPacking')
        if self.autoCorrSubset:
            self.autoCorrSubset.export(outfile, level, namespace_, name_='autoCorrSubset')
        if self.cbeProcessing:
            self.cbeProcessing.export(outfile, level, namespace_, name_='cbeProcessing')
    def hasContent_(self):
        if (
            self.pp or
            self.blbProdIntegration is not None or
            self.blbPair or
            self.stationPacking is not None or
            self.productPacking is not None or
            self.autoCorrSubset is not None or
            self.cbeProcessing is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polProducts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.autoCorrMode is not None and 'autoCorrMode' not in already_processed:
            already_processed.append('autoCorrMode')
            showIndent(outfile, level)
            outfile.write('autoCorrMode = %s,\n' % (self.autoCorrMode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pp=[\n')
        level += 1
        for pp_ in self.pp:
            showIndent(outfile, level)
            outfile.write('model_.pp(\n')
            pp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.blbProdIntegration is not None:
            showIndent(outfile, level)
            outfile.write('blbProdIntegration=model_.blbProdIntegration(\n')
            self.blbProdIntegration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.stationPacking is not None:
            showIndent(outfile, level)
            outfile.write('stationPacking=model_.stationPacking(\n')
            self.stationPacking.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.productPacking is not None:
            showIndent(outfile, level)
            outfile.write('productPacking=model_.productPacking(\n')
            self.productPacking.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoCorrSubset is not None:
            showIndent(outfile, level)
            outfile.write('autoCorrSubset=model_.autoCorrSubset(\n')
            self.autoCorrSubset.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cbeProcessing is not None:
            showIndent(outfile, level)
            outfile.write('cbeProcessing=model_.cbeProcessing(\n')
            self.cbeProcessing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('autoCorrMode', node)
        if value is not None and 'autoCorrMode' not in already_processed:
            already_processed.append('autoCorrMode')
            self.autoCorrMode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pp':
            obj_ = pp.factory()
            obj_.build(child_)
            self.pp.append(obj_)
        elif nodeName_ == 'blbProdIntegration':
            obj_ = blbProdIntegration.factory()
            obj_.build(child_)
            self.set_blbProdIntegration(obj_)
        elif nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'stationPacking':
            obj_ = stationPacking.factory()
            obj_.build(child_)
            self.set_stationPacking(obj_)
        elif nodeName_ == 'productPacking':
            obj_ = productPacking.factory()
            obj_.build(child_)
            self.set_productPacking(obj_)
        elif nodeName_ == 'autoCorrSubset':
            obj_ = autoCorrSubset.factory()
            obj_.build(child_)
            self.set_autoCorrSubset(obj_)
        elif nodeName_ == 'cbeProcessing':
            obj_ = cbeProcessing.factory()
            obj_.build(child_)
            self.set_cbeProcessing(obj_)
# end class polProducts


class pp(GeneratedsSuper):
    """Polarization product."""
    subclass = None
    superclass = None
    def __init__(self, spectralChannels=None, id=None, correlation=None):
        self.spectralChannels = _cast(None, spectralChannels)
        self.id = _cast(None, id)
        self.correlation = _cast(None, correlation)
        pass
    def factory(*args_, **kwargs_):
        if pp.subclass:
            return pp.subclass(*args_, **kwargs_)
        else:
            return pp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectralChannels(self): return self.spectralChannels
    def set_spectralChannels(self, spectralChannels): self.spectralChannels = spectralChannels
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_correlation(self): return self.correlation
    def set_correlation(self, correlation): self.correlation = correlation
    def export(self, outfile, level, namespace_='widar:', name_='pp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pp')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='pp'):
        if self.spectralChannels is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            outfile.write(' spectralChannels=%s' % (quote_attrib(self.spectralChannels), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.correlation is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            outfile.write(' correlation=%s' % (quote_attrib(self.correlation), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='pp', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectralChannels is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            showIndent(outfile, level)
            outfile.write('spectralChannels = %s,\n' % (self.spectralChannels,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.correlation is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            showIndent(outfile, level)
            outfile.write('correlation = %s,\n' % (self.correlation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectralChannels', node)
        if value is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            self.spectralChannels = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('correlation', node)
        if value is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            self.correlation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pp


class blbProdIntegration(GeneratedsSuper):
    """Integration Time defined as: Minimum Hardware Integration Time
    (MHIT) in microseconds. H/W integration factor (h/w integration
    time specified as multiple of the minimum h/w integration time).
    LTA integration factor (LTA integration time specified as
    multiple of the h/w integration time). CBE integration factor
    (CBE integration time specified as multiple of the LTA
    integration time). Phase for recirculation (serial,parallel) is
    relevant only if recFactor>1. If recPhase is not specified and
    recFactor>1, CM assumes that phase for recirculation is serial.
    For phased binning: a) minHwIntegTime is not relevant and does
    not need to be specified. b) ccIntegFactor is not relevant and
    need not be specified. c) ltaIntegFactor can be specified (if
    not specified assume 1)."""
    subclass = None
    superclass = None
    def __init__(self, ccIntegFactor=1, burstBlankDuration=None, pauseBetweenBursts=None, numRollingBursts=None, cbeIntegFactor=1, recirculation=None, recPhase=None, minIntegTime=None, burstDuration=None, ltaIntegFactor=1, firstBurstOffset=None):
        self.ccIntegFactor = _cast(int, ccIntegFactor)
        self.burstBlankDuration = _cast(int, burstBlankDuration)
        self.pauseBetweenBursts = _cast(int, pauseBetweenBursts)
        self.numRollingBursts = _cast(int, numRollingBursts)
        self.cbeIntegFactor = _cast(int, cbeIntegFactor)
        self.recirculation = _cast(None, recirculation)
        self.recPhase = _cast(None, recPhase)
        self.minIntegTime = _cast(None, minIntegTime)
        self.burstDuration = _cast(int, burstDuration)
        self.ltaIntegFactor = _cast(int, ltaIntegFactor)
        self.firstBurstOffset = _cast(int, firstBurstOffset)
        pass
    def factory(*args_, **kwargs_):
        if blbProdIntegration.subclass:
            return blbProdIntegration.subclass(*args_, **kwargs_)
        else:
            return blbProdIntegration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ccIntegFactor(self): return self.ccIntegFactor
    def set_ccIntegFactor(self, ccIntegFactor): self.ccIntegFactor = ccIntegFactor
    def get_burstBlankDuration(self): return self.burstBlankDuration
    def set_burstBlankDuration(self, burstBlankDuration): self.burstBlankDuration = burstBlankDuration
    def get_pauseBetweenBursts(self): return self.pauseBetweenBursts
    def set_pauseBetweenBursts(self, pauseBetweenBursts): self.pauseBetweenBursts = pauseBetweenBursts
    def get_numRollingBursts(self): return self.numRollingBursts
    def set_numRollingBursts(self, numRollingBursts): self.numRollingBursts = numRollingBursts
    def get_cbeIntegFactor(self): return self.cbeIntegFactor
    def set_cbeIntegFactor(self, cbeIntegFactor): self.cbeIntegFactor = cbeIntegFactor
    def get_recirculation(self): return self.recirculation
    def set_recirculation(self, recirculation): self.recirculation = recirculation
    def get_recPhase(self): return self.recPhase
    def set_recPhase(self, recPhase): self.recPhase = recPhase
    def get_minIntegTime(self): return self.minIntegTime
    def set_minIntegTime(self, minIntegTime): self.minIntegTime = minIntegTime
    def get_burstDuration(self): return self.burstDuration
    def set_burstDuration(self, burstDuration): self.burstDuration = burstDuration
    def get_ltaIntegFactor(self): return self.ltaIntegFactor
    def set_ltaIntegFactor(self, ltaIntegFactor): self.ltaIntegFactor = ltaIntegFactor
    def get_firstBurstOffset(self): return self.firstBurstOffset
    def set_firstBurstOffset(self, firstBurstOffset): self.firstBurstOffset = firstBurstOffset
    def export(self, outfile, level, namespace_='widar:', name_='blbProdIntegration', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='blbProdIntegration')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='blbProdIntegration'):
        if self.ccIntegFactor is not None and 'ccIntegFactor' not in already_processed:
            already_processed.append('ccIntegFactor')
            outfile.write(' ccIntegFactor="%s"' % self.gds_format_integer(self.ccIntegFactor, input_name='ccIntegFactor'))
        if self.burstBlankDuration is not None and 'burstBlankDuration' not in already_processed:
            already_processed.append('burstBlankDuration')
            outfile.write(' burstBlankDuration="%s"' % self.gds_format_integer(self.burstBlankDuration, input_name='burstBlankDuration'))
        if self.pauseBetweenBursts is not None and 'pauseBetweenBursts' not in already_processed:
            already_processed.append('pauseBetweenBursts')
            outfile.write(' pauseBetweenBursts="%s"' % self.gds_format_integer(self.pauseBetweenBursts, input_name='pauseBetweenBursts'))
        if self.numRollingBursts is not None and 'numRollingBursts' not in already_processed:
            already_processed.append('numRollingBursts')
            outfile.write(' numRollingBursts="%s"' % self.gds_format_integer(self.numRollingBursts, input_name='numRollingBursts'))
        if self.cbeIntegFactor is not None and 'cbeIntegFactor' not in already_processed:
            already_processed.append('cbeIntegFactor')
            outfile.write(' cbeIntegFactor="%s"' % self.gds_format_integer(self.cbeIntegFactor, input_name='cbeIntegFactor'))
        if self.recirculation is not None and 'recirculation' not in already_processed:
            already_processed.append('recirculation')
            outfile.write(' recirculation=%s' % (quote_attrib(self.recirculation), ))
        if self.recPhase is not None and 'recPhase' not in already_processed:
            already_processed.append('recPhase')
            outfile.write(' recPhase=%s' % (quote_attrib(self.recPhase), ))
        if self.minIntegTime is not None and 'minIntegTime' not in already_processed:
            already_processed.append('minIntegTime')
            outfile.write(' minIntegTime=%s' % (quote_attrib(self.minIntegTime), ))
        if self.burstDuration is not None and 'burstDuration' not in already_processed:
            already_processed.append('burstDuration')
            outfile.write(' burstDuration="%s"' % self.gds_format_integer(self.burstDuration, input_name='burstDuration'))
        if self.ltaIntegFactor is not None and 'ltaIntegFactor' not in already_processed:
            already_processed.append('ltaIntegFactor')
            outfile.write(' ltaIntegFactor="%s"' % self.gds_format_integer(self.ltaIntegFactor, input_name='ltaIntegFactor'))
        if self.firstBurstOffset is not None and 'firstBurstOffset' not in already_processed:
            already_processed.append('firstBurstOffset')
            outfile.write(' firstBurstOffset="%s"' % self.gds_format_integer(self.firstBurstOffset, input_name='firstBurstOffset'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='blbProdIntegration', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='blbProdIntegration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ccIntegFactor is not None and 'ccIntegFactor' not in already_processed:
            already_processed.append('ccIntegFactor')
            showIndent(outfile, level)
            outfile.write('ccIntegFactor = %d,\n' % (self.ccIntegFactor,))
        if self.burstBlankDuration is not None and 'burstBlankDuration' not in already_processed:
            already_processed.append('burstBlankDuration')
            showIndent(outfile, level)
            outfile.write('burstBlankDuration = %d,\n' % (self.burstBlankDuration,))
        if self.pauseBetweenBursts is not None and 'pauseBetweenBursts' not in already_processed:
            already_processed.append('pauseBetweenBursts')
            showIndent(outfile, level)
            outfile.write('pauseBetweenBursts = %d,\n' % (self.pauseBetweenBursts,))
        if self.numRollingBursts is not None and 'numRollingBursts' not in already_processed:
            already_processed.append('numRollingBursts')
            showIndent(outfile, level)
            outfile.write('numRollingBursts = %d,\n' % (self.numRollingBursts,))
        if self.cbeIntegFactor is not None and 'cbeIntegFactor' not in already_processed:
            already_processed.append('cbeIntegFactor')
            showIndent(outfile, level)
            outfile.write('cbeIntegFactor = %d,\n' % (self.cbeIntegFactor,))
        if self.recirculation is not None and 'recirculation' not in already_processed:
            already_processed.append('recirculation')
            showIndent(outfile, level)
            outfile.write('recirculation = %s,\n' % (self.recirculation,))
        if self.recPhase is not None and 'recPhase' not in already_processed:
            already_processed.append('recPhase')
            showIndent(outfile, level)
            outfile.write('recPhase = %s,\n' % (self.recPhase,))
        if self.minIntegTime is not None and 'minIntegTime' not in already_processed:
            already_processed.append('minIntegTime')
            showIndent(outfile, level)
            outfile.write('minIntegTime = %s,\n' % (self.minIntegTime,))
        if self.burstDuration is not None and 'burstDuration' not in already_processed:
            already_processed.append('burstDuration')
            showIndent(outfile, level)
            outfile.write('burstDuration = %d,\n' % (self.burstDuration,))
        if self.ltaIntegFactor is not None and 'ltaIntegFactor' not in already_processed:
            already_processed.append('ltaIntegFactor')
            showIndent(outfile, level)
            outfile.write('ltaIntegFactor = %d,\n' % (self.ltaIntegFactor,))
        if self.firstBurstOffset is not None and 'firstBurstOffset' not in already_processed:
            already_processed.append('firstBurstOffset')
            showIndent(outfile, level)
            outfile.write('firstBurstOffset = %d,\n' % (self.firstBurstOffset,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ccIntegFactor', node)
        if value is not None and 'ccIntegFactor' not in already_processed:
            already_processed.append('ccIntegFactor')
            try:
                self.ccIntegFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('burstBlankDuration', node)
        if value is not None and 'burstBlankDuration' not in already_processed:
            already_processed.append('burstBlankDuration')
            try:
                self.burstBlankDuration = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('pauseBetweenBursts', node)
        if value is not None and 'pauseBetweenBursts' not in already_processed:
            already_processed.append('pauseBetweenBursts')
            try:
                self.pauseBetweenBursts = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numRollingBursts', node)
        if value is not None and 'numRollingBursts' not in already_processed:
            already_processed.append('numRollingBursts')
            try:
                self.numRollingBursts = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cbeIntegFactor', node)
        if value is not None and 'cbeIntegFactor' not in already_processed:
            already_processed.append('cbeIntegFactor')
            try:
                self.cbeIntegFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('recirculation', node)
        if value is not None and 'recirculation' not in already_processed:
            already_processed.append('recirculation')
            self.recirculation = value
        value = find_attr_value_('recPhase', node)
        if value is not None and 'recPhase' not in already_processed:
            already_processed.append('recPhase')
            self.recPhase = value
        value = find_attr_value_('minIntegTime', node)
        if value is not None and 'minIntegTime' not in already_processed:
            already_processed.append('minIntegTime')
            self.minIntegTime = value
        value = find_attr_value_('burstDuration', node)
        if value is not None and 'burstDuration' not in already_processed:
            already_processed.append('burstDuration')
            try:
                self.burstDuration = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ltaIntegFactor', node)
        if value is not None and 'ltaIntegFactor' not in already_processed:
            already_processed.append('ltaIntegFactor')
            try:
                self.ltaIntegFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('firstBurstOffset', node)
        if value is not None and 'firstBurstOffset' not in already_processed:
            already_processed.append('firstBurstOffset')
            try:
                self.firstBurstOffset = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class blbProdIntegration


class phaseBinning(GeneratedsSuper):
    """Default implemented by CM: numBins if not specified, assumed to be
    1. Default implemented by CMIB: maxHwIntegTime 500 micro
    seconds. Default for numBins not specified in schema; if
    specified, JAXB adds default to messages. maxHwIntegTime, if not
    specified is not specified in CMIB configuration and CMIB
    assumes 500 micro seconds."""
    subclass = None
    superclass = None
    def __init__(self, phase=None, binWidth=None, numBins=None):
        self.phase = _cast(None, phase)
        self.binWidth = _cast(None, binWidth)
        self.numBins = _cast(None, numBins)
        pass
    def factory(*args_, **kwargs_):
        if phaseBinning.subclass:
            return phaseBinning.subclass(*args_, **kwargs_)
        else:
            return phaseBinning(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_binWidth(self): return self.binWidth
    def set_binWidth(self, binWidth): self.binWidth = binWidth
    def get_numBins(self): return self.numBins
    def set_numBins(self, numBins): self.numBins = numBins
    def export(self, outfile, level, namespace_='widar:', name_='phaseBinning', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='phaseBinning')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='phaseBinning'):
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            outfile.write(' phase=%s' % (quote_attrib(self.phase), ))
        if self.binWidth is not None and 'binWidth' not in already_processed:
            already_processed.append('binWidth')
            outfile.write(' binWidth=%s' % (quote_attrib(self.binWidth), ))
        if self.numBins is not None and 'numBins' not in already_processed:
            already_processed.append('numBins')
            outfile.write(' numBins=%s' % (quote_attrib(self.numBins), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='phaseBinning', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='phaseBinning'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            showIndent(outfile, level)
            outfile.write('phase = %s,\n' % (self.phase,))
        if self.binWidth is not None and 'binWidth' not in already_processed:
            already_processed.append('binWidth')
            showIndent(outfile, level)
            outfile.write('binWidth = %s,\n' % (self.binWidth,))
        if self.numBins is not None and 'numBins' not in already_processed:
            already_processed.append('numBins')
            showIndent(outfile, level)
            outfile.write('numBins = %s,\n' % (self.numBins,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            self.phase = value
        value = find_attr_value_('binWidth', node)
        if value is not None and 'binWidth' not in already_processed:
            already_processed.append('binWidth')
            self.binWidth = value
        value = find_attr_value_('numBins', node)
        if value is not None and 'numBins' not in already_processed:
            already_processed.append('numBins')
            self.numBins = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class phaseBinning


class blbPair(GeneratedsSuper):
    """List of Baseline Board Pairs to be used for a particular subband
    Acronym ifd stands for Inter-Frame Delay"""
    subclass = None
    superclass = None
    def __init__(self, quadrant=None, numBlbPairs=None, ifd=None, ifdRandom=None, firstBlbPair=None):
        self.quadrant = _cast(None, quadrant)
        self.numBlbPairs = _cast(None, numBlbPairs)
        self.ifd = _cast(None, ifd)
        self.ifdRandom = _cast(None, ifdRandom)
        self.firstBlbPair = _cast(None, firstBlbPair)
        pass
    def factory(*args_, **kwargs_):
        if blbPair.subclass:
            return blbPair.subclass(*args_, **kwargs_)
        else:
            return blbPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quadrant(self): return self.quadrant
    def set_quadrant(self, quadrant): self.quadrant = quadrant
    def get_numBlbPairs(self): return self.numBlbPairs
    def set_numBlbPairs(self, numBlbPairs): self.numBlbPairs = numBlbPairs
    def get_ifd(self): return self.ifd
    def set_ifd(self, ifd): self.ifd = ifd
    def get_ifdRandom(self): return self.ifdRandom
    def set_ifdRandom(self, ifdRandom): self.ifdRandom = ifdRandom
    def get_firstBlbPair(self): return self.firstBlbPair
    def set_firstBlbPair(self, firstBlbPair): self.firstBlbPair = firstBlbPair
    def export(self, outfile, level, namespace_='widar:', name_='blbPair', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='blbPair')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='blbPair'):
        if self.quadrant is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            outfile.write(' quadrant=%s' % (quote_attrib(self.quadrant), ))
        if self.numBlbPairs is not None and 'numBlbPairs' not in already_processed:
            already_processed.append('numBlbPairs')
            outfile.write(' numBlbPairs=%s' % (quote_attrib(self.numBlbPairs), ))
        if self.ifd is not None and 'ifd' not in already_processed:
            already_processed.append('ifd')
            outfile.write(' ifd=%s' % (quote_attrib(self.ifd), ))
        if self.ifdRandom is not None and 'ifdRandom' not in already_processed:
            already_processed.append('ifdRandom')
            outfile.write(' ifdRandom=%s' % (quote_attrib(self.ifdRandom), ))
        if self.firstBlbPair is not None and 'firstBlbPair' not in already_processed:
            already_processed.append('firstBlbPair')
            outfile.write(' firstBlbPair=%s' % (quote_attrib(self.firstBlbPair), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='blbPair', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='blbPair'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quadrant is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            showIndent(outfile, level)
            outfile.write('quadrant = %s,\n' % (self.quadrant,))
        if self.numBlbPairs is not None and 'numBlbPairs' not in already_processed:
            already_processed.append('numBlbPairs')
            showIndent(outfile, level)
            outfile.write('numBlbPairs = %s,\n' % (self.numBlbPairs,))
        if self.ifd is not None and 'ifd' not in already_processed:
            already_processed.append('ifd')
            showIndent(outfile, level)
            outfile.write('ifd = %s,\n' % (self.ifd,))
        if self.ifdRandom is not None and 'ifdRandom' not in already_processed:
            already_processed.append('ifdRandom')
            showIndent(outfile, level)
            outfile.write('ifdRandom = %s,\n' % (self.ifdRandom,))
        if self.firstBlbPair is not None and 'firstBlbPair' not in already_processed:
            already_processed.append('firstBlbPair')
            showIndent(outfile, level)
            outfile.write('firstBlbPair = %s,\n' % (self.firstBlbPair,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quadrant', node)
        if value is not None and 'quadrant' not in already_processed:
            already_processed.append('quadrant')
            self.quadrant = value
        value = find_attr_value_('numBlbPairs', node)
        if value is not None and 'numBlbPairs' not in already_processed:
            already_processed.append('numBlbPairs')
            self.numBlbPairs = value
        value = find_attr_value_('ifd', node)
        if value is not None and 'ifd' not in already_processed:
            already_processed.append('ifd')
            self.ifd = value
        value = find_attr_value_('ifdRandom', node)
        if value is not None and 'ifdRandom' not in already_processed:
            already_processed.append('ifdRandom')
            self.ifdRandom = value
        value = find_attr_value_('firstBlbPair', node)
        if value is not None and 'firstBlbPair' not in already_processed:
            already_processed.append('firstBlbPair')
            self.firstBlbPair = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class blbPair


class summedArray(GeneratedsSuper):
    """The sum of the subarray. List of Baseline Boards: If specified in
    summedArray choice applies both for cc and vdif. If not
    specified at all, CM will use Baseline Boards specified in
    element polProducts."""
    subclass = None
    superclass = None
    def __init__(self, integTime=None, autoIntegration=None, continuousInteg=None, headroom6dB=None, zeroFillInvalidData=None, modifyExcludeStations=None, applyIntegInHw=None, sid=None, excludeStations=None, blbPair=None, cc=None, vdif=None):
        self.integTime = _cast(int, integTime)
        self.autoIntegration = _cast(bool, autoIntegration)
        self.continuousInteg = _cast(bool, continuousInteg)
        self.headroom6dB = _cast(bool, headroom6dB)
        self.zeroFillInvalidData = _cast(bool, zeroFillInvalidData)
        self.modifyExcludeStations = _cast(bool, modifyExcludeStations)
        self.applyIntegInHw = _cast(bool, applyIntegInHw)
        self.sid = _cast(None, sid)
        self.excludeStations = _cast(None, excludeStations)
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        self.cc = cc
        self.vdif = vdif
    def factory(*args_, **kwargs_):
        if summedArray.subclass:
            return summedArray.subclass(*args_, **kwargs_)
        else:
            return summedArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_cc(self): return self.cc
    def set_cc(self, cc): self.cc = cc
    def get_vdif(self): return self.vdif
    def set_vdif(self, vdif): self.vdif = vdif
    def get_integTime(self): return self.integTime
    def set_integTime(self, integTime): self.integTime = integTime
    def get_autoIntegration(self): return self.autoIntegration
    def set_autoIntegration(self, autoIntegration): self.autoIntegration = autoIntegration
    def get_continuousInteg(self): return self.continuousInteg
    def set_continuousInteg(self, continuousInteg): self.continuousInteg = continuousInteg
    def get_headroom6dB(self): return self.headroom6dB
    def set_headroom6dB(self, headroom6dB): self.headroom6dB = headroom6dB
    def get_zeroFillInvalidData(self): return self.zeroFillInvalidData
    def set_zeroFillInvalidData(self, zeroFillInvalidData): self.zeroFillInvalidData = zeroFillInvalidData
    def get_modifyExcludeStations(self): return self.modifyExcludeStations
    def set_modifyExcludeStations(self, modifyExcludeStations): self.modifyExcludeStations = modifyExcludeStations
    def get_applyIntegInHw(self): return self.applyIntegInHw
    def set_applyIntegInHw(self, applyIntegInHw): self.applyIntegInHw = applyIntegInHw
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_excludeStations(self): return self.excludeStations
    def set_excludeStations(self, excludeStations): self.excludeStations = excludeStations
    def export(self, outfile, level, namespace_='widar:', name_='summedArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='summedArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='summedArray'):
        if self.integTime is not None and 'integTime' not in already_processed:
            already_processed.append('integTime')
            outfile.write(' integTime="%s"' % self.gds_format_integer(self.integTime, input_name='integTime'))
        if self.autoIntegration is not None and 'autoIntegration' not in already_processed:
            already_processed.append('autoIntegration')
            outfile.write(' autoIntegration="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.autoIntegration)), input_name='autoIntegration'))
        if self.continuousInteg is not None and 'continuousInteg' not in already_processed:
            already_processed.append('continuousInteg')
            outfile.write(' continuousInteg="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.continuousInteg)), input_name='continuousInteg'))
        if self.headroom6dB is not None and 'headroom6dB' not in already_processed:
            already_processed.append('headroom6dB')
            outfile.write(' headroom6dB="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.headroom6dB)), input_name='headroom6dB'))
        if self.zeroFillInvalidData is not None and 'zeroFillInvalidData' not in already_processed:
            already_processed.append('zeroFillInvalidData')
            outfile.write(' zeroFillInvalidData="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.zeroFillInvalidData)), input_name='zeroFillInvalidData'))
        if self.modifyExcludeStations is not None and 'modifyExcludeStations' not in already_processed:
            already_processed.append('modifyExcludeStations')
            outfile.write(' modifyExcludeStations="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.modifyExcludeStations)), input_name='modifyExcludeStations'))
        if self.applyIntegInHw is not None and 'applyIntegInHw' not in already_processed:
            already_processed.append('applyIntegInHw')
            outfile.write(' applyIntegInHw="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.applyIntegInHw)), input_name='applyIntegInHw'))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            outfile.write(' sid=%s' % (quote_attrib(self.sid), ))
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            outfile.write(' excludeStations=%s' % (quote_attrib(self.excludeStations), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='summedArray', fromsubclass_=False):
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        if self.cc:
            self.cc.export(outfile, level, namespace_, name_='cc')
        if self.vdif:
            self.vdif.export(outfile, level, namespace_, name_='vdif')
    def hasContent_(self):
        if (
            self.blbPair or
            self.cc is not None or
            self.vdif is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='summedArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.integTime is not None and 'integTime' not in already_processed:
            already_processed.append('integTime')
            showIndent(outfile, level)
            outfile.write('integTime = %d,\n' % (self.integTime,))
        if self.autoIntegration is not None and 'autoIntegration' not in already_processed:
            already_processed.append('autoIntegration')
            showIndent(outfile, level)
            outfile.write('autoIntegration = %s,\n' % (self.autoIntegration,))
        if self.continuousInteg is not None and 'continuousInteg' not in already_processed:
            already_processed.append('continuousInteg')
            showIndent(outfile, level)
            outfile.write('continuousInteg = %s,\n' % (self.continuousInteg,))
        if self.headroom6dB is not None and 'headroom6dB' not in already_processed:
            already_processed.append('headroom6dB')
            showIndent(outfile, level)
            outfile.write('headroom6dB = %s,\n' % (self.headroom6dB,))
        if self.zeroFillInvalidData is not None and 'zeroFillInvalidData' not in already_processed:
            already_processed.append('zeroFillInvalidData')
            showIndent(outfile, level)
            outfile.write('zeroFillInvalidData = %s,\n' % (self.zeroFillInvalidData,))
        if self.modifyExcludeStations is not None and 'modifyExcludeStations' not in already_processed:
            already_processed.append('modifyExcludeStations')
            showIndent(outfile, level)
            outfile.write('modifyExcludeStations = %s,\n' % (self.modifyExcludeStations,))
        if self.applyIntegInHw is not None and 'applyIntegInHw' not in already_processed:
            already_processed.append('applyIntegInHw')
            showIndent(outfile, level)
            outfile.write('applyIntegInHw = %s,\n' % (self.applyIntegInHw,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            showIndent(outfile, level)
            outfile.write('sid = %s,\n' % (self.sid,))
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            showIndent(outfile, level)
            outfile.write('excludeStations = %s,\n' % (self.excludeStations,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cc is not None:
            showIndent(outfile, level)
            outfile.write('cc=model_.cc(\n')
            self.cc.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vdif is not None:
            showIndent(outfile, level)
            outfile.write('vdif=model_.vdif(\n')
            self.vdif.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('integTime', node)
        if value is not None and 'integTime' not in already_processed:
            already_processed.append('integTime')
            try:
                self.integTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('autoIntegration', node)
        if value is not None and 'autoIntegration' not in already_processed:
            already_processed.append('autoIntegration')
            if value in ('true', '1'):
                self.autoIntegration = True
            elif value in ('false', '0'):
                self.autoIntegration = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('continuousInteg', node)
        if value is not None and 'continuousInteg' not in already_processed:
            already_processed.append('continuousInteg')
            if value in ('true', '1'):
                self.continuousInteg = True
            elif value in ('false', '0'):
                self.continuousInteg = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('headroom6dB', node)
        if value is not None and 'headroom6dB' not in already_processed:
            already_processed.append('headroom6dB')
            if value in ('true', '1'):
                self.headroom6dB = True
            elif value in ('false', '0'):
                self.headroom6dB = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('zeroFillInvalidData', node)
        if value is not None and 'zeroFillInvalidData' not in already_processed:
            already_processed.append('zeroFillInvalidData')
            if value in ('true', '1'):
                self.zeroFillInvalidData = True
            elif value in ('false', '0'):
                self.zeroFillInvalidData = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('modifyExcludeStations', node)
        if value is not None and 'modifyExcludeStations' not in already_processed:
            already_processed.append('modifyExcludeStations')
            if value in ('true', '1'):
                self.modifyExcludeStations = True
            elif value in ('false', '0'):
                self.modifyExcludeStations = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('applyIntegInHw', node)
        if value is not None and 'applyIntegInHw' not in already_processed:
            already_processed.append('applyIntegInHw')
            if value in ('true', '1'):
                self.applyIntegInHw = True
            elif value in ('false', '0'):
                self.applyIntegInHw = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.append('sid')
            self.sid = value
        value = find_attr_value_('excludeStations', node)
        if value is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            self.excludeStations = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'cc':
            obj_ = cc.factory()
            obj_.build(child_)
            self.set_cc(obj_)
        elif nodeName_ == 'vdif':
            obj_ = vdif.factory()
            obj_.build(child_)
            self.set_vdif(obj_)
# end class summedArray


class modifySummedArray(GeneratedsSuper):
    """Modify summed array - If the action=modify can be specified in
    element subarray or per subband. 2012-04-13 SV : Not
    implemented. Need to check is this required. If not, should be
    removed from the schema."""
    subclass = None
    superclass = None
    def __init__(self, excludeStations=None, vdifEnableA=None, vdifEnableB=None):
        self.excludeStations = _cast(None, excludeStations)
        self.vdifEnableA = _cast(bool, vdifEnableA)
        self.vdifEnableB = _cast(bool, vdifEnableB)
        pass
    def factory(*args_, **kwargs_):
        if modifySummedArray.subclass:
            return modifySummedArray.subclass(*args_, **kwargs_)
        else:
            return modifySummedArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_excludeStations(self): return self.excludeStations
    def set_excludeStations(self, excludeStations): self.excludeStations = excludeStations
    def get_vdifEnableA(self): return self.vdifEnableA
    def set_vdifEnableA(self, vdifEnableA): self.vdifEnableA = vdifEnableA
    def get_vdifEnableB(self): return self.vdifEnableB
    def set_vdifEnableB(self, vdifEnableB): self.vdifEnableB = vdifEnableB
    def export(self, outfile, level, namespace_='widar:', name_='modifySummedArray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modifySummedArray')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='modifySummedArray'):
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            outfile.write(' excludeStations=%s' % (quote_attrib(self.excludeStations), ))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            outfile.write(' vdifEnableA="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableA)), input_name='vdifEnableA'))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            outfile.write(' vdifEnableB="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableB)), input_name='vdifEnableB'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='modifySummedArray', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modifySummedArray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.excludeStations is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            showIndent(outfile, level)
            outfile.write('excludeStations = %s,\n' % (self.excludeStations,))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            showIndent(outfile, level)
            outfile.write('vdifEnableA = %s,\n' % (self.vdifEnableA,))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            showIndent(outfile, level)
            outfile.write('vdifEnableB = %s,\n' % (self.vdifEnableB,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('excludeStations', node)
        if value is not None and 'excludeStations' not in already_processed:
            already_processed.append('excludeStations')
            self.excludeStations = value
        value = find_attr_value_('vdifEnableA', node)
        if value is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            if value in ('true', '1'):
                self.vdifEnableA = True
            elif value in ('false', '0'):
                self.vdifEnableA = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdifEnableB', node)
        if value is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            if value in ('true', '1'):
                self.vdifEnableB = True
            elif value in ('false', '0'):
                self.vdifEnableB = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modifySummedArray


class cc(GeneratedsSuper):
    """Send summed data to the Correlator Chip Array"""
    subclass = None
    superclass = None
    def __init__(self, agcEnabled=True, requantGain=None, agcRms=None, pp=None, blbPair=None, blbProdIntegration=None):
        self.agcEnabled = _cast(bool, agcEnabled)
        self.requantGain = _cast(None, requantGain)
        self.agcRms = _cast(float, agcRms)
        if pp is None:
            self.pp = []
        else:
            self.pp = pp
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
        self.blbProdIntegration = blbProdIntegration
    def factory(*args_, **kwargs_):
        if cc.subclass:
            return cc.subclass(*args_, **kwargs_)
        else:
            return cc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pp(self): return self.pp
    def set_pp(self, pp): self.pp = pp
    def add_pp(self, value): self.pp.append(value)
    def insert_pp(self, index, value): self.pp[index] = value
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_blbProdIntegration(self): return self.blbProdIntegration
    def set_blbProdIntegration(self, blbProdIntegration): self.blbProdIntegration = blbProdIntegration
    def get_agcEnabled(self): return self.agcEnabled
    def set_agcEnabled(self, agcEnabled): self.agcEnabled = agcEnabled
    def get_requantGain(self): return self.requantGain
    def set_requantGain(self, requantGain): self.requantGain = requantGain
    def get_agcRms(self): return self.agcRms
    def set_agcRms(self, agcRms): self.agcRms = agcRms
    def export(self, outfile, level, namespace_='widar:', name_='cc', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cc')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cc'):
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            outfile.write(' agcEnabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.agcEnabled)), input_name='agcEnabled'))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            outfile.write(' requantGain=%s' % (quote_attrib(self.requantGain), ))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            outfile.write(' agcRms="%s"' % self.gds_format_float(self.agcRms, input_name='agcRms'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cc', fromsubclass_=False):
        for pp_ in self.pp:
            pp_.export(outfile, level, namespace_, name_='pp')
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
        if self.blbProdIntegration:
            self.blbProdIntegration.export(outfile, level, namespace_, name_='blbProdIntegration')
    def hasContent_(self):
        if (
            self.pp or
            self.blbPair or
            self.blbProdIntegration is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cc'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            showIndent(outfile, level)
            outfile.write('agcEnabled = %s,\n' % (self.agcEnabled,))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            showIndent(outfile, level)
            outfile.write('requantGain = %s,\n' % (self.requantGain,))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            showIndent(outfile, level)
            outfile.write('agcRms = %f,\n' % (self.agcRms,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pp=[\n')
        level += 1
        for pp_ in self.pp:
            showIndent(outfile, level)
            outfile.write('model_.pp(\n')
            pp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.blbProdIntegration is not None:
            showIndent(outfile, level)
            outfile.write('blbProdIntegration=model_.blbProdIntegration(\n')
            self.blbProdIntegration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agcEnabled', node)
        if value is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            if value in ('true', '1'):
                self.agcEnabled = True
            elif value in ('false', '0'):
                self.agcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('requantGain', node)
        if value is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            self.requantGain = value
        value = find_attr_value_('agcRms', node)
        if value is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            try:
                self.agcRms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (agcRms): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pp':
            obj_ = pp.factory()
            obj_.build(child_)
            self.pp.append(obj_)
        elif nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
        elif nodeName_ == 'blbProdIntegration':
            obj_ = blbProdIntegration.factory()
            obj_.build(child_)
            self.set_blbProdIntegration(obj_)
# end class cc


class vdif(GeneratedsSuper):
    """Send the sum of a subarray to VDIF output Default value for VDIF
    frame size is 1250 (enforced by CM). Default enforced by CM: a)
    vdifEnable=false b) agcEnabled=true. c) epoch and epochOffset
    are required parameters in "create subarray" """
    subclass = None
    superclass = None
    def __init__(self, bThread=None, bDestIP=None, frameSize=None, aDestMAC='12:34:56:78:90:00', agcEnabled=None, aDestPort='12002', bPacketDelay=None, epoch=None, aThread=None, aDestIP='192.168.0.21', stationId=None, bDestMAC=None, vdifEnableA=None, epochOffset=None, aPacketDelay=None, vdifEnableB=None, bDestPort=None, numBits='2', requantGain=None, agcRms=None, blbPair=None):
        self.bThread = _cast(None, bThread)
        self.bDestIP = _cast(None, bDestIP)
        self.frameSize = _cast(None, frameSize)
        self.aDestMAC = _cast(None, aDestMAC)
        self.agcEnabled = _cast(bool, agcEnabled)
        self.aDestPort = _cast(None, aDestPort)
        self.bPacketDelay = _cast(None, bPacketDelay)
        self.epoch = _cast(None, epoch)
        self.aThread = _cast(None, aThread)
        self.aDestIP = _cast(None, aDestIP)
        self.stationId = _cast(None, stationId)
        self.bDestMAC = _cast(None, bDestMAC)
        self.vdifEnableA = _cast(bool, vdifEnableA)
        self.epochOffset = _cast(int, epochOffset)
        self.aPacketDelay = _cast(None, aPacketDelay)
        self.vdifEnableB = _cast(bool, vdifEnableB)
        self.bDestPort = _cast(None, bDestPort)
        self.numBits = _cast(None, numBits)
        self.requantGain = _cast(None, requantGain)
        self.agcRms = _cast(float, agcRms)
        if blbPair is None:
            self.blbPair = []
        else:
            self.blbPair = blbPair
    def factory(*args_, **kwargs_):
        if vdif.subclass:
            return vdif.subclass(*args_, **kwargs_)
        else:
            return vdif(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_blbPair(self): return self.blbPair
    def set_blbPair(self, blbPair): self.blbPair = blbPair
    def add_blbPair(self, value): self.blbPair.append(value)
    def insert_blbPair(self, index, value): self.blbPair[index] = value
    def get_bThread(self): return self.bThread
    def set_bThread(self, bThread): self.bThread = bThread
    def get_bDestIP(self): return self.bDestIP
    def set_bDestIP(self, bDestIP): self.bDestIP = bDestIP
    def get_frameSize(self): return self.frameSize
    def set_frameSize(self, frameSize): self.frameSize = frameSize
    def get_aDestMAC(self): return self.aDestMAC
    def set_aDestMAC(self, aDestMAC): self.aDestMAC = aDestMAC
    def get_agcEnabled(self): return self.agcEnabled
    def set_agcEnabled(self, agcEnabled): self.agcEnabled = agcEnabled
    def get_aDestPort(self): return self.aDestPort
    def set_aDestPort(self, aDestPort): self.aDestPort = aDestPort
    def get_bPacketDelay(self): return self.bPacketDelay
    def set_bPacketDelay(self, bPacketDelay): self.bPacketDelay = bPacketDelay
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_aThread(self): return self.aThread
    def set_aThread(self, aThread): self.aThread = aThread
    def get_aDestIP(self): return self.aDestIP
    def set_aDestIP(self, aDestIP): self.aDestIP = aDestIP
    def get_stationId(self): return self.stationId
    def set_stationId(self, stationId): self.stationId = stationId
    def get_bDestMAC(self): return self.bDestMAC
    def set_bDestMAC(self, bDestMAC): self.bDestMAC = bDestMAC
    def get_vdifEnableA(self): return self.vdifEnableA
    def set_vdifEnableA(self, vdifEnableA): self.vdifEnableA = vdifEnableA
    def get_epochOffset(self): return self.epochOffset
    def set_epochOffset(self, epochOffset): self.epochOffset = epochOffset
    def get_aPacketDelay(self): return self.aPacketDelay
    def set_aPacketDelay(self, aPacketDelay): self.aPacketDelay = aPacketDelay
    def get_vdifEnableB(self): return self.vdifEnableB
    def set_vdifEnableB(self, vdifEnableB): self.vdifEnableB = vdifEnableB
    def get_bDestPort(self): return self.bDestPort
    def set_bDestPort(self, bDestPort): self.bDestPort = bDestPort
    def get_numBits(self): return self.numBits
    def set_numBits(self, numBits): self.numBits = numBits
    def get_requantGain(self): return self.requantGain
    def set_requantGain(self, requantGain): self.requantGain = requantGain
    def get_agcRms(self): return self.agcRms
    def set_agcRms(self, agcRms): self.agcRms = agcRms
    def export(self, outfile, level, namespace_='widar:', name_='vdif', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vdif')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vdif'):
        if self.bThread is not None and 'bThread' not in already_processed:
            already_processed.append('bThread')
            outfile.write(' bThread=%s' % (quote_attrib(self.bThread), ))
        if self.bDestIP is not None and 'bDestIP' not in already_processed:
            already_processed.append('bDestIP')
            outfile.write(' bDestIP=%s' % (quote_attrib(self.bDestIP), ))
        if self.frameSize is not None and 'frameSize' not in already_processed:
            already_processed.append('frameSize')
            outfile.write(' frameSize=%s' % (quote_attrib(self.frameSize), ))
        if self.aDestMAC is not None and 'aDestMAC' not in already_processed:
            already_processed.append('aDestMAC')
            outfile.write(' aDestMAC=%s' % (self.gds_format_string(quote_attrib(self.aDestMAC).encode(ExternalEncoding), input_name='aDestMAC'), ))
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            outfile.write(' agcEnabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.agcEnabled)), input_name='agcEnabled'))
        if self.aDestPort is not None and 'aDestPort' not in already_processed:
            already_processed.append('aDestPort')
            outfile.write(' aDestPort=%s' % (self.gds_format_string(quote_attrib(self.aDestPort).encode(ExternalEncoding), input_name='aDestPort'), ))
        if self.bPacketDelay is not None and 'bPacketDelay' not in already_processed:
            already_processed.append('bPacketDelay')
            outfile.write(' bPacketDelay=%s' % (quote_attrib(self.bPacketDelay), ))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (quote_attrib(self.epoch), ))
        if self.aThread is not None and 'aThread' not in already_processed:
            already_processed.append('aThread')
            outfile.write(' aThread=%s' % (quote_attrib(self.aThread), ))
        if self.aDestIP is not None and 'aDestIP' not in already_processed:
            already_processed.append('aDestIP')
            outfile.write(' aDestIP=%s' % (quote_attrib(self.aDestIP), ))
        if self.stationId is not None and 'stationId' not in already_processed:
            already_processed.append('stationId')
            outfile.write(' stationId=%s' % (quote_attrib(self.stationId), ))
        if self.bDestMAC is not None and 'bDestMAC' not in already_processed:
            already_processed.append('bDestMAC')
            outfile.write(' bDestMAC=%s' % (self.gds_format_string(quote_attrib(self.bDestMAC).encode(ExternalEncoding), input_name='bDestMAC'), ))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            outfile.write(' vdifEnableA="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableA)), input_name='vdifEnableA'))
        if self.epochOffset is not None and 'epochOffset' not in already_processed:
            already_processed.append('epochOffset')
            outfile.write(' epochOffset="%s"' % self.gds_format_integer(self.epochOffset, input_name='epochOffset'))
        if self.aPacketDelay is not None and 'aPacketDelay' not in already_processed:
            already_processed.append('aPacketDelay')
            outfile.write(' aPacketDelay=%s' % (quote_attrib(self.aPacketDelay), ))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            outfile.write(' vdifEnableB="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.vdifEnableB)), input_name='vdifEnableB'))
        if self.bDestPort is not None and 'bDestPort' not in already_processed:
            already_processed.append('bDestPort')
            outfile.write(' bDestPort=%s' % (self.gds_format_string(quote_attrib(self.bDestPort).encode(ExternalEncoding), input_name='bDestPort'), ))
        if self.numBits is not None and 'numBits' not in already_processed:
            already_processed.append('numBits')
            outfile.write(' numBits=%s' % (quote_attrib(self.numBits), ))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            outfile.write(' requantGain=%s' % (quote_attrib(self.requantGain), ))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            outfile.write(' agcRms="%s"' % self.gds_format_float(self.agcRms, input_name='agcRms'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vdif', fromsubclass_=False):
        for blbPair_ in self.blbPair:
            blbPair_.export(outfile, level, namespace_, name_='blbPair')
    def hasContent_(self):
        if (
            self.blbPair
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vdif'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bThread is not None and 'bThread' not in already_processed:
            already_processed.append('bThread')
            showIndent(outfile, level)
            outfile.write('bThread = %s,\n' % (self.bThread,))
        if self.bDestIP is not None and 'bDestIP' not in already_processed:
            already_processed.append('bDestIP')
            showIndent(outfile, level)
            outfile.write('bDestIP = %s,\n' % (self.bDestIP,))
        if self.frameSize is not None and 'frameSize' not in already_processed:
            already_processed.append('frameSize')
            showIndent(outfile, level)
            outfile.write('frameSize = %s,\n' % (self.frameSize,))
        if self.aDestMAC is not None and 'aDestMAC' not in already_processed:
            already_processed.append('aDestMAC')
            showIndent(outfile, level)
            outfile.write('aDestMAC = "%s",\n' % (self.aDestMAC,))
        if self.agcEnabled is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            showIndent(outfile, level)
            outfile.write('agcEnabled = %s,\n' % (self.agcEnabled,))
        if self.aDestPort is not None and 'aDestPort' not in already_processed:
            already_processed.append('aDestPort')
            showIndent(outfile, level)
            outfile.write('aDestPort = "%s",\n' % (self.aDestPort,))
        if self.bPacketDelay is not None and 'bPacketDelay' not in already_processed:
            already_processed.append('bPacketDelay')
            showIndent(outfile, level)
            outfile.write('bPacketDelay = %s,\n' % (self.bPacketDelay,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = %s,\n' % (self.epoch,))
        if self.aThread is not None and 'aThread' not in already_processed:
            already_processed.append('aThread')
            showIndent(outfile, level)
            outfile.write('aThread = %s,\n' % (self.aThread,))
        if self.aDestIP is not None and 'aDestIP' not in already_processed:
            already_processed.append('aDestIP')
            showIndent(outfile, level)
            outfile.write('aDestIP = %s,\n' % (self.aDestIP,))
        if self.stationId is not None and 'stationId' not in already_processed:
            already_processed.append('stationId')
            showIndent(outfile, level)
            outfile.write('stationId = %s,\n' % (self.stationId,))
        if self.bDestMAC is not None and 'bDestMAC' not in already_processed:
            already_processed.append('bDestMAC')
            showIndent(outfile, level)
            outfile.write('bDestMAC = "%s",\n' % (self.bDestMAC,))
        if self.vdifEnableA is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            showIndent(outfile, level)
            outfile.write('vdifEnableA = %s,\n' % (self.vdifEnableA,))
        if self.epochOffset is not None and 'epochOffset' not in already_processed:
            already_processed.append('epochOffset')
            showIndent(outfile, level)
            outfile.write('epochOffset = %d,\n' % (self.epochOffset,))
        if self.aPacketDelay is not None and 'aPacketDelay' not in already_processed:
            already_processed.append('aPacketDelay')
            showIndent(outfile, level)
            outfile.write('aPacketDelay = %s,\n' % (self.aPacketDelay,))
        if self.vdifEnableB is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            showIndent(outfile, level)
            outfile.write('vdifEnableB = %s,\n' % (self.vdifEnableB,))
        if self.bDestPort is not None and 'bDestPort' not in already_processed:
            already_processed.append('bDestPort')
            showIndent(outfile, level)
            outfile.write('bDestPort = "%s",\n' % (self.bDestPort,))
        if self.numBits is not None and 'numBits' not in already_processed:
            already_processed.append('numBits')
            showIndent(outfile, level)
            outfile.write('numBits = %s,\n' % (self.numBits,))
        if self.requantGain is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            showIndent(outfile, level)
            outfile.write('requantGain = %s,\n' % (self.requantGain,))
        if self.agcRms is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            showIndent(outfile, level)
            outfile.write('agcRms = %f,\n' % (self.agcRms,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('blbPair=[\n')
        level += 1
        for blbPair_ in self.blbPair:
            showIndent(outfile, level)
            outfile.write('model_.blbPair(\n')
            blbPair_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bThread', node)
        if value is not None and 'bThread' not in already_processed:
            already_processed.append('bThread')
            self.bThread = value
        value = find_attr_value_('bDestIP', node)
        if value is not None and 'bDestIP' not in already_processed:
            already_processed.append('bDestIP')
            self.bDestIP = value
        value = find_attr_value_('frameSize', node)
        if value is not None and 'frameSize' not in already_processed:
            already_processed.append('frameSize')
            self.frameSize = value
        value = find_attr_value_('aDestMAC', node)
        if value is not None and 'aDestMAC' not in already_processed:
            already_processed.append('aDestMAC')
            self.aDestMAC = value
        value = find_attr_value_('agcEnabled', node)
        if value is not None and 'agcEnabled' not in already_processed:
            already_processed.append('agcEnabled')
            if value in ('true', '1'):
                self.agcEnabled = True
            elif value in ('false', '0'):
                self.agcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('aDestPort', node)
        if value is not None and 'aDestPort' not in already_processed:
            already_processed.append('aDestPort')
            self.aDestPort = value
        value = find_attr_value_('bPacketDelay', node)
        if value is not None and 'bPacketDelay' not in already_processed:
            already_processed.append('bPacketDelay')
            self.bPacketDelay = value
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('aThread', node)
        if value is not None and 'aThread' not in already_processed:
            already_processed.append('aThread')
            self.aThread = value
        value = find_attr_value_('aDestIP', node)
        if value is not None and 'aDestIP' not in already_processed:
            already_processed.append('aDestIP')
            self.aDestIP = value
        value = find_attr_value_('stationId', node)
        if value is not None and 'stationId' not in already_processed:
            already_processed.append('stationId')
            self.stationId = value
        value = find_attr_value_('bDestMAC', node)
        if value is not None and 'bDestMAC' not in already_processed:
            already_processed.append('bDestMAC')
            self.bDestMAC = value
        value = find_attr_value_('vdifEnableA', node)
        if value is not None and 'vdifEnableA' not in already_processed:
            already_processed.append('vdifEnableA')
            if value in ('true', '1'):
                self.vdifEnableA = True
            elif value in ('false', '0'):
                self.vdifEnableA = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('epochOffset', node)
        if value is not None and 'epochOffset' not in already_processed:
            already_processed.append('epochOffset')
            try:
                self.epochOffset = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('aPacketDelay', node)
        if value is not None and 'aPacketDelay' not in already_processed:
            already_processed.append('aPacketDelay')
            self.aPacketDelay = value
        value = find_attr_value_('vdifEnableB', node)
        if value is not None and 'vdifEnableB' not in already_processed:
            already_processed.append('vdifEnableB')
            if value in ('true', '1'):
                self.vdifEnableB = True
            elif value in ('false', '0'):
                self.vdifEnableB = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bDestPort', node)
        if value is not None and 'bDestPort' not in already_processed:
            already_processed.append('bDestPort')
            self.bDestPort = value
        value = find_attr_value_('numBits', node)
        if value is not None and 'numBits' not in already_processed:
            already_processed.append('numBits')
            self.numBits = value
        value = find_attr_value_('requantGain', node)
        if value is not None and 'requantGain' not in already_processed:
            already_processed.append('requantGain')
            self.requantGain = value
        value = find_attr_value_('agcRms', node)
        if value is not None and 'agcRms' not in already_processed:
            already_processed.append('agcRms')
            try:
                self.agcRms = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (agcRms): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'blbPair':
            obj_ = blbPair.factory()
            obj_.build(child_)
            self.blbPair.append(obj_)
# end class vdif


class wideBandCorrelator(GeneratedsSuper):
    """Configuration for the Station Board Wideband Correlator. For input
    from EVLA antennas, WBC products will be specified using A/B
    (Baseband pair IDs) Different format may be used for VLBI or
    other input that have more than one band in the input stream."""
    subclass = None
    superclass = None
    def __init__(self, wpp=None):
        if wpp is None:
            self.wpp = []
        else:
            self.wpp = wpp
    def factory(*args_, **kwargs_):
        if wideBandCorrelator.subclass:
            return wideBandCorrelator.subclass(*args_, **kwargs_)
        else:
            return wideBandCorrelator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wpp(self): return self.wpp
    def set_wpp(self, wpp): self.wpp = wpp
    def add_wpp(self, value): self.wpp.append(value)
    def insert_wpp(self, index, value): self.wpp[index] = value
    def export(self, outfile, level, namespace_='widar:', name_='wideBandCorrelator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wideBandCorrelator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wideBandCorrelator'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wideBandCorrelator', fromsubclass_=False):
        for wpp_ in self.wpp:
            wpp_.export(outfile, level, namespace_, name_='wpp')
    def hasContent_(self):
        if (
            self.wpp
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wideBandCorrelator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('wpp=[\n')
        level += 1
        for wpp_ in self.wpp:
            showIndent(outfile, level)
            outfile.write('model_.wpp(\n')
            wpp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'wpp':
            obj_ = wpp.factory()
            obj_.build(child_)
            self.wpp.append(obj_)
# end class wideBandCorrelator


class wpp(GeneratedsSuper):
    """Polarization Product for the Station Board Wideband Correlator. Uses
    A/B to identify which input data streams should be correlated.
    Attribute correlation changed from required to optional, so that
    correlation does not need to be specified for status=disable.
    Added attribute status - so that user can disable individual
    products. If not specified, CM assumes that product is enabled,
    examples: Enable product A*A Enable product A*B Disable product
    B*B Default values, enforced by CM: spectralChannels=64,
    integFactor=100, status=enabled."""
    subclass = None
    superclass = None
    def __init__(self, spectralChannels=None, integFactor=None, status=None, id=None, correlation=None):
        self.spectralChannels = _cast(None, spectralChannels)
        self.integFactor = _cast(int, integFactor)
        self.status = _cast(None, status)
        self.id = _cast(None, id)
        self.correlation = _cast(None, correlation)
        pass
    def factory(*args_, **kwargs_):
        if wpp.subclass:
            return wpp.subclass(*args_, **kwargs_)
        else:
            return wpp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spectralChannels(self): return self.spectralChannels
    def set_spectralChannels(self, spectralChannels): self.spectralChannels = spectralChannels
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_correlation(self): return self.correlation
    def set_correlation(self, correlation): self.correlation = correlation
    def export(self, outfile, level, namespace_='widar:', name_='wpp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wpp')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='wpp'):
        if self.spectralChannels is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            outfile.write(' spectralChannels=%s' % (quote_attrib(self.spectralChannels), ))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor="%s"' % self.gds_format_integer(self.integFactor, input_name='integFactor'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.correlation is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            outfile.write(' correlation=%s' % (quote_attrib(self.correlation), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='wpp', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wpp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.spectralChannels is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            showIndent(outfile, level)
            outfile.write('spectralChannels = %s,\n' % (self.spectralChannels,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %d,\n' % (self.integFactor,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.correlation is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            showIndent(outfile, level)
            outfile.write('correlation = %s,\n' % (self.correlation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('spectralChannels', node)
        if value is not None and 'spectralChannels' not in already_processed:
            already_processed.append('spectralChannels')
            self.spectralChannels = value
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            try:
                self.integFactor = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('correlation', node)
        if value is not None and 'correlation' not in already_processed:
            already_processed.append('correlation')
            self.correlation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wpp


class baseline(GeneratedsSuper):
    """Used to disable / enable baselines. A baseline is uniquely
    identified by a pair of station IDs. If only one Station ID is
    specified, all the baselines for that station will be
    disbled/enabled. If baseband pair (single baseband) and subband
    are not specified applies for all the products (i.e. for all the
    subbands of all the basebandes)."""
    subclass = None
    superclass = None
    def __init__(self, status=None, stationTwo=None, stationOne=None, bbB=None, bbA=None, subband=None):
        self.status = _cast(None, status)
        self.stationTwo = _cast(None, stationTwo)
        self.stationOne = _cast(None, stationOne)
        self.bbB = _cast(None, bbB)
        self.bbA = _cast(None, bbA)
        self.subband = _cast(None, subband)
        pass
    def factory(*args_, **kwargs_):
        if baseline.subclass:
            return baseline.subclass(*args_, **kwargs_)
        else:
            return baseline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_stationTwo(self): return self.stationTwo
    def set_stationTwo(self, stationTwo): self.stationTwo = stationTwo
    def get_stationOne(self): return self.stationOne
    def set_stationOne(self, stationOne): self.stationOne = stationOne
    def get_bbB(self): return self.bbB
    def set_bbB(self, bbB): self.bbB = bbB
    def get_bbA(self): return self.bbA
    def set_bbA(self, bbA): self.bbA = bbA
    def get_subband(self): return self.subband
    def set_subband(self, subband): self.subband = subband
    def export(self, outfile, level, namespace_='widar:', name_='baseline', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseline')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='baseline'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.stationTwo is not None and 'stationTwo' not in already_processed:
            already_processed.append('stationTwo')
            outfile.write(' stationTwo=%s' % (quote_attrib(self.stationTwo), ))
        if self.stationOne is not None and 'stationOne' not in already_processed:
            already_processed.append('stationOne')
            outfile.write(' stationOne=%s' % (quote_attrib(self.stationOne), ))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            outfile.write(' bbB=%s' % (quote_attrib(self.bbB), ))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            outfile.write(' bbA=%s' % (quote_attrib(self.bbA), ))
        if self.subband is not None and 'subband' not in already_processed:
            already_processed.append('subband')
            outfile.write(' subband=%s' % (quote_attrib(self.subband), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='baseline', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='baseline'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.stationTwo is not None and 'stationTwo' not in already_processed:
            already_processed.append('stationTwo')
            showIndent(outfile, level)
            outfile.write('stationTwo = %s,\n' % (self.stationTwo,))
        if self.stationOne is not None and 'stationOne' not in already_processed:
            already_processed.append('stationOne')
            showIndent(outfile, level)
            outfile.write('stationOne = %s,\n' % (self.stationOne,))
        if self.bbB is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            showIndent(outfile, level)
            outfile.write('bbB = %s,\n' % (self.bbB,))
        if self.bbA is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            showIndent(outfile, level)
            outfile.write('bbA = %s,\n' % (self.bbA,))
        if self.subband is not None and 'subband' not in already_processed:
            already_processed.append('subband')
            showIndent(outfile, level)
            outfile.write('subband = %s,\n' % (self.subband,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('stationTwo', node)
        if value is not None and 'stationTwo' not in already_processed:
            already_processed.append('stationTwo')
            self.stationTwo = value
        value = find_attr_value_('stationOne', node)
        if value is not None and 'stationOne' not in already_processed:
            already_processed.append('stationOne')
            self.stationOne = value
        value = find_attr_value_('bbB', node)
        if value is not None and 'bbB' not in already_processed:
            already_processed.append('bbB')
            self.bbB = value
        value = find_attr_value_('bbA', node)
        if value is not None and 'bbA' not in already_processed:
            already_processed.append('bbA')
            self.bbA = value
        value = find_attr_value_('subband', node)
        if value is not None and 'subband' not in already_processed:
            already_processed.append('subband')
            self.subband = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class baseline


class stationPacking(GeneratedsSuper):
    """Station packing algorithm. User may specify one of the two options:
    1) use the minimum number of the Correlator Chips (i.e. columns
    and rows on the Baseline Board) or 2) distribute station input
    across as many Baseline Board columns/rows as possible."""
    subclass = None
    superclass = None
    def __init__(self, algorithm=None):
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if stationPacking.subclass:
            return stationPacking.subclass(*args_, **kwargs_)
        else:
            return stationPacking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='stationPacking', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stationPacking')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='stationPacking'):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='stationPacking', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stationPacking'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stationPacking


class productPacking(GeneratedsSuper):
    """Product packing algorithm. This parameter is relevant only if there
    is more than one Correlator Chip available per baseline. User
    can specify one of the two supported options: 1) MaxPack, which
    means: minimise the number of Correlator Chips that produce lag
    chain for each product (i.e. avoid use of static recirulation
    memory) 2) MinPack, which means: distribute lag chain across
    available Correlator Chips."""
    subclass = None
    superclass = None
    def __init__(self, algorithm=None):
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if productPacking.subclass:
            return productPacking.subclass(*args_, **kwargs_)
        else:
            return productPacking(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='productPacking', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='productPacking')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='productPacking'):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='productPacking', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='productPacking'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class productPacking


class autoCorrSubset(GeneratedsSuper):
    """The correlator can not obtain all auto-correlation products all the
    time, this is used to specify desired subset of auto-correlation
    products."""
    subclass = None
    superclass = None
    def __init__(self, dwellTime='10', startFrom='lowestStId', algorithm=None):
        self.dwellTime = _cast(None, dwellTime)
        self.startFrom = _cast(None, startFrom)
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if autoCorrSubset.subclass:
            return autoCorrSubset.subclass(*args_, **kwargs_)
        else:
            return autoCorrSubset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dwellTime(self): return self.dwellTime
    def set_dwellTime(self, dwellTime): self.dwellTime = dwellTime
    def get_startFrom(self): return self.startFrom
    def set_startFrom(self, startFrom): self.startFrom = startFrom
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='autoCorrSubset', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autoCorrSubset')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='autoCorrSubset'):
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            outfile.write(' dwellTime=%s' % (quote_attrib(self.dwellTime), ))
        if self.startFrom is not None and 'startFrom' not in already_processed:
            already_processed.append('startFrom')
            outfile.write(' startFrom=%s' % (quote_attrib(self.startFrom), ))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='autoCorrSubset', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='autoCorrSubset'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            showIndent(outfile, level)
            outfile.write('dwellTime = %s,\n' % (self.dwellTime,))
        if self.startFrom is not None and 'startFrom' not in already_processed:
            already_processed.append('startFrom')
            showIndent(outfile, level)
            outfile.write('startFrom = %s,\n' % (self.startFrom,))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dwellTime', node)
        if value is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            self.dwellTime = value
        value = find_attr_value_('startFrom', node)
        if value is not None and 'startFrom' not in already_processed:
            already_processed.append('startFrom')
            self.startFrom = value
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class autoCorrSubset


class cbeProcessing(GeneratedsSuper):
    """Specifies processing to be done by CBE on data products from the
    Baseline Boards. This is optional and, if not used, the CBE will
    default to 'integrateFirst' with no other processing
    done.Optional; if not specified, CBE and MCAF will determine the
    number.Specifies the minimal process to be performed by CBE.
    Optional; if omitted defaults to 'integrateFirst'.The three
    choices are: -- integrateFirst: 1. Flag, 2. Integrate, 3.
    DvNormalize, 4. FourierTransform, 5. WriteToBdf. --
    transformFirst: 1. Flag, 2. DvNormalize, 3. FourierTransform, 4.
    Integrate, 5. AccNormalize, 6. WriteToBdf. -- noTransform 1.
    Flag, 2. Integrate, 3. DvNormalize, 4. WriteToBdf. The doubling
    of data size will have to be accounted for in the BDF and,
    perhaps, the SDM."""
    subclass = None
    superclass = None
    def __init__(self, nSpectralWindowChannels=None, integrationStyle=None, averageFrequency=None, window=None):
        self.nSpectralWindowChannels = _cast(int, nSpectralWindowChannels)
        self.integrationStyle = _cast(None, integrationStyle)
        self.averageFrequency = averageFrequency
        self.window = window
    def factory(*args_, **kwargs_):
        if cbeProcessing.subclass:
            return cbeProcessing.subclass(*args_, **kwargs_)
        else:
            return cbeProcessing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averageFrequency(self): return self.averageFrequency
    def set_averageFrequency(self, averageFrequency): self.averageFrequency = averageFrequency
    def get_window(self): return self.window
    def set_window(self, window): self.window = window
    def get_nSpectralWindowChannels(self): return self.nSpectralWindowChannels
    def set_nSpectralWindowChannels(self, nSpectralWindowChannels): self.nSpectralWindowChannels = nSpectralWindowChannels
    def get_integrationStyle(self): return self.integrationStyle
    def set_integrationStyle(self, integrationStyle): self.integrationStyle = integrationStyle
    def export(self, outfile, level, namespace_='widar:', name_='cbeProcessing', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cbeProcessing')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cbeProcessing'):
        if self.nSpectralWindowChannels is not None and 'nSpectralWindowChannels' not in already_processed:
            already_processed.append('nSpectralWindowChannels')
            outfile.write(' nSpectralWindowChannels="%s"' % self.gds_format_integer(self.nSpectralWindowChannels, input_name='nSpectralWindowChannels'))
        if self.integrationStyle is not None and 'integrationStyle' not in already_processed:
            already_processed.append('integrationStyle')
            outfile.write(' integrationStyle=%s' % (self.gds_format_string(quote_attrib(self.integrationStyle).encode(ExternalEncoding), input_name='integrationStyle'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cbeProcessing', fromsubclass_=False):
        if self.averageFrequency:
            self.averageFrequency.export(outfile, level, namespace_, name_='averageFrequency')
        if self.window:
            self.window.export(outfile, level, namespace_, name_='window')
    def hasContent_(self):
        if (
            self.averageFrequency is not None or
            self.window is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cbeProcessing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nSpectralWindowChannels is not None and 'nSpectralWindowChannels' not in already_processed:
            already_processed.append('nSpectralWindowChannels')
            showIndent(outfile, level)
            outfile.write('nSpectralWindowChannels = %d,\n' % (self.nSpectralWindowChannels,))
        if self.integrationStyle is not None and 'integrationStyle' not in already_processed:
            already_processed.append('integrationStyle')
            showIndent(outfile, level)
            outfile.write('integrationStyle = "%s",\n' % (self.integrationStyle,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.averageFrequency is not None:
            showIndent(outfile, level)
            outfile.write('averageFrequency=model_.averageFrequencyType(\n')
            self.averageFrequency.exportLiteral(outfile, level, name_='averageFrequency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.window is not None:
            showIndent(outfile, level)
            outfile.write('window=model_.windowType(\n')
            self.window.exportLiteral(outfile, level, name_='window')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nSpectralWindowChannels', node)
        if value is not None and 'nSpectralWindowChannels' not in already_processed:
            already_processed.append('nSpectralWindowChannels')
            try:
                self.nSpectralWindowChannels = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('integrationStyle', node)
        if value is not None and 'integrationStyle' not in already_processed:
            already_processed.append('integrationStyle')
            self.integrationStyle = value
            self.integrationStyle = ' '.join(self.integrationStyle.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'averageFrequency':
            obj_ = averageFrequencyType.factory()
            obj_.build(child_)
            self.set_averageFrequency(obj_)
        elif nodeName_ == 'window':
            obj_ = windowType.factory()
            obj_.build(child_)
            self.set_window(obj_)
# end class cbeProcessing


class antenna(GeneratedsSuper):
    """Basic antenna information as specified in the VCI messages. Antenna
    ID is needed only by the Correlator Backend. Detailed antenna
    information will be specified in the Antenna Table and made
    available to the Backend by some other means (e.g. as a file
    stored on a server)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, name=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if antenna.subclass:
            return antenna.subclass(*args_, **kwargs_)
        else:
            return antenna(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='antenna', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='antenna')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='antenna'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='antenna', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='antenna'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class antenna


class host(GeneratedsSuper):
    """Set of parameters that unequely define a WIDAR host computer. This
    element may be used in logs/Alarms and other messages, where it
    may be used to identify the machine where log or report was
    originated."""
    subclass = None
    superclass = None
    def __init__(self, instance=None, type_=None, destIP4address=None):
        self.instance = _cast(None, instance)
        self.type_ = _cast(None, type_)
        self.destIP4address = _cast(None, destIP4address)
        pass
    def factory(*args_, **kwargs_):
        if host.subclass:
            return host.subclass(*args_, **kwargs_)
        else:
            return host(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_destIP4address(self): return self.destIP4address
    def set_destIP4address(self, destIP4address): self.destIP4address = destIP4address
    def export(self, outfile, level, namespace_='widar:', name_='host', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='host')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='host'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            outfile.write(' destIP4address=%s' % (quote_attrib(self.destIP4address), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='host', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='host'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            showIndent(outfile, level)
            outfile.write('destIP4address = %s,\n' % (self.destIP4address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('destIP4address', node)
        if value is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            self.destIP4address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class host


class radarMode(GeneratedsSuper):
    """2012-02-29 Sonja.Vrcic@nrc.gc.ca: Radar Mode has not been
    implemented. This element has been added for completness and to
    record inital implementation ideas, but before implementing
    this, use cases and detailed requirements should be defined. Raw
    data saving, also known as, radar mode. Narrow band output of a
    single filter per Station Board Data Path (i.e. per filter bank)
    can be saved in the memory and sent to the specified location.
    Number of bits to be saved is equal to the number of bits in the
    filter output, with exception of 7-bit output which is saved as
    8 bits of data. Duration can be specified in the number of 10
    millisecond interrupts. Duration=0 means perform data saving
    until "off" command is received or until the configuration is
    overwritten by another configuration."""
    subclass = None
    superclass = None
    def __init__(self, status=None, duration=0, destination=None):
        self.status = _cast(None, status)
        self.duration = _cast(int, duration)
        self.destination = _cast(None, destination)
        pass
    def factory(*args_, **kwargs_):
        if radarMode.subclass:
            return radarMode.subclass(*args_, **kwargs_)
        else:
            return radarMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def export(self, outfile, level, namespace_='widar:', name_='radarMode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='radarMode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='radarMode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration="%s"' % self.gds_format_integer(self.duration, input_name='duration'))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='radarMode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='radarMode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = %d,\n' % (self.duration,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            try:
                self.duration = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class radarMode


class cmMonitorControl(GeneratedsSuper):
    """Global parameters of VCI Configuration Mapper. 2012 October Replaced
    attribute: *xs:attribute name="flushCmibQueues"
    type="widar:YesNoType" use="optional" * with element
    cmFlushCmibQueues"""
    subclass = None
    superclass = None
    def __init__(self, crmQuery=None, sendQueryToCRM=None, sendConfigToBLBs=None, enableAllComponents=None, sendConfigToCBE=None, vciSchemaValidation=None, sendConfigToXBBs=None, query=None, sendConfigToSTBs=None, queryCfgStatus=None, cfgQueue=None, actQueue=None, ctrlQueue=None, cbeOutputQueue=None, cmLogging=None, vciReporting=None, cmAlerts=None, cmDeleteSubarray=None, cmFlushCmibQueues=None, ifdDefault=None):
        self.crmQuery = _cast(None, crmQuery)
        self.sendQueryToCRM = _cast(None, sendQueryToCRM)
        self.sendConfigToBLBs = _cast(None, sendConfigToBLBs)
        self.enableAllComponents = _cast(None, enableAllComponents)
        self.sendConfigToCBE = _cast(None, sendConfigToCBE)
        self.vciSchemaValidation = _cast(None, vciSchemaValidation)
        self.sendConfigToXBBs = _cast(None, sendConfigToXBBs)
        self.query = _cast(None, query)
        self.sendConfigToSTBs = _cast(None, sendConfigToSTBs)
        self.queryCfgStatus = queryCfgStatus
        self.cfgQueue = cfgQueue
        self.actQueue = actQueue
        self.ctrlQueue = ctrlQueue
        self.cbeOutputQueue = cbeOutputQueue
        self.cmLogging = cmLogging
        self.vciReporting = vciReporting
        self.cmAlerts = cmAlerts
        self.cmDeleteSubarray = cmDeleteSubarray
        self.cmFlushCmibQueues = cmFlushCmibQueues
        self.ifdDefault = ifdDefault
    def factory(*args_, **kwargs_):
        if cmMonitorControl.subclass:
            return cmMonitorControl.subclass(*args_, **kwargs_)
        else:
            return cmMonitorControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_queryCfgStatus(self): return self.queryCfgStatus
    def set_queryCfgStatus(self, queryCfgStatus): self.queryCfgStatus = queryCfgStatus
    def get_cfgQueue(self): return self.cfgQueue
    def set_cfgQueue(self, cfgQueue): self.cfgQueue = cfgQueue
    def get_actQueue(self): return self.actQueue
    def set_actQueue(self, actQueue): self.actQueue = actQueue
    def get_ctrlQueue(self): return self.ctrlQueue
    def set_ctrlQueue(self, ctrlQueue): self.ctrlQueue = ctrlQueue
    def get_cbeOutputQueue(self): return self.cbeOutputQueue
    def set_cbeOutputQueue(self, cbeOutputQueue): self.cbeOutputQueue = cbeOutputQueue
    def get_cmLogging(self): return self.cmLogging
    def set_cmLogging(self, cmLogging): self.cmLogging = cmLogging
    def get_vciReporting(self): return self.vciReporting
    def set_vciReporting(self, vciReporting): self.vciReporting = vciReporting
    def get_cmAlerts(self): return self.cmAlerts
    def set_cmAlerts(self, cmAlerts): self.cmAlerts = cmAlerts
    def get_cmDeleteSubarray(self): return self.cmDeleteSubarray
    def set_cmDeleteSubarray(self, cmDeleteSubarray): self.cmDeleteSubarray = cmDeleteSubarray
    def get_cmFlushCmibQueues(self): return self.cmFlushCmibQueues
    def set_cmFlushCmibQueues(self, cmFlushCmibQueues): self.cmFlushCmibQueues = cmFlushCmibQueues
    def get_ifdDefault(self): return self.ifdDefault
    def set_ifdDefault(self, ifdDefault): self.ifdDefault = ifdDefault
    def get_crmQuery(self): return self.crmQuery
    def set_crmQuery(self, crmQuery): self.crmQuery = crmQuery
    def get_sendQueryToCRM(self): return self.sendQueryToCRM
    def set_sendQueryToCRM(self, sendQueryToCRM): self.sendQueryToCRM = sendQueryToCRM
    def get_sendConfigToBLBs(self): return self.sendConfigToBLBs
    def set_sendConfigToBLBs(self, sendConfigToBLBs): self.sendConfigToBLBs = sendConfigToBLBs
    def get_enableAllComponents(self): return self.enableAllComponents
    def set_enableAllComponents(self, enableAllComponents): self.enableAllComponents = enableAllComponents
    def get_sendConfigToCBE(self): return self.sendConfigToCBE
    def set_sendConfigToCBE(self, sendConfigToCBE): self.sendConfigToCBE = sendConfigToCBE
    def get_vciSchemaValidation(self): return self.vciSchemaValidation
    def set_vciSchemaValidation(self, vciSchemaValidation): self.vciSchemaValidation = vciSchemaValidation
    def get_sendConfigToXBBs(self): return self.sendConfigToXBBs
    def set_sendConfigToXBBs(self, sendConfigToXBBs): self.sendConfigToXBBs = sendConfigToXBBs
    def get_query(self): return self.query
    def set_query(self, query): self.query = query
    def get_sendConfigToSTBs(self): return self.sendConfigToSTBs
    def set_sendConfigToSTBs(self, sendConfigToSTBs): self.sendConfigToSTBs = sendConfigToSTBs
    def export(self, outfile, level, namespace_='widar:', name_='cmMonitorControl', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmMonitorControl')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmMonitorControl'):
        if self.crmQuery is not None and 'crmQuery' not in already_processed:
            already_processed.append('crmQuery')
            outfile.write(' crmQuery=%s' % (quote_attrib(self.crmQuery), ))
        if self.sendQueryToCRM is not None and 'sendQueryToCRM' not in already_processed:
            already_processed.append('sendQueryToCRM')
            outfile.write(' sendQueryToCRM=%s' % (quote_attrib(self.sendQueryToCRM), ))
        if self.sendConfigToBLBs is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            outfile.write(' sendConfigToBLBs=%s' % (quote_attrib(self.sendConfigToBLBs), ))
        if self.enableAllComponents is not None and 'enableAllComponents' not in already_processed:
            already_processed.append('enableAllComponents')
            outfile.write(' enableAllComponents=%s' % (self.gds_format_string(quote_attrib(self.enableAllComponents).encode(ExternalEncoding), input_name='enableAllComponents'), ))
        if self.sendConfigToCBE is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            outfile.write(' sendConfigToCBE=%s' % (quote_attrib(self.sendConfigToCBE), ))
        if self.vciSchemaValidation is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            outfile.write(' vciSchemaValidation=%s' % (quote_attrib(self.vciSchemaValidation), ))
        if self.sendConfigToXBBs is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            outfile.write(' sendConfigToXBBs=%s' % (quote_attrib(self.sendConfigToXBBs), ))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            outfile.write(' query=%s' % (quote_attrib(self.query), ))
        if self.sendConfigToSTBs is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            outfile.write(' sendConfigToSTBs=%s' % (quote_attrib(self.sendConfigToSTBs), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmMonitorControl', fromsubclass_=False):
        if self.queryCfgStatus:
            self.queryCfgStatus.export(outfile, level, namespace_, name_='queryCfgStatus')
        if self.cfgQueue:
            self.cfgQueue.export(outfile, level, namespace_, name_='cfgQueue')
        if self.actQueue:
            self.actQueue.export(outfile, level, namespace_, name_='actQueue')
        if self.ctrlQueue:
            self.ctrlQueue.export(outfile, level, namespace_, name_='ctrlQueue')
        if self.cbeOutputQueue:
            self.cbeOutputQueue.export(outfile, level, namespace_, name_='cbeOutputQueue')
        if self.cmLogging:
            self.cmLogging.export(outfile, level, namespace_, name_='cmLogging')
        if self.vciReporting:
            self.vciReporting.export(outfile, level, namespace_, name_='vciReporting')
        if self.cmAlerts:
            self.cmAlerts.export(outfile, level, namespace_, name_='cmAlerts')
        if self.cmDeleteSubarray:
            self.cmDeleteSubarray.export(outfile, level, namespace_, name_='cmDeleteSubarray')
        if self.cmFlushCmibQueues:
            self.cmFlushCmibQueues.export(outfile, level, namespace_, name_='cmFlushCmibQueues')
        if self.ifdDefault:
            self.ifdDefault.export(outfile, level, namespace_, name_='ifdDefault')
    def hasContent_(self):
        if (
            self.queryCfgStatus is not None or
            self.cfgQueue is not None or
            self.actQueue is not None or
            self.ctrlQueue is not None or
            self.cbeOutputQueue is not None or
            self.cmLogging is not None or
            self.vciReporting is not None or
            self.cmAlerts is not None or
            self.cmDeleteSubarray is not None or
            self.cmFlushCmibQueues is not None or
            self.ifdDefault is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmMonitorControl'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.crmQuery is not None and 'crmQuery' not in already_processed:
            already_processed.append('crmQuery')
            showIndent(outfile, level)
            outfile.write('crmQuery = %s,\n' % (self.crmQuery,))
        if self.sendQueryToCRM is not None and 'sendQueryToCRM' not in already_processed:
            already_processed.append('sendQueryToCRM')
            showIndent(outfile, level)
            outfile.write('sendQueryToCRM = %s,\n' % (self.sendQueryToCRM,))
        if self.sendConfigToBLBs is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToBLBs = %s,\n' % (self.sendConfigToBLBs,))
        if self.enableAllComponents is not None and 'enableAllComponents' not in already_processed:
            already_processed.append('enableAllComponents')
            showIndent(outfile, level)
            outfile.write('enableAllComponents = "%s",\n' % (self.enableAllComponents,))
        if self.sendConfigToCBE is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            showIndent(outfile, level)
            outfile.write('sendConfigToCBE = %s,\n' % (self.sendConfigToCBE,))
        if self.vciSchemaValidation is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            showIndent(outfile, level)
            outfile.write('vciSchemaValidation = %s,\n' % (self.vciSchemaValidation,))
        if self.sendConfigToXBBs is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToXBBs = %s,\n' % (self.sendConfigToXBBs,))
        if self.query is not None and 'query' not in already_processed:
            already_processed.append('query')
            showIndent(outfile, level)
            outfile.write('query = %s,\n' % (self.query,))
        if self.sendConfigToSTBs is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            showIndent(outfile, level)
            outfile.write('sendConfigToSTBs = %s,\n' % (self.sendConfigToSTBs,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.queryCfgStatus is not None:
            showIndent(outfile, level)
            outfile.write('queryCfgStatus=model_.queryCfgStatus(\n')
            self.queryCfgStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cfgQueue is not None:
            showIndent(outfile, level)
            outfile.write('cfgQueue=model_.cfgQueue(\n')
            self.cfgQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.actQueue is not None:
            showIndent(outfile, level)
            outfile.write('actQueue=model_.actQueue(\n')
            self.actQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ctrlQueue is not None:
            showIndent(outfile, level)
            outfile.write('ctrlQueue=model_.ctrlQueue(\n')
            self.ctrlQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cbeOutputQueue is not None:
            showIndent(outfile, level)
            outfile.write('cbeOutputQueue=model_.cbeOutputQueue(\n')
            self.cbeOutputQueue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmLogging is not None:
            showIndent(outfile, level)
            outfile.write('cmLogging=model_.cmLogging(\n')
            self.cmLogging.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vciReporting is not None:
            showIndent(outfile, level)
            outfile.write('vciReporting=model_.vciReporting(\n')
            self.vciReporting.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmAlerts is not None:
            showIndent(outfile, level)
            outfile.write('cmAlerts=model_.cmAlerts(\n')
            self.cmAlerts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmDeleteSubarray is not None:
            showIndent(outfile, level)
            outfile.write('cmDeleteSubarray=model_.cmDeleteSubarray(\n')
            self.cmDeleteSubarray.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cmFlushCmibQueues is not None:
            showIndent(outfile, level)
            outfile.write('cmFlushCmibQueues=model_.cmFlushCmibQueues(\n')
            self.cmFlushCmibQueues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ifdDefault is not None:
            showIndent(outfile, level)
            outfile.write('ifdDefault=model_.ifdDefault(\n')
            self.ifdDefault.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('crmQuery', node)
        if value is not None and 'crmQuery' not in already_processed:
            already_processed.append('crmQuery')
            self.crmQuery = value
        value = find_attr_value_('sendQueryToCRM', node)
        if value is not None and 'sendQueryToCRM' not in already_processed:
            already_processed.append('sendQueryToCRM')
            self.sendQueryToCRM = value
        value = find_attr_value_('sendConfigToBLBs', node)
        if value is not None and 'sendConfigToBLBs' not in already_processed:
            already_processed.append('sendConfigToBLBs')
            self.sendConfigToBLBs = value
        value = find_attr_value_('enableAllComponents', node)
        if value is not None and 'enableAllComponents' not in already_processed:
            already_processed.append('enableAllComponents')
            self.enableAllComponents = value
        value = find_attr_value_('sendConfigToCBE', node)
        if value is not None and 'sendConfigToCBE' not in already_processed:
            already_processed.append('sendConfigToCBE')
            self.sendConfigToCBE = value
        value = find_attr_value_('vciSchemaValidation', node)
        if value is not None and 'vciSchemaValidation' not in already_processed:
            already_processed.append('vciSchemaValidation')
            self.vciSchemaValidation = value
        value = find_attr_value_('sendConfigToXBBs', node)
        if value is not None and 'sendConfigToXBBs' not in already_processed:
            already_processed.append('sendConfigToXBBs')
            self.sendConfigToXBBs = value
        value = find_attr_value_('query', node)
        if value is not None and 'query' not in already_processed:
            already_processed.append('query')
            self.query = value
        value = find_attr_value_('sendConfigToSTBs', node)
        if value is not None and 'sendConfigToSTBs' not in already_processed:
            already_processed.append('sendConfigToSTBs')
            self.sendConfigToSTBs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'queryCfgStatus':
            obj_ = queryCfgStatus.factory()
            obj_.build(child_)
            self.set_queryCfgStatus(obj_)
        elif nodeName_ == 'cfgQueue':
            obj_ = cfgQueue.factory()
            obj_.build(child_)
            self.set_cfgQueue(obj_)
        elif nodeName_ == 'actQueue':
            obj_ = actQueue.factory()
            obj_.build(child_)
            self.set_actQueue(obj_)
        elif nodeName_ == 'ctrlQueue':
            obj_ = ctrlQueue.factory()
            obj_.build(child_)
            self.set_ctrlQueue(obj_)
        elif nodeName_ == 'cbeOutputQueue':
            obj_ = cbeOutputQueue.factory()
            obj_.build(child_)
            self.set_cbeOutputQueue(obj_)
        elif nodeName_ == 'cmLogging':
            obj_ = cmLogging.factory()
            obj_.build(child_)
            self.set_cmLogging(obj_)
        elif nodeName_ == 'vciReporting':
            obj_ = vciReporting.factory()
            obj_.build(child_)
            self.set_vciReporting(obj_)
        elif nodeName_ == 'cmAlerts':
            obj_ = cmAlerts.factory()
            obj_.build(child_)
            self.set_cmAlerts(obj_)
        elif nodeName_ == 'cmDeleteSubarray':
            obj_ = cmDeleteSubarray.factory()
            obj_.build(child_)
            self.set_cmDeleteSubarray(obj_)
        elif nodeName_ == 'cmFlushCmibQueues':
            obj_ = cmFlushCmibQueues.factory()
            obj_.build(child_)
            self.set_cmFlushCmibQueues(obj_)
        elif nodeName_ == 'ifdDefault':
            obj_ = ifdDefault.factory()
            obj_.build(child_)
            self.set_ifdDefault(obj_)
# end class cmMonitorControl


class vciReporting(GeneratedsSuper):
    """Specify destination address and port for VCI Responses/Reports.
    Enable/disable transmission of VCI Responses/Reports."""
    subclass = None
    superclass = None
    def __init__(self, transmit=None, destIpAddress=None, destPort=None):
        self.transmit = _cast(None, transmit)
        self.destIpAddress = _cast(None, destIpAddress)
        self.destPort = _cast(int, destPort)
        pass
    def factory(*args_, **kwargs_):
        if vciReporting.subclass:
            return vciReporting.subclass(*args_, **kwargs_)
        else:
            return vciReporting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transmit(self): return self.transmit
    def set_transmit(self, transmit): self.transmit = transmit
    def get_destIpAddress(self): return self.destIpAddress
    def set_destIpAddress(self, destIpAddress): self.destIpAddress = destIpAddress
    def get_destPort(self): return self.destPort
    def set_destPort(self, destPort): self.destPort = destPort
    def export(self, outfile, level, namespace_='widar:', name_='vciReporting', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vciReporting')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='vciReporting'):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            outfile.write(' transmit=%s' % (quote_attrib(self.transmit), ))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            outfile.write(' destIpAddress=%s' % (self.gds_format_string(quote_attrib(self.destIpAddress).encode(ExternalEncoding), input_name='destIpAddress'), ))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            outfile.write(' destPort="%s"' % self.gds_format_integer(self.destPort, input_name='destPort'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='vciReporting', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vciReporting'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            showIndent(outfile, level)
            outfile.write('transmit = %s,\n' % (self.transmit,))
        if self.destIpAddress is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            showIndent(outfile, level)
            outfile.write('destIpAddress = "%s",\n' % (self.destIpAddress,))
        if self.destPort is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            showIndent(outfile, level)
            outfile.write('destPort = %d,\n' % (self.destPort,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transmit', node)
        if value is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            self.transmit = value
        value = find_attr_value_('destIpAddress', node)
        if value is not None and 'destIpAddress' not in already_processed:
            already_processed.append('destIpAddress')
            self.destIpAddress = value
        value = find_attr_value_('destPort', node)
        if value is not None and 'destPort' not in already_processed:
            already_processed.append('destPort')
            try:
                self.destPort = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vciReporting


class cmAlerts(GeneratedsSuper):
    """Enable/disable transmission of xAlerts."""
    subclass = None
    superclass = None
    def __init__(self, transmit=None):
        self.transmit = _cast(None, transmit)
        pass
    def factory(*args_, **kwargs_):
        if cmAlerts.subclass:
            return cmAlerts.subclass(*args_, **kwargs_)
        else:
            return cmAlerts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transmit(self): return self.transmit
    def set_transmit(self, transmit): self.transmit = transmit
    def export(self, outfile, level, namespace_='widar:', name_='cmAlerts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmAlerts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmAlerts'):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            outfile.write(' transmit=%s' % (quote_attrib(self.transmit), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmAlerts', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmAlerts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transmit is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            showIndent(outfile, level)
            outfile.write('transmit = %s,\n' % (self.transmit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transmit', node)
        if value is not None and 'transmit' not in already_processed:
            already_processed.append('transmit')
            self.transmit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmAlerts


class queryCfgStatus(GeneratedsSuper):
    """Request for configuration status report. One can specify: cfg=active
    or cfg=next or activation time or CorrModel ID. If more than one
    identification is specified, CM uses the first valid identifier,
    in following order: 1. cfg 2. actTime 3. CorrModel ID"""
    subclass = None
    superclass = None
    def __init__(self, actTime=None, cfg=None, corrModelId=None):
        self.actTime = _cast(None, actTime)
        self.cfg = _cast(None, cfg)
        self.corrModelId = _cast(float, corrModelId)
        pass
    def factory(*args_, **kwargs_):
        if queryCfgStatus.subclass:
            return queryCfgStatus.subclass(*args_, **kwargs_)
        else:
            return queryCfgStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actTime(self): return self.actTime
    def set_actTime(self, actTime): self.actTime = actTime
    def get_cfg(self): return self.cfg
    def set_cfg(self, cfg): self.cfg = cfg
    def get_corrModelId(self): return self.corrModelId
    def set_corrModelId(self, corrModelId): self.corrModelId = corrModelId
    def export(self, outfile, level, namespace_='widar:', name_='queryCfgStatus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='queryCfgStatus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='queryCfgStatus'):
        if self.actTime is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            outfile.write(' actTime=%s' % (self.gds_format_string(quote_attrib(self.actTime).encode(ExternalEncoding), input_name='actTime'), ))
        if self.cfg is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            outfile.write(' cfg=%s' % (quote_attrib(self.cfg), ))
        if self.corrModelId is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            outfile.write(' corrModelId="%s"' % self.gds_format_double(self.corrModelId, input_name='corrModelId'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='queryCfgStatus', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='queryCfgStatus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.actTime is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            showIndent(outfile, level)
            outfile.write('actTime = "%s",\n' % (self.actTime,))
        if self.cfg is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            showIndent(outfile, level)
            outfile.write('cfg = %s,\n' % (self.cfg,))
        if self.corrModelId is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            showIndent(outfile, level)
            outfile.write('corrModelId = %e,\n' % (self.corrModelId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('actTime', node)
        if value is not None and 'actTime' not in already_processed:
            already_processed.append('actTime')
            self.actTime = value
        value = find_attr_value_('cfg', node)
        if value is not None and 'cfg' not in already_processed:
            already_processed.append('cfg')
            self.cfg = value
        value = find_attr_value_('corrModelId', node)
        if value is not None and 'corrModelId' not in already_processed:
            already_processed.append('corrModelId')
            try:
                self.corrModelId = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (corrModelId): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class queryCfgStatus


class cfgQueue(GeneratedsSuper):
    """Monitor and control for the configuration queue."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cfgQueue.subclass:
            return cfgQueue.subclass(*args_, **kwargs_)
        else:
            return cfgQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cfgQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cfgQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cfgQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cfgQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cfgQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cfgQueue


class actQueue(GeneratedsSuper):
    """Monitor and control for the activation queue."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if actQueue.subclass:
            return actQueue.subclass(*args_, **kwargs_)
        else:
            return actQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='actQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='actQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='actQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='actQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class actQueue


class ctrlQueue(GeneratedsSuper):
    """Monitor and control for the queue that contains Control messages."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ctrlQueue.subclass:
            return ctrlQueue.subclass(*args_, **kwargs_)
        else:
            return ctrlQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='ctrlQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ctrlQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='ctrlQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='ctrlQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ctrlQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ctrlQueue


class cbeOutputQueue(GeneratedsSuper):
    """Monitor and control for the queue that contains messages for CBE."""
    subclass = None
    superclass = None
    def __init__(self, action=None, valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cbeOutputQueue.subclass:
            return cbeOutputQueue.subclass(*args_, **kwargs_)
        else:
            return cbeOutputQueue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cbeOutputQueue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cbeOutputQueue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cbeOutputQueue'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cbeOutputQueue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cbeOutputQueue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cbeOutputQueue


class ifdDefault(GeneratedsSuper):
    """Default values for inter-frame delay."""
    subclass = None
    superclass = None
    def __init__(self, delay=None, mode=None, randomOn=None):
        self.delay = _cast(None, delay)
        self.mode = _cast(None, mode)
        self.randomOn = _cast(None, randomOn)
        pass
    def factory(*args_, **kwargs_):
        if ifdDefault.subclass:
            return ifdDefault.subclass(*args_, **kwargs_)
        else:
            return ifdDefault(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_randomOn(self): return self.randomOn
    def set_randomOn(self, randomOn): self.randomOn = randomOn
    def export(self, outfile, level, namespace_='widar:', name_='ifdDefault', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ifdDefault')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='ifdDefault'):
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            outfile.write(' delay=%s' % (quote_attrib(self.delay), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
        if self.randomOn is not None and 'randomOn' not in already_processed:
            already_processed.append('randomOn')
            outfile.write(' randomOn=%s' % (quote_attrib(self.randomOn), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='ifdDefault', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ifdDefault'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            showIndent(outfile, level)
            outfile.write('delay = %s,\n' % (self.delay,))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            showIndent(outfile, level)
            outfile.write('mode = %s,\n' % (self.mode,))
        if self.randomOn is not None and 'randomOn' not in already_processed:
            already_processed.append('randomOn')
            showIndent(outfile, level)
            outfile.write('randomOn = %s,\n' % (self.randomOn,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            self.delay = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            self.mode = value
        value = find_attr_value_('randomOn', node)
        if value is not None and 'randomOn' not in already_processed:
            already_processed.append('randomOn')
            self.randomOn = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ifdDefault


class cmFlushCmibQueues(GeneratedsSuper):
    """Flush CMIB configuration(input) queue in specified racks."""
    subclass = None
    superclass = None
    def __init__(self, all='no', b108='no', b103='no', b102='no', b101='no', b107='no', b106='no', b105='no', b104='no', s005='no', s004='no', s007='no', s006='no', s001='no', s003='no', s002='no', s008='no'):
        self.all = _cast(None, all)
        self.b108 = _cast(None, b108)
        self.b103 = _cast(None, b103)
        self.b102 = _cast(None, b102)
        self.b101 = _cast(None, b101)
        self.b107 = _cast(None, b107)
        self.b106 = _cast(None, b106)
        self.b105 = _cast(None, b105)
        self.b104 = _cast(None, b104)
        self.s005 = _cast(None, s005)
        self.s004 = _cast(None, s004)
        self.s007 = _cast(None, s007)
        self.s006 = _cast(None, s006)
        self.s001 = _cast(None, s001)
        self.s003 = _cast(None, s003)
        self.s002 = _cast(None, s002)
        self.s008 = _cast(None, s008)
        pass
    def factory(*args_, **kwargs_):
        if cmFlushCmibQueues.subclass:
            return cmFlushCmibQueues.subclass(*args_, **kwargs_)
        else:
            return cmFlushCmibQueues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def get_b108(self): return self.b108
    def set_b108(self, b108): self.b108 = b108
    def get_b103(self): return self.b103
    def set_b103(self, b103): self.b103 = b103
    def get_b102(self): return self.b102
    def set_b102(self, b102): self.b102 = b102
    def get_b101(self): return self.b101
    def set_b101(self, b101): self.b101 = b101
    def get_b107(self): return self.b107
    def set_b107(self, b107): self.b107 = b107
    def get_b106(self): return self.b106
    def set_b106(self, b106): self.b106 = b106
    def get_b105(self): return self.b105
    def set_b105(self, b105): self.b105 = b105
    def get_b104(self): return self.b104
    def set_b104(self, b104): self.b104 = b104
    def get_s005(self): return self.s005
    def set_s005(self, s005): self.s005 = s005
    def get_s004(self): return self.s004
    def set_s004(self, s004): self.s004 = s004
    def get_s007(self): return self.s007
    def set_s007(self, s007): self.s007 = s007
    def get_s006(self): return self.s006
    def set_s006(self, s006): self.s006 = s006
    def get_s001(self): return self.s001
    def set_s001(self, s001): self.s001 = s001
    def get_s003(self): return self.s003
    def set_s003(self, s003): self.s003 = s003
    def get_s002(self): return self.s002
    def set_s002(self, s002): self.s002 = s002
    def get_s008(self): return self.s008
    def set_s008(self, s008): self.s008 = s008
    def export(self, outfile, level, namespace_='widar:', name_='cmFlushCmibQueues', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmFlushCmibQueues')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmFlushCmibQueues'):
        if self.all is not None and 'all' not in already_processed:
            already_processed.append('all')
            outfile.write(' all=%s' % (quote_attrib(self.all), ))
        if self.b108 is not None and 'b108' not in already_processed:
            already_processed.append('b108')
            outfile.write(' b108=%s' % (quote_attrib(self.b108), ))
        if self.b103 is not None and 'b103' not in already_processed:
            already_processed.append('b103')
            outfile.write(' b103=%s' % (quote_attrib(self.b103), ))
        if self.b102 is not None and 'b102' not in already_processed:
            already_processed.append('b102')
            outfile.write(' b102=%s' % (quote_attrib(self.b102), ))
        if self.b101 is not None and 'b101' not in already_processed:
            already_processed.append('b101')
            outfile.write(' b101=%s' % (quote_attrib(self.b101), ))
        if self.b107 is not None and 'b107' not in already_processed:
            already_processed.append('b107')
            outfile.write(' b107=%s' % (quote_attrib(self.b107), ))
        if self.b106 is not None and 'b106' not in already_processed:
            already_processed.append('b106')
            outfile.write(' b106=%s' % (quote_attrib(self.b106), ))
        if self.b105 is not None and 'b105' not in already_processed:
            already_processed.append('b105')
            outfile.write(' b105=%s' % (quote_attrib(self.b105), ))
        if self.b104 is not None and 'b104' not in already_processed:
            already_processed.append('b104')
            outfile.write(' b104=%s' % (quote_attrib(self.b104), ))
        if self.s005 is not None and 's005' not in already_processed:
            already_processed.append('s005')
            outfile.write(' s005=%s' % (quote_attrib(self.s005), ))
        if self.s004 is not None and 's004' not in already_processed:
            already_processed.append('s004')
            outfile.write(' s004=%s' % (quote_attrib(self.s004), ))
        if self.s007 is not None and 's007' not in already_processed:
            already_processed.append('s007')
            outfile.write(' s007=%s' % (quote_attrib(self.s007), ))
        if self.s006 is not None and 's006' not in already_processed:
            already_processed.append('s006')
            outfile.write(' s006=%s' % (quote_attrib(self.s006), ))
        if self.s001 is not None and 's001' not in already_processed:
            already_processed.append('s001')
            outfile.write(' s001=%s' % (quote_attrib(self.s001), ))
        if self.s003 is not None and 's003' not in already_processed:
            already_processed.append('s003')
            outfile.write(' s003=%s' % (quote_attrib(self.s003), ))
        if self.s002 is not None and 's002' not in already_processed:
            already_processed.append('s002')
            outfile.write(' s002=%s' % (quote_attrib(self.s002), ))
        if self.s008 is not None and 's008' not in already_processed:
            already_processed.append('s008')
            outfile.write(' s008=%s' % (quote_attrib(self.s008), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmFlushCmibQueues', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmFlushCmibQueues'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.all is not None and 'all' not in already_processed:
            already_processed.append('all')
            showIndent(outfile, level)
            outfile.write('all = %s,\n' % (self.all,))
        if self.b108 is not None and 'b108' not in already_processed:
            already_processed.append('b108')
            showIndent(outfile, level)
            outfile.write('b108 = %s,\n' % (self.b108,))
        if self.b103 is not None and 'b103' not in already_processed:
            already_processed.append('b103')
            showIndent(outfile, level)
            outfile.write('b103 = %s,\n' % (self.b103,))
        if self.b102 is not None and 'b102' not in already_processed:
            already_processed.append('b102')
            showIndent(outfile, level)
            outfile.write('b102 = %s,\n' % (self.b102,))
        if self.b101 is not None and 'b101' not in already_processed:
            already_processed.append('b101')
            showIndent(outfile, level)
            outfile.write('b101 = %s,\n' % (self.b101,))
        if self.b107 is not None and 'b107' not in already_processed:
            already_processed.append('b107')
            showIndent(outfile, level)
            outfile.write('b107 = %s,\n' % (self.b107,))
        if self.b106 is not None and 'b106' not in already_processed:
            already_processed.append('b106')
            showIndent(outfile, level)
            outfile.write('b106 = %s,\n' % (self.b106,))
        if self.b105 is not None and 'b105' not in already_processed:
            already_processed.append('b105')
            showIndent(outfile, level)
            outfile.write('b105 = %s,\n' % (self.b105,))
        if self.b104 is not None and 'b104' not in already_processed:
            already_processed.append('b104')
            showIndent(outfile, level)
            outfile.write('b104 = %s,\n' % (self.b104,))
        if self.s005 is not None and 's005' not in already_processed:
            already_processed.append('s005')
            showIndent(outfile, level)
            outfile.write('s005 = %s,\n' % (self.s005,))
        if self.s004 is not None and 's004' not in already_processed:
            already_processed.append('s004')
            showIndent(outfile, level)
            outfile.write('s004 = %s,\n' % (self.s004,))
        if self.s007 is not None and 's007' not in already_processed:
            already_processed.append('s007')
            showIndent(outfile, level)
            outfile.write('s007 = %s,\n' % (self.s007,))
        if self.s006 is not None and 's006' not in already_processed:
            already_processed.append('s006')
            showIndent(outfile, level)
            outfile.write('s006 = %s,\n' % (self.s006,))
        if self.s001 is not None and 's001' not in already_processed:
            already_processed.append('s001')
            showIndent(outfile, level)
            outfile.write('s001 = %s,\n' % (self.s001,))
        if self.s003 is not None and 's003' not in already_processed:
            already_processed.append('s003')
            showIndent(outfile, level)
            outfile.write('s003 = %s,\n' % (self.s003,))
        if self.s002 is not None and 's002' not in already_processed:
            already_processed.append('s002')
            showIndent(outfile, level)
            outfile.write('s002 = %s,\n' % (self.s002,))
        if self.s008 is not None and 's008' not in already_processed:
            already_processed.append('s008')
            showIndent(outfile, level)
            outfile.write('s008 = %s,\n' % (self.s008,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.append('all')
            self.all = value
        value = find_attr_value_('b108', node)
        if value is not None and 'b108' not in already_processed:
            already_processed.append('b108')
            self.b108 = value
        value = find_attr_value_('b103', node)
        if value is not None and 'b103' not in already_processed:
            already_processed.append('b103')
            self.b103 = value
        value = find_attr_value_('b102', node)
        if value is not None and 'b102' not in already_processed:
            already_processed.append('b102')
            self.b102 = value
        value = find_attr_value_('b101', node)
        if value is not None and 'b101' not in already_processed:
            already_processed.append('b101')
            self.b101 = value
        value = find_attr_value_('b107', node)
        if value is not None and 'b107' not in already_processed:
            already_processed.append('b107')
            self.b107 = value
        value = find_attr_value_('b106', node)
        if value is not None and 'b106' not in already_processed:
            already_processed.append('b106')
            self.b106 = value
        value = find_attr_value_('b105', node)
        if value is not None and 'b105' not in already_processed:
            already_processed.append('b105')
            self.b105 = value
        value = find_attr_value_('b104', node)
        if value is not None and 'b104' not in already_processed:
            already_processed.append('b104')
            self.b104 = value
        value = find_attr_value_('s005', node)
        if value is not None and 's005' not in already_processed:
            already_processed.append('s005')
            self.s005 = value
        value = find_attr_value_('s004', node)
        if value is not None and 's004' not in already_processed:
            already_processed.append('s004')
            self.s004 = value
        value = find_attr_value_('s007', node)
        if value is not None and 's007' not in already_processed:
            already_processed.append('s007')
            self.s007 = value
        value = find_attr_value_('s006', node)
        if value is not None and 's006' not in already_processed:
            already_processed.append('s006')
            self.s006 = value
        value = find_attr_value_('s001', node)
        if value is not None and 's001' not in already_processed:
            already_processed.append('s001')
            self.s001 = value
        value = find_attr_value_('s003', node)
        if value is not None and 's003' not in already_processed:
            already_processed.append('s003')
            self.s003 = value
        value = find_attr_value_('s002', node)
        if value is not None and 's002' not in already_processed:
            already_processed.append('s002')
            self.s002 = value
        value = find_attr_value_('s008', node)
        if value is not None and 's008' not in already_processed:
            already_processed.append('s008')
            self.s008 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmFlushCmibQueues


class cmDeleteSubarray(GeneratedsSuper):
    """Delete subarray with the specified Config ID. If configId==all
    delete all subarrays. This command is used when usr does not
    want to (or cannot) specify activation time. When this command
    is received, CM searches both the active configuration and all
    the scheduled configurations (in the Activation Queue) and
    deletes all the instances of a subarray with the specified
    Config ID."""
    subclass = None
    superclass = None
    def __init__(self, configId=None, valueOf_=None):
        self.configId = _cast(None, configId)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cmDeleteSubarray.subclass:
            return cmDeleteSubarray.subclass(*args_, **kwargs_)
        else:
            return cmDeleteSubarray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configId(self): return self.configId
    def set_configId(self, configId): self.configId = configId
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='widar:', name_='cmDeleteSubarray', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmDeleteSubarray')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmDeleteSubarray'):
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            outfile.write(' configId=%s' % (self.gds_format_string(quote_attrib(self.configId).encode(ExternalEncoding), input_name='configId'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmDeleteSubarray', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmDeleteSubarray'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.configId is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            showIndent(outfile, level)
            outfile.write('configId = "%s",\n' % (self.configId,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('configId', node)
        if value is not None and 'configId' not in already_processed:
            already_processed.append('configId')
            self.configId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmDeleteSubarray


class cmLogging(GeneratedsSuper):
    
    subclass = None
    superclass = None
    def __init__(self, level=None, logCrmMessages=None, logToFile=None, logCbeMessages=None, logBlbMessages=None, logXAlerts=None, logVciMessages=None, logStbMessages=None, logXbbMessages=None):
        self.level = _cast(None, level)
        self.logCrmMessages = _cast(None, logCrmMessages)
        self.logToFile = _cast(None, logToFile)
        self.logCbeMessages = _cast(None, logCbeMessages)
        self.logBlbMessages = _cast(None, logBlbMessages)
        self.logXAlerts = _cast(None, logXAlerts)
        self.logVciMessages = _cast(None, logVciMessages)
        self.logStbMessages = _cast(None, logStbMessages)
        self.logXbbMessages = _cast(None, logXbbMessages)
        pass
    def factory(*args_, **kwargs_):
        if cmLogging.subclass:
            return cmLogging.subclass(*args_, **kwargs_)
        else:
            return cmLogging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_logCrmMessages(self): return self.logCrmMessages
    def set_logCrmMessages(self, logCrmMessages): self.logCrmMessages = logCrmMessages
    def get_logToFile(self): return self.logToFile
    def set_logToFile(self, logToFile): self.logToFile = logToFile
    def get_logCbeMessages(self): return self.logCbeMessages
    def set_logCbeMessages(self, logCbeMessages): self.logCbeMessages = logCbeMessages
    def get_logBlbMessages(self): return self.logBlbMessages
    def set_logBlbMessages(self, logBlbMessages): self.logBlbMessages = logBlbMessages
    def get_logXAlerts(self): return self.logXAlerts
    def set_logXAlerts(self, logXAlerts): self.logXAlerts = logXAlerts
    def get_logVciMessages(self): return self.logVciMessages
    def set_logVciMessages(self, logVciMessages): self.logVciMessages = logVciMessages
    def get_logStbMessages(self): return self.logStbMessages
    def set_logStbMessages(self, logStbMessages): self.logStbMessages = logStbMessages
    def get_logXbbMessages(self): return self.logXbbMessages
    def set_logXbbMessages(self, logXbbMessages): self.logXbbMessages = logXbbMessages
    def export(self, outfile, level, namespace_='widar:', name_='cmLogging', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cmLogging')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='cmLogging'):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.logCrmMessages is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            outfile.write(' logCrmMessages=%s' % (quote_attrib(self.logCrmMessages), ))
        if self.logToFile is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            outfile.write(' logToFile=%s' % (quote_attrib(self.logToFile), ))
        if self.logCbeMessages is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            outfile.write(' logCbeMessages=%s' % (quote_attrib(self.logCbeMessages), ))
        if self.logBlbMessages is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            outfile.write(' logBlbMessages=%s' % (quote_attrib(self.logBlbMessages), ))
        if self.logXAlerts is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            outfile.write(' logXAlerts=%s' % (quote_attrib(self.logXAlerts), ))
        if self.logVciMessages is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            outfile.write(' logVciMessages=%s' % (quote_attrib(self.logVciMessages), ))
        if self.logStbMessages is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            outfile.write(' logStbMessages=%s' % (quote_attrib(self.logStbMessages), ))
        if self.logXbbMessages is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            outfile.write(' logXbbMessages=%s' % (quote_attrib(self.logXbbMessages), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='cmLogging', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cmLogging'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
        if self.logCrmMessages is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            showIndent(outfile, level)
            outfile.write('logCrmMessages = %s,\n' % (self.logCrmMessages,))
        if self.logToFile is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            showIndent(outfile, level)
            outfile.write('logToFile = %s,\n' % (self.logToFile,))
        if self.logCbeMessages is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            showIndent(outfile, level)
            outfile.write('logCbeMessages = %s,\n' % (self.logCbeMessages,))
        if self.logBlbMessages is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            showIndent(outfile, level)
            outfile.write('logBlbMessages = %s,\n' % (self.logBlbMessages,))
        if self.logXAlerts is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            showIndent(outfile, level)
            outfile.write('logXAlerts = %s,\n' % (self.logXAlerts,))
        if self.logVciMessages is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            showIndent(outfile, level)
            outfile.write('logVciMessages = %s,\n' % (self.logVciMessages,))
        if self.logStbMessages is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            showIndent(outfile, level)
            outfile.write('logStbMessages = %s,\n' % (self.logStbMessages,))
        if self.logXbbMessages is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            showIndent(outfile, level)
            outfile.write('logXbbMessages = %s,\n' % (self.logXbbMessages,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
        value = find_attr_value_('logCrmMessages', node)
        if value is not None and 'logCrmMessages' not in already_processed:
            already_processed.append('logCrmMessages')
            self.logCrmMessages = value
        value = find_attr_value_('logToFile', node)
        if value is not None and 'logToFile' not in already_processed:
            already_processed.append('logToFile')
            self.logToFile = value
        value = find_attr_value_('logCbeMessages', node)
        if value is not None and 'logCbeMessages' not in already_processed:
            already_processed.append('logCbeMessages')
            self.logCbeMessages = value
        value = find_attr_value_('logBlbMessages', node)
        if value is not None and 'logBlbMessages' not in already_processed:
            already_processed.append('logBlbMessages')
            self.logBlbMessages = value
        value = find_attr_value_('logXAlerts', node)
        if value is not None and 'logXAlerts' not in already_processed:
            already_processed.append('logXAlerts')
            self.logXAlerts = value
        value = find_attr_value_('logVciMessages', node)
        if value is not None and 'logVciMessages' not in already_processed:
            already_processed.append('logVciMessages')
            self.logVciMessages = value
        value = find_attr_value_('logStbMessages', node)
        if value is not None and 'logStbMessages' not in already_processed:
            already_processed.append('logStbMessages')
            self.logStbMessages = value
        value = find_attr_value_('logXbbMessages', node)
        if value is not None and 'logXbbMessages' not in already_processed:
            already_processed.append('logXbbMessages')
            self.logXbbMessages = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cmLogging


class component(GeneratedsSuper):
    """This is an attempt to define an XML element that could be used to
    query or report status of any h/w or s/w component. Element
    component can be generated both by the VCI client and by the
    correlator. ID and type are enough to unquely identify any WIDAR
    component. Optionally, a name can be assigned, but VCI clinet
    can not use the name to identify component. Attributes xmlTag
    and status are specified only by the correlator. If an XML
    element is specified for the component, the message generated by
    the correlator"""
    subclass = None
    superclass = None
    def __init__(self, status=None, xmlTag=None, type_=None, id=None, name=None):
        self.status = _cast(None, status)
        self.xmlTag = _cast(None, xmlTag)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if component.subclass:
            return component.subclass(*args_, **kwargs_)
        else:
            return component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_xmlTag(self): return self.xmlTag
    def set_xmlTag(self, xmlTag): self.xmlTag = xmlTag
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='widar:', name_='component', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='component')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='component'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.xmlTag is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            outfile.write(' xmlTag=%s' % (self.gds_format_string(quote_attrib(self.xmlTag).encode(ExternalEncoding), input_name='xmlTag'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='component', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='component'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = "%s",\n' % (self.status,))
        if self.xmlTag is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            showIndent(outfile, level)
            outfile.write('xmlTag = "%s",\n' % (self.xmlTag,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('xmlTag', node)
        if value is not None and 'xmlTag' not in already_processed:
            already_processed.append('xmlTag')
            self.xmlTag = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class component


class originator(GeneratedsSuper):
    """Originator of the vciLog. Depending on the type of event, name of
    the class, method and/or thread may be provided."""
    subclass = None
    superclass = None
    def __init__(self, thread=None, classxx=None, componentID=None, componentType=None, logger=None, method=None):
        self.thread = _cast(None, thread)
        self.classxx = _cast(None, classxx)
        self.componentID = _cast(None, componentID)
        self.componentType = _cast(None, componentType)
        self.logger = _cast(None, logger)
        self.method = _cast(None, method)
        pass
    def factory(*args_, **kwargs_):
        if originator.subclass:
            return originator.subclass(*args_, **kwargs_)
        else:
            return originator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thread(self): return self.thread
    def set_thread(self, thread): self.thread = thread
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def get_componentID(self): return self.componentID
    def set_componentID(self, componentID): self.componentID = componentID
    def get_componentType(self): return self.componentType
    def set_componentType(self, componentType): self.componentType = componentType
    def get_logger(self): return self.logger
    def set_logger(self, logger): self.logger = logger
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def export(self, outfile, level, namespace_='widar:', name_='originator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='originator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='originator'):
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            outfile.write(' thread=%s' % (self.gds_format_string(quote_attrib(self.thread).encode(ExternalEncoding), input_name='thread'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            outfile.write(' componentID=%s' % (self.gds_format_string(quote_attrib(self.componentID).encode(ExternalEncoding), input_name='componentID'), ))
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            outfile.write(' componentType=%s' % (self.gds_format_string(quote_attrib(self.componentType).encode(ExternalEncoding), input_name='componentType'), ))
        if self.logger is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            outfile.write(' logger=%s' % (self.gds_format_string(quote_attrib(self.logger).encode(ExternalEncoding), input_name='logger'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='originator', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='originator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            showIndent(outfile, level)
            outfile.write('thread = "%s",\n' % (self.thread,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            showIndent(outfile, level)
            outfile.write('componentID = "%s",\n' % (self.componentID,))
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            showIndent(outfile, level)
            outfile.write('componentType = "%s",\n' % (self.componentType,))
        if self.logger is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            showIndent(outfile, level)
            outfile.write('logger = "%s",\n' % (self.logger,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = "%s",\n' % (self.method,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            self.thread = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
        value = find_attr_value_('componentID', node)
        if value is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            self.componentID = value
        value = find_attr_value_('componentType', node)
        if value is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            self.componentType = value
        value = find_attr_value_('logger', node)
        if value is not None and 'logger' not in already_processed:
            already_processed.append('logger')
            self.logger = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class originator


class affectedComponent(GeneratedsSuper):
    """The component which is the source of the event or which is affected
    by the event. For example, if a crash is being reported : the
    component that crashed."""
    subclass = None
    superclass = None
    def __init__(self, componentType=None, method=None, componentID=None, thread=None, classxx=None):
        self.componentType = _cast(None, componentType)
        self.method = _cast(None, method)
        self.componentID = _cast(None, componentID)
        self.thread = _cast(None, thread)
        self.classxx = _cast(None, classxx)
        pass
    def factory(*args_, **kwargs_):
        if affectedComponent.subclass:
            return affectedComponent.subclass(*args_, **kwargs_)
        else:
            return affectedComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentType(self): return self.componentType
    def set_componentType(self, componentType): self.componentType = componentType
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_componentID(self): return self.componentID
    def set_componentID(self, componentID): self.componentID = componentID
    def get_thread(self): return self.thread
    def set_thread(self, thread): self.thread = thread
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='widar:', name_='affectedComponent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='affectedComponent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='affectedComponent'):
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            outfile.write(' componentType=%s' % (self.gds_format_string(quote_attrib(self.componentType).encode(ExternalEncoding), input_name='componentType'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            outfile.write(' componentID=%s' % (self.gds_format_string(quote_attrib(self.componentID).encode(ExternalEncoding), input_name='componentID'), ))
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            outfile.write(' thread=%s' % (self.gds_format_string(quote_attrib(self.thread).encode(ExternalEncoding), input_name='thread'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='affectedComponent', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='affectedComponent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.componentType is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            showIndent(outfile, level)
            outfile.write('componentType = "%s",\n' % (self.componentType,))
        if self.method is not None and 'method' not in already_processed:
            already_processed.append('method')
            showIndent(outfile, level)
            outfile.write('method = "%s",\n' % (self.method,))
        if self.componentID is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            showIndent(outfile, level)
            outfile.write('componentID = "%s",\n' % (self.componentID,))
        if self.thread is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            showIndent(outfile, level)
            outfile.write('thread = "%s",\n' % (self.thread,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentType', node)
        if value is not None and 'componentType' not in already_processed:
            already_processed.append('componentType')
            self.componentType = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.append('method')
            self.method = value
        value = find_attr_value_('componentID', node)
        if value is not None and 'componentID' not in already_processed:
            already_processed.append('componentID')
            self.componentID = value
        value = find_attr_value_('thread', node)
        if value is not None and 'thread' not in already_processed:
            already_processed.append('thread')
            self.thread = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class affectedComponent


class trowable(GeneratedsSuper):
    """Used to log Java exceptions (object trowable)."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, message=None, stackTrace=None, trowable=None):
        self.type_ = type_
        self.message = message
        if stackTrace is None:
            self.stackTrace = []
        else:
            self.stackTrace = stackTrace
        if trowable is None:
            self.trowable = []
        else:
            self.trowable = trowable
    def factory(*args_, **kwargs_):
        if trowable.subclass:
            return trowable.subclass(*args_, **kwargs_)
        else:
            return trowable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_stackTrace(self): return self.stackTrace
    def set_stackTrace(self, stackTrace): self.stackTrace = stackTrace
    def add_stackTrace(self, value): self.stackTrace.append(value)
    def insert_stackTrace(self, index, value): self.stackTrace[index] = value
    def get_trowable(self): return self.trowable
    def set_trowable(self, trowable): self.trowable = trowable
    def add_trowable(self, value): self.trowable.append(value)
    def insert_trowable(self, index, value): self.trowable[index] = value
    def export(self, outfile, level, namespace_='widar:', name_='trowable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trowable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='trowable'):
        pass
    def exportChildren(self, outfile, level, namespace_='widar:', name_='trowable', fromsubclass_=False):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.gds_format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        for stackTrace_ in self.stackTrace:
            showIndent(outfile, level)
            outfile.write('<%sstackTrace>%s</%sstackTrace>\n' % (namespace_, self.gds_format_string(quote_xml(stackTrace_).encode(ExternalEncoding), input_name='stackTrace'), namespace_))
        for trowable_ in self.trowable:
            trowable_.export(outfile, level, namespace_, name_='trowable')
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.message is not None or
            self.stackTrace or
            self.trowable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='trowable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('stackTrace=[\n')
        level += 1
        for stackTrace_ in self.stackTrace:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(stackTrace_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('trowable=[\n')
        level += 1
        for trowable_ in self.trowable:
            showIndent(outfile, level)
            outfile.write('model_.trowable(\n')
            trowable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'stackTrace':
            stackTrace_ = child_.text
            stackTrace_ = self.gds_validate_string(stackTrace_, node, 'stackTrace')
            self.stackTrace.append(stackTrace_)
        elif nodeName_ == 'trowable':
            obj_ = trowable.factory()
            obj_.build(child_)
            self.trowable.append(obj_)
# end class trowable


class widarHost(GeneratedsSuper):
    """Set of parameters that unequely define a WIDAR host computer
    (physical device). Obviously, IP address can be used to uniqely
    define a computer system, while type and instance are more
    sutiable as information to be stored for future reference."""
    subclass = None
    superclass = None
    def __init__(self, instance=None, type_=None, destIP4address=None):
        self.instance = _cast(None, instance)
        self.type_ = _cast(None, type_)
        self.destIP4address = _cast(None, destIP4address)
        pass
    def factory(*args_, **kwargs_):
        if widarHost.subclass:
            return widarHost.subclass(*args_, **kwargs_)
        else:
            return widarHost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_destIP4address(self): return self.destIP4address
    def set_destIP4address(self, destIP4address): self.destIP4address = destIP4address
    def export(self, outfile, level, namespace_='widar:', name_='widarHost', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='widarHost')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='widarHost'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            outfile.write(' destIP4address=%s' % (quote_attrib(self.destIP4address), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='widarHost', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='widarHost'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.destIP4address is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            showIndent(outfile, level)
            outfile.write('destIP4address = %s,\n' % (self.destIP4address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('destIP4address', node)
        if value is not None and 'destIP4address' not in already_processed:
            already_processed.append('destIP4address')
            self.destIP4address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class widarHost


class MsgCommentType(GeneratedsSuper):
    """Decription used in log / alarm messages."""
    subclass = None
    superclass = None
    def __init__(self, code=None, level=None, description=None, property=None):
        self.code = _cast(None, code)
        self.level = _cast(None, level)
        if description is None:
            self.description = []
        else:
            self.description = description
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if MsgCommentType.subclass:
            return MsgCommentType.subclass(*args_, **kwargs_)
        else:
            return MsgCommentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property(self, index, value): self.property[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def export(self, outfile, level, namespace_='widar:', name_='MsgCommentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MsgCommentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='MsgCommentType'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='MsgCommentType', fromsubclass_=False):
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(description_).encode(ExternalEncoding), input_name='description'), namespace_))
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.description or
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MsgCommentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            showIndent(outfile, level)
            outfile.write('code = "%s",\n' % (self.code,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.property(\n')
            property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.append('code')
            self.code = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'property':
            obj_ = property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class MsgCommentType


class property(GeneratedsSuper):
    """Used to report status of the parameters which are not defined in the
    WIDAR XML Schema."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if property.subclass:
            return property.subclass(*args_, **kwargs_)
        else:
            return property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='widar:', name_='property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='property')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='property'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='property', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class property


class moduleLocation(GeneratedsSuper):
    """Module Location Id as specified in the System Numbering Plan.
    Defines the physical location of the module."""
    subclass = None
    superclass = None
    def __init__(self, slot=None, crate=None, rack=None):
        self.slot = _cast(None, slot)
        self.crate = _cast(None, crate)
        self.rack = _cast(None, rack)
        pass
    def factory(*args_, **kwargs_):
        if moduleLocation.subclass:
            return moduleLocation.subclass(*args_, **kwargs_)
        else:
            return moduleLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_slot(self): return self.slot
    def set_slot(self, slot): self.slot = slot
    def get_crate(self): return self.crate
    def set_crate(self, crate): self.crate = crate
    def get_rack(self): return self.rack
    def set_rack(self, rack): self.rack = rack
    def export(self, outfile, level, namespace_='widar:', name_='moduleLocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moduleLocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='moduleLocation'):
        if self.slot is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            outfile.write(' slot=%s' % (quote_attrib(self.slot), ))
        if self.crate is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            outfile.write(' crate=%s' % (quote_attrib(self.crate), ))
        if self.rack is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            outfile.write(' rack=%s' % (quote_attrib(self.rack), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='moduleLocation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='moduleLocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.slot is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            showIndent(outfile, level)
            outfile.write('slot = %s,\n' % (self.slot,))
        if self.crate is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            showIndent(outfile, level)
            outfile.write('crate = %s,\n' % (self.crate,))
        if self.rack is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            showIndent(outfile, level)
            outfile.write('rack = %s,\n' % (self.rack,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('slot', node)
        if value is not None and 'slot' not in already_processed:
            already_processed.append('slot')
            self.slot = value
        value = find_attr_value_('crate', node)
        if value is not None and 'crate' not in already_processed:
            already_processed.append('crate')
            self.crate = value
        value = find_attr_value_('rack', node)
        if value is not None and 'rack' not in already_processed:
            already_processed.append('rack')
            self.rack = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class moduleLocation


class toneExtraction(GeneratedsSuper):
    """2012-02-29 Sonja.Vrcic@nrc.gc.ca: Tone extraction not implemented."""
    subclass = None
    superclass = None
    def __init__(self, status=None, destination=None, numTones=None, integFactor='10', dwellTime=None):
        self.status = _cast(None, status)
        self.destination = _cast(None, destination)
        self.numTones = _cast(int, numTones)
        self.integFactor = _cast(None, integFactor)
        self.dwellTime = _cast(int, dwellTime)
        pass
    def factory(*args_, **kwargs_):
        if toneExtraction.subclass:
            return toneExtraction.subclass(*args_, **kwargs_)
        else:
            return toneExtraction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_numTones(self): return self.numTones
    def set_numTones(self, numTones): self.numTones = numTones
    def get_integFactor(self): return self.integFactor
    def set_integFactor(self, integFactor): self.integFactor = integFactor
    def get_dwellTime(self): return self.dwellTime
    def set_dwellTime(self, dwellTime): self.dwellTime = dwellTime
    def export(self, outfile, level, namespace_='widar:', name_='toneExtraction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='toneExtraction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='toneExtraction'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.numTones is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            outfile.write(' numTones="%s"' % self.gds_format_integer(self.numTones, input_name='numTones'))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            outfile.write(' integFactor=%s' % (quote_attrib(self.integFactor), ))
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            outfile.write(' dwellTime="%s"' % self.gds_format_integer(self.dwellTime, input_name='dwellTime'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='toneExtraction', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='toneExtraction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.numTones is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            showIndent(outfile, level)
            outfile.write('numTones = %d,\n' % (self.numTones,))
        if self.integFactor is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            showIndent(outfile, level)
            outfile.write('integFactor = %s,\n' % (self.integFactor,))
        if self.dwellTime is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            showIndent(outfile, level)
            outfile.write('dwellTime = %d,\n' % (self.dwellTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('numTones', node)
        if value is not None and 'numTones' not in already_processed:
            already_processed.append('numTones')
            try:
                self.numTones = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('integFactor', node)
        if value is not None and 'integFactor' not in already_processed:
            already_processed.append('integFactor')
            self.integFactor = value
        value = find_attr_value_('dwellTime', node)
        if value is not None and 'dwellTime' not in already_processed:
            already_processed.append('dwellTime')
            try:
                self.dwellTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class toneExtraction


class noiseDiode(GeneratedsSuper):
    """Noise Diode configuration."""
    subclass = None
    superclass = None
    def __init__(self, status='enable', phase=0.0, dutyCycle='50.0', periodMilliSec='9.6'):
        self.status = _cast(None, status)
        self.phase = _cast(float, phase)
        self.dutyCycle = _cast(None, dutyCycle)
        self.periodMilliSec = _cast(None, periodMilliSec)
        pass
    def factory(*args_, **kwargs_):
        if noiseDiode.subclass:
            return noiseDiode.subclass(*args_, **kwargs_)
        else:
            return noiseDiode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_dutyCycle(self): return self.dutyCycle
    def set_dutyCycle(self, dutyCycle): self.dutyCycle = dutyCycle
    def get_periodMilliSec(self): return self.periodMilliSec
    def set_periodMilliSec(self, periodMilliSec): self.periodMilliSec = periodMilliSec
    def export(self, outfile, level, namespace_='widar:', name_='noiseDiode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='noiseDiode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='noiseDiode'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            outfile.write(' phase="%s"' % self.gds_format_double(self.phase, input_name='phase'))
        if self.dutyCycle is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            outfile.write(' dutyCycle=%s' % (quote_attrib(self.dutyCycle), ))
        if self.periodMilliSec is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            outfile.write(' periodMilliSec=%s' % (quote_attrib(self.periodMilliSec), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='noiseDiode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='noiseDiode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            showIndent(outfile, level)
            outfile.write('phase = %e,\n' % (self.phase,))
        if self.dutyCycle is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            showIndent(outfile, level)
            outfile.write('dutyCycle = %s,\n' % (self.dutyCycle,))
        if self.periodMilliSec is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            showIndent(outfile, level)
            outfile.write('periodMilliSec = %s,\n' % (self.periodMilliSec,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.append('phase')
            try:
                self.phase = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (phase): %s' % exp)
        value = find_attr_value_('dutyCycle', node)
        if value is not None and 'dutyCycle' not in already_processed:
            already_processed.append('dutyCycle')
            self.dutyCycle = value
        value = find_attr_value_('periodMilliSec', node)
        if value is not None and 'periodMilliSec' not in already_processed:
            already_processed.append('periodMilliSec')
            self.periodMilliSec = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class noiseDiode


class gating(GeneratedsSuper):
    """Gating has not been implemented in CM. Schema for gating is likely
    to change. Gating period in milliseconds (or frequency in Hz).
    Gate width is specified as percent of the period (when the gate
    is on). Epoch is specified as UT (or should it be the same as
    activation time)."""
    subclass = None
    superclass = None
    def __init__(self, status='disable', period=None, firstDerivative=None, epoch=None, secondDerivative=None, gateWidth='0.5'):
        self.status = _cast(None, status)
        self.period = _cast(float, period)
        self.firstDerivative = _cast(int, firstDerivative)
        self.epoch = _cast(None, epoch)
        self.secondDerivative = _cast(int, secondDerivative)
        self.gateWidth = _cast(None, gateWidth)
        pass
    def factory(*args_, **kwargs_):
        if gating.subclass:
            return gating.subclass(*args_, **kwargs_)
        else:
            return gating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_firstDerivative(self): return self.firstDerivative
    def set_firstDerivative(self, firstDerivative): self.firstDerivative = firstDerivative
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def get_secondDerivative(self): return self.secondDerivative
    def set_secondDerivative(self, secondDerivative): self.secondDerivative = secondDerivative
    def get_gateWidth(self): return self.gateWidth
    def set_gateWidth(self, gateWidth): self.gateWidth = gateWidth
    def export(self, outfile, level, namespace_='widar:', name_='gating', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gating')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='gating'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_double(self.period, input_name='period'))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            outfile.write(' firstDerivative="%s"' % self.gds_format_integer(self.firstDerivative, input_name='firstDerivative'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            outfile.write(' secondDerivative="%s"' % self.gds_format_integer(self.secondDerivative, input_name='secondDerivative'))
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            outfile.write(' gateWidth=%s' % (quote_attrib(self.gateWidth), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='gating', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gating'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %e,\n' % (self.period,))
        if self.firstDerivative is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            showIndent(outfile, level)
            outfile.write('firstDerivative = %d,\n' % (self.firstDerivative,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
        if self.secondDerivative is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            showIndent(outfile, level)
            outfile.write('secondDerivative = %d,\n' % (self.secondDerivative,))
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            showIndent(outfile, level)
            outfile.write('gateWidth = %s,\n' % (self.gateWidth,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (period): %s' % exp)
        value = find_attr_value_('firstDerivative', node)
        if value is not None and 'firstDerivative' not in already_processed:
            already_processed.append('firstDerivative')
            try:
                self.firstDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
        value = find_attr_value_('secondDerivative', node)
        if value is not None and 'secondDerivative' not in already_processed:
            already_processed.append('secondDerivative')
            try:
                self.secondDerivative = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('gateWidth', node)
        if value is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            self.gateWidth = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gating


class gateModel(GeneratedsSuper):
    """Model for gating. Period in milliseconds. Gate width is specified as
    percent of the period (when the gate is on). Epoch is specified
    as UT (or should it be the same as activation time)."""
    subclass = None
    superclass = None
    def __init__(self, gateWidth='0.5', period=None, epoch=None):
        self.gateWidth = _cast(None, gateWidth)
        self.period = _cast(float, period)
        self.epoch = _cast(None, epoch)
        pass
    def factory(*args_, **kwargs_):
        if gateModel.subclass:
            return gateModel.subclass(*args_, **kwargs_)
        else:
            return gateModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gateWidth(self): return self.gateWidth
    def set_gateWidth(self, gateWidth): self.gateWidth = gateWidth
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_epoch(self): return self.epoch
    def set_epoch(self, epoch): self.epoch = epoch
    def export(self, outfile, level, namespace_='widar:', name_='gateModel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gateModel')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='gateModel'):
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            outfile.write(' gateWidth=%s' % (quote_attrib(self.gateWidth), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            outfile.write(' period="%s"' % self.gds_format_double(self.period, input_name='period'))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            outfile.write(' epoch=%s' % (self.gds_format_string(quote_attrib(self.epoch).encode(ExternalEncoding), input_name='epoch'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='gateModel', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gateModel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gateWidth is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            showIndent(outfile, level)
            outfile.write('gateWidth = %s,\n' % (self.gateWidth,))
        if self.period is not None and 'period' not in already_processed:
            already_processed.append('period')
            showIndent(outfile, level)
            outfile.write('period = %e,\n' % (self.period,))
        if self.epoch is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            showIndent(outfile, level)
            outfile.write('epoch = "%s",\n' % (self.epoch,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gateWidth', node)
        if value is not None and 'gateWidth' not in already_processed:
            already_processed.append('gateWidth')
            self.gateWidth = value
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.append('period')
            try:
                self.period = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (period): %s' % exp)
        value = find_attr_value_('epoch', node)
        if value is not None and 'epoch' not in already_processed:
            already_processed.append('epoch')
            self.epoch = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gateModel


class modelCoeff(GeneratedsSuper):
    """Coefficent for the gate models is the same as for delay models. This
    format will be used during the testing. When the full system is
    installed ASCII representation may be replaced by hexBinary."""
    subclass = None
    superclass = None
    def __init__(self, cff=None, index=None):
        self.cff = _cast(float, cff)
        self.index = _cast(int, index)
        pass
    def factory(*args_, **kwargs_):
        if modelCoeff.subclass:
            return modelCoeff.subclass(*args_, **kwargs_)
        else:
            return modelCoeff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cff(self): return self.cff
    def set_cff(self, cff): self.cff = cff
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def export(self, outfile, level, namespace_='widar:', name_='modelCoeff', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modelCoeff')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='modelCoeff'):
        if self.cff is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            outfile.write(' cff="%s"' % self.gds_format_double(self.cff, input_name='cff'))
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='modelCoeff', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='modelCoeff'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cff is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            showIndent(outfile, level)
            outfile.write('cff = %e,\n' % (self.cff,))
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            showIndent(outfile, level)
            outfile.write('index = %d,\n' % (self.index,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cff', node)
        if value is not None and 'cff' not in already_processed:
            already_processed.append('cff')
            try:
                self.cff = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (cff): %s' % exp)
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.append('index')
            try:
                self.index = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modelCoeff


class averageFrequencyType(GeneratedsSuper):
    """'boxcar is the only supported algorithm at this time.For the
    'boxcar' algorithm, 'span' specifies how many frequency channels
    are used in each average."""
    subclass = None
    superclass = None
    def __init__(self, span=None, algorithm=None):
        self.span = _cast(int, span)
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if averageFrequencyType.subclass:
            return averageFrequencyType.subclass(*args_, **kwargs_)
        else:
            return averageFrequencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_span(self): return self.span
    def set_span(self, span): self.span = span
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='averageFrequencyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='averageFrequencyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='averageFrequencyType'):
        if self.span is not None and 'span' not in already_processed:
            already_processed.append('span')
            outfile.write(' span="%s"' % self.gds_format_integer(self.span, input_name='span'))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_format_string(quote_attrib(self.algorithm).encode(ExternalEncoding), input_name='algorithm'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='averageFrequencyType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='averageFrequencyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.span is not None and 'span' not in already_processed:
            already_processed.append('span')
            showIndent(outfile, level)
            outfile.write('span = %d,\n' % (self.span,))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = "%s",\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('span', node)
        if value is not None and 'span' not in already_processed:
            already_processed.append('span')
            try:
                self.span = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class averageFrequencyType


class windowType(GeneratedsSuper):
    """'hanning' is the only algorithm supported at this time.Optional.
    Specifies width of desired convolution function."""
    subclass = None
    superclass = None
    def __init__(self, width=None, algorithm=None):
        self.width = _cast(int, width)
        self.algorithm = _cast(None, algorithm)
        pass
    def factory(*args_, **kwargs_):
        if windowType.subclass:
            return windowType.subclass(*args_, **kwargs_)
        else:
            return windowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def export(self, outfile, level, namespace_='widar:', name_='windowType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='windowType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='widar:', name_='windowType'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_format_string(quote_attrib(self.algorithm).encode(ExternalEncoding), input_name='algorithm'), ))
    def exportChildren(self, outfile, level, namespace_='widar:', name_='windowType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='windowType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = %d,\n' % (self.width,))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = "%s",\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            try:
                self.width = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class windowType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'vciRequest'
        rootClass = vciRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_=rootTag, 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'vciRequest'
        rootClass = vciRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="vciRequest",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'vciRequest'
        rootClass = vciRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from vcixml_parser import *\n\n')
##     sys.stdout.write('import vcixml_parser as model_\n\n')
##     sys.stdout.write('rootObj = model_.rootTag(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "MsgCommentType",
    "actQueue",
    "activationTrigger",
    "affectedComponent",
    "antenna",
    "autoCorrSubset",
    "averageFrequencyType",
    "baseBand",
    "baseBandHw",
    "baseline",
    "bb",
    "bbParams",
    "blbPair",
    "blbProdIntegration",
    "cbeOutputQueue",
    "cbeProcessing",
    "cc",
    "cfgQueue",
    "cmAlerts",
    "cmDeleteSubarray",
    "cmFlushCmibQueues",
    "cmLogging",
    "cmMonitorControl",
    "component",
    "ctrlQueue",
    "gateModel",
    "gating",
    "host",
    "ifdDefault",
    "listOfStations",
    "modelCoeff",
    "modifySummedArray",
    "moduleLocation",
    "noiseDiode",
    "originator",
    "phaseBinning",
    "polProducts",
    "pp",
    "productPacking",
    "property",
    "queryCfgStatus",
    "radarMode",
    "sbParams",
    "station",
    "stationHw",
    "stationInputOutput",
    "stationPacking",
    "subArray",
    "subBand",
    "summedArray",
    "toneExtraction",
    "trowable",
    "vciReporting",
    "vciRequest",
    "vdif",
    "widarHost",
    "wideBandCorrelator",
    "windowType",
    "wpp"
    ]
